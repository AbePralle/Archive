class BCWriter : Visitor
  PROPERTIES
    this_type          : Type
    this_method        : Method

    writer             : TextWriter

    id_table()         : HashTable<<String,Integer>>
    id_list()          : String[]

    real_table()       : HashTable<<Real,Integer>>
    real_list()        : Real[]

    string_table()     : HashTable<<String,Integer>>
    string_list()      : String[]

    code()             : Integer[]

    line_info()        : Integer[]
    compact_line_info(): StringBuilder
    filepath_indices() : HashTable<<String,Integer>>
    filenames()        : String[]

    # line info tracking reset at the beginning of each method
    starting_ip        : Integer
    tokens()           : Token[]

    min_embedded_n = -(2^21)  : Integer
    max_embedded_n = (2^21)-1 : Integer

    label_addresses()     : HashTable<<String,Integer>>
    backpatch_addresses() : Integer[]
    backpatch_labels()    : String[]

  METHODS
    method compile( String filepath )
      #if (not filepath.ends_with(".bca")) filepath += ".bca"

      # Reset 'compiled' flag on all methods
      forEach (m in Analyzer.method_list) m.compiled = false

      id_table.clear
      id_list.clear
      string_table.clear
      string_list.clear

      code.clear
      code.add(Op.halt)  # Invariant: code[0] = HALT

      forEach (type in Types) compile( type )

      reset_line_info_for_new_method  # flush encoded line info

      writer = File(filepath).create_writer
      writer.print( "BARDCODE" )
      writer.write( 0xb0 )
      writer.write( 0x20 )
      writer.write( 0x13 )
      writer.write( 0x06 )
      writer.write( 0x01 )

      write( code.count )
      forEach (n in code) 
        write( n )
      endForEach

      write( id_list.count )
      forEach (id in id_list) write(id)

      write( Types.type_list.count )
      forEach (type in Types.type_list)
        write( id_table[type.name] )
        write( type.attributes.flags )
        write( type.attributes.tags.count )
        forEach (tag in type.attributes.tags) write( id_table[tag] )

        write( type.base_types.count )
        forEach (base_type in type.base_types) write( base_type.index )

        write( type.settings_list.count )
        forEach (p in type.settings_list)
          write( id_table[p.name] )
          write( p.type.index )
        endForEach

        write( type.property_list.count )
        forEach (p in type.property_list)
          write( id_table[p.name] )
          write( p.type.index )
        endForEach

      endForEach

      write( Types.main_type.index )

      write( Analyzer.method_list.count )
      forEach (m in Analyzer.method_list) write( m )

      write( Types.type_list.count )
      forEach (type in Types.type_list) write_method_tables( type )

      write( real_list.count )
      forEach (r in real_list) write( r )

      # Convert filepaths to filenames
      forEach (index of filenames) filenames[index] = File(filenames[index]).filename

      write( filenames.count )
      forEach (filename in filenames) write( filename )

      write( compact_line_info.count )
      forEach (n in compact_line_info) writer.write(n)

      write( string_list.count )
      forEach (st in string_list) write(st)

      writer.close

    method reset_line_info_for_new_method.Integer
      if (tokens.count?)
        compile_line_info
      endIf

      tokens.clear
      starting_ip = code.count

      local var index = compact_line_info.count
      return index

    method write_code( Token t, Integer n )
      if (tokens.count == 0) tokens.add(t)
      while ((tokens.count+starting_ip) < code.count) tokens.add( tokens.last )

      tokens.add( t )
      code.add( n )

    method write_code_with_arg_n( Token t, Integer opcode, Integer arg )
      if (tokens.count == 0) tokens.add(t)
      while ((tokens.count+starting_ip) < code.count) tokens.add( tokens.last )

      tokens.add( t )
      code.add( opcode_with_embedded_n(opcode,arg) )

    method write_jump( Token t, Integer jump_opcode, String to_label )
      backpatch_addresses.add( code.count )
      backpatch_labels.add( to_label )
      write_code( t, jump_opcode )

    method define_label( String label )
      if (label_addresses.contains(label)) throw BardError( "[Internal] Label already defined: " + label )

      label_addresses[label] = code.count

      # Remove jumps that jump to the very next address
      while (backpatch_addresses.count? and backpatch_addresses.last == code.count-1 and
        label_addresses.contains(backpatch_labels.last) and label_addresses[backpatch_labels.last] == code.count)

        backpatch_addresses.remove_last
        backpatch_labels.remove_last

        local var remap_address = code.count
        code.remove_last
        tokens.remove_last

        forEach (key in label_addresses.keys)
          if (label_addresses[key] == remap_address)
            label_addresses[key] = (remap_address - 1)
          endIf
        endForEach
      endWhile


    method backpatch_all( Method m )
      while (backpatch_labels.count? and label_addresses.contains(backpatch_labels.last))
        local var destination_address = label_addresses[ backpatch_labels.remove_last ]
        local var starting_address = backpatch_addresses.remove_last
        code[starting_address] = opcode_with_embedded_n( code[starting_address], destination_address - (starting_address+1) )
      endWhile

      if (backpatch_labels.count?)
        throw BardError( "[Internal] Unresolved label during backpatch: " + backpatch_labels.last )
      endIf

      # Fix up try/catch handler addresses
      forEach (handler in m.exception_handlers)
        forEach (c in handler.catches)
          #println( "ASSIGNING CATCH IP:" + label_addresses[c.label_name] )
          c.handler_ip = label_addresses[ c.label_name ]
        endForEach
      endForEach

      label_addresses.clear

    method discard_code( Integer old_count )
      code.discard_from( old_count )
      tokens.discard_from( old_count )

    method compile( Type type )
      this_type = type
      collect_id( type.name )
      forEach (tag in type.attributes.tags) collect_id( tag )
      forEach (p in type.property_list) collect_id( p.name )
      forEach (m in type.method_list) compile( m )

    method compile( Method m )
      if (m.compiled) return
      m.compiled = true

      collect_id( m.name )
      forEach (param in m.parameters)
        collect_id( param.name )
      endForEach
      if (m.return_type?)
        collect_id( m.return_type.name )
      endIf

      this_method = m
      m.ip = code.count
      m.line_info_index = reset_line_info_for_new_method

      if (not m.type_context.is_aspect or m.signature == "init_settings()") visit( m )

      if (m.return_type?)
        if (m.is_initializer)
          write_code( m.t, Op.return_this )
        else
          write_code( m.t, Op.throw_missing_return )
        endIf
      else
        local var t = m.t
        if (m.body.count?) t = m.body.last.t
        if (this_type.is_compound) write_code( t, opcode_with_embedded_n( Op.compound_return_nil_fp_adjust_n, this_type.slot_count) )
        else                       write_code( t, Op.return_nil )
      endIf

      backpatch_all( m )  # resolve all labels

      # Allow a spot for a native method implementation to rewrite the method
      # body with a NATIVE_CALL_INDEX_N and NATIVE_RETURN command.
      while (code.count - m.ip < 2) write_code( m.t, Op.nop )

      m.ip_limit = code.count

    method collect_id( String id ).Integer
      if (id_table.contains(id)) return id_table[id]

      local var index = id_table.count
      id_table[id] = index
      id_list.add( id )
      return index

    method collect_real( Real r ).Integer
      if (real_table.contains(r)) return real_table[r]

      local var index = real_table.count
      real_table[r] = index
      real_list.add( r )
      return index

    method collect_string( String st ).Integer
      if (string_table.contains(st)) return string_table[st]

      local var index = string_table.count
      string_table[st] = index
      string_list.add( st )
      return index

    method opcode_with_embedded_n( Integer opcode, Integer n ).Integer
      return opcode | n.left_shifted(10)

    method opcode_with_embedded_a_b( Integer opcode, Integer a, Integer b ).Integer
      return opcode | (a&0x7fff).left_shifted(10) | (b&0x7fff).left_shifted(21)

    method write( Integer n )
      if (n >= -64 and n <= 127)
        # %01111111 or %11xxxxxx
        writer.write( n )
      elseIf (n >= 128 and n <= 0xfff)
        # %1000xxxx yyyyyyyy
        writer.write( 0x80 | (n.right_shifted(8)) )
        writer.write( n )
      elseIf (n >= 0x1000 and n <= 0xfFFFF)
        # %1001xxxx yyyyyyyy zzzzzzzz
        writer.write( 0x90 | (n.right_shifted(16)) )
        writer.write( n.right_shifted(8) )
        writer.write( n )
      elseIf (n >= 0x100000 and n <= 0xfFFFFff)
        # %1010xxxx yyyyyyyy zzzzzzzz aaaaaaaa
        writer.write( 0xa0 | (n.right_shifted(24)) )
        writer.write( n.right_shifted(16) )
        writer.write( n.right_shifted(8) )
        writer.write( n )
      else
        # %10110000 xxxxxxxx yyyyyyyy zzzzzzzz aaaaaaaa
        writer.write( 0xb0 )
        writer.write( n.right_shifted(24) )
        writer.write( n.right_shifted(16) )
        writer.write( n.right_shifted(8) )
        writer.write( n )
      endIf

    method write( Real r )
      local Int64 data = ( r as Int64 )
      write( data.right_shifted(32) as Integer )
      write( data as Integer )

    method write( String st )
      write( st.count )
      forEach (ch in st) write( ch )

    method write_method_tables( Type type )
      write( type.method_list.count )
      forEach (m in type.method_list)
        write( m.global_index )
      endForEach

      local var aspect_count = 0
      forEach (base_type in type.base_types)
        if (base_type.is_aspect) ++aspect_count
      endForEach

      write( aspect_count )
      forEach (base_type in type.base_types)
        if (base_type.is_aspect)
          write( base_type.index )
          write( base_type.method_list.count )
          forEach (m in base_type.method_list)
            write( type.must_find_method(m.call_signature,m.return_type).global_index )
          endForEach
        endIf
      endForEach

    method write( Method m )
      #println( "@$ $::$" (writer.position.to_String(16),m.type_context,m.signature))
      write( m.type_context.index )
      write( id_table[m.name] )
      write( m.parameters.count )
      if (m.return_type?) write( m.return_type.index )
      else                write( -1 )
      write( m.locals.count )

      forEach (v in m.locals)
        write( v.type.index )
      endForEach
      write( m.ip )
      write( m.ip_limit )
      write( m.line_info_index )

      write( m.attributes.flags )
      write( m.attributes.tags.count )
      forEach (tag in m.attributes.tags) write( id_table[tag] )

      write( m.exception_handlers.count )
      forEach (cur_handler in m.exception_handlers)
        write( cur_handler.ip_start )
        write( cur_handler.ip_limit )
        write( cur_handler.catches.count )
        forEach (cur_catch in cur_handler.catches)
          write( cur_catch.local_info.type.index )
          write( cur_catch.handler_ip )
          write( cur_catch.local_info.slot_index )
        endForEach
      endForEach

    method next_control_id.String
      return Analyzer.unique_id

    method print
      println( "# identifier".pluralize(id_list.count) )
      forEach (index of id_list)
        println( "  $(3) $" (index,id_list[index]) )
      endForEach
      println

      println( "# string".pluralize(string_list.count) )
      forEach (index of string_list)
        println( "  $(3) $" (index,string_list[index]) )
      endForEach
      println

    method compile_line_info
      # FORMAT
      #
      # file_switches
      #
      # forEach (1..file_switches)
      #   filename_index
      #   starting_line_number
      #   ip  # always > any previous IP
      #
      #   delta_count
      #   forEach (1..delta_count)
      #     line_delta
      #     ip_delta
      #   endForEach
      #
      # endForEach

      # Collect token filepaths
      forEach (t in tokens)
        if (not filepath_indices.contains(t.filepath))
          filepath_indices[t.filepath] = filenames.count
          filenames.add( t.filepath )
        endIf
      endForEach

      local var file_switches_index = line_info.count
      line_info.add( 0 )

      local String cur_filename = null
      local var cur_line = 0
      local var cur_ip = starting_ip
      local var previous_ip = starting_ip
      local var delta_count_index = -1
      forEach (t in tokens)
        if ((cur_filename is null) or t.filepath != cur_filename)
          cur_filename = t.filepath
          cur_line = t.line
          ++line_info[ file_switches_index ]
          line_info.add( filepath_indices[cur_filename] )
          line_info.add( cur_line )
          line_info.add( cur_ip )
          previous_ip = cur_ip
          delta_count_index = line_info.count
          line_info.add( 0 )
        else
          if (cur_line != t.line)
            ++line_info[ delta_count_index ]
            line_info.add( t.line - cur_line )
            line_info.add( cur_ip - previous_ip )
            previous_ip = cur_ip
            cur_line = t.line
          endIf
        endIf
        ++cur_ip
      endForEach

      # Transfer unencoded line_info to compact, encoded line_info
      local var saved_writer = writer
      writer = compact_line_info
      forEach (n in line_info) write(n)
      line_info.clear
      writer = saved_writer

    method visit( CmdStatementList cmd )
      Analyzer.context.push_local_scope
      forEach (statement in cmd)
        statement.dispatch( this )
        if (statement.type?)
          if (statement.type.is_primitive or statement.type.is_reference)
            write_code( statement.t, Op.pop_discard )
          else
            write_code( statement.t, opcode_with_embedded_n( Op.resolve_pop_discard_compound_type_n, statement.type.index) )
          endIf
        endIf
      endForEach
      Analyzer.context.pop_local_scope

    method visit( CmdTron cmd ).Cmd
      write_code( cmd.t, Op.trace_on )
      return cmd

    method visit( CmdTroff cmd ).Cmd
      write_code( cmd.t, Op.trace_off )
      return cmd

    method visit( CmdReturnNil cmd ).Cmd
      if (this_method.is_initializer)
        write_code( cmd.t, Op.return_this )

      elseIf (this_type.is_compound)
        write_code( cmd.t, opcode_with_embedded_n( Op.compound_return_nil_fp_adjust_n, this_type.slot_count) )

      else
        write_code( cmd.t, Op.return_nil )
      endIf
      return cmd

    method visit( CmdReturnThis cmd ).Cmd
      write_code( cmd.t, Op.return_this )
      return cmd

    method visit( CmdReturnValue cmd ).Cmd
      cmd.operand.dispatch( this )
      local var type = cmd.operand.type
      local var opcode = 0
      local var arg = 0
      local var context_type = this_type
      if (context_type.is_compound and context_type.slot_count > 1)
        arg = this_type.slot_count - 1
        which (type.classification)
          case Type.reference_type: opcode = Op.compound_return_object_fp_adjust_n
          case Type.real_type:      opcode = Op.compound_return_real_fp_adjust_n
          case Type.integer_type:   opcode = Op.compound_return_integer_fp_adjust_n
          case Type.character_type: opcode = Op.compound_return_integer_fp_adjust_n
          case Type.byte_type:      opcode = Op.compound_return_integer_fp_adjust_n
          case Type.logical_type:   opcode = Op.compound_return_integer_fp_adjust_n
          case Type.compound_type
            write_code( cmd.t, opcode_with_embedded_a_b(Op.compound_return_compound_a_slots_fp_adjust_b, type.slot_count, (arg+1)-type.slot_count ) )
            return cmd
          others: throw cmd.error( "TODO: CmdReturnValue for type " + type )
        endWhich
      else
        which (type.classification)
          case Type.reference_type: opcode = Op.return_object
          case Type.real_type:      opcode = Op.return_real
          case Type.integer_type:   opcode = Op.return_integer
          case Type.character_type: opcode = Op.return_integer
          case Type.byte_type:      opcode = Op.return_integer
          case Type.logical_type:   opcode = Op.return_integer
          case Type.compound_type:  opcode = Op.return_compound_n_slots; arg = type.slot_count
          others: throw cmd.error( "TODO: CmdReturnValue for type " + type )
        endWhich
      endIf

      write_code( cmd.t, opcode_with_embedded_n( opcode, arg ) )
      return cmd

    method visit( CmdSpecializeReference cmd ).Cmd
      cmd.operand .= dispatch( this )
      write_code( cmd.t, opcode_with_embedded_n(Op.specialize_as_type_index_n,cmd.as_type.index) )
      return cmd

    method visit( CmdConvertIntegerToReal cmd ).Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.convert_integer_to_real )
      return cmd

    method visit( CmdConvertRealToInteger cmd ).Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.convert_real_to_integer )
      return cmd

    method visit( CmdConvertCharacterToInteger cmd ).Cmd
      cmd.operand.dispatch( this )
      # No actual operator is required
      return cmd

    method visit( CmdConvertByteToInteger cmd ).Cmd
      cmd.operand.dispatch( this )
      # No actual operator is required
      return cmd

    method visit( CmdConvertIntegerToCharacter cmd ).Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.convert_integer_to_character )
      return cmd

    method visit( CmdConvertIntegerToByte cmd ).Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.convert_integer_to_byte )
      return cmd

    method visit( CmdConvertLogicalToInteger cmd ).Cmd
      cmd.operand.dispatch( this )
      # No actual operator is required
      return cmd

      #method visit( CmdCharacterAsInteger cmd ).Cmd
      #cmd.operand.dispatch( this )
      # No actual operator is required
      #return cmd

      #method visit( CmdIntegerAsCharacter cmd ).Cmd
      #cmd.operand.dispatch( this )
      ## No actual operator is required
      #return cmd


    method visit( CmdIf cmd ).Cmd
      local var next_block_index = 2
      cmd.condition.dispatch( this )
      write_jump( cmd.condition.t, Op.jump_if_false_to_offset_n, "next_" + next_block_index + "_" + cmd.control_id )

      cmd.body.dispatch( this )
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )

      forEach (index of cmd.elseIf_conditions)
        define_label( "next_" + next_block_index + "_" + cmd.control_id )
        ++next_block_index

        local var condition = cmd.elseIf_conditions[index]
        condition.dispatch( this )
        write_jump( condition.t, Op.jump_if_false_to_offset_n, "next_" + next_block_index + "_" + cmd.control_id )

        cmd.elseIf_bodies[index].dispatch( this )
        write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )
      endForEach

      define_label( "next_" + next_block_index + "_" + cmd.control_id )
      if (cmd.else_body?)
        cmd.else_body.dispatch( this )
      endIf

      define_label( "end_" + cmd.control_id )

      return cmd

    method visit( CmdContingent cmd ).Cmd
      cmd.body.dispatch( this )

      if(cmd.satisfied_body?)
        define_label( "satisfied_" + cmd.control_id )
        cmd.satisfied_body.dispatch( this )
      endIf

      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )

      if(cmd.unsatisfied_body?)
        define_label( "unsatisfied_" + cmd.control_id )
        cmd.unsatisfied_body.dispatch( this )
      endIf

      if(not cmd.satisfied_body?)   define_label( "satisfied_" + cmd.control_id )
      if(not cmd.unsatisfied_body?) define_label( "unsatisfied_" + cmd.control_id )
      define_label("end_" + cmd.control_id)

      return cmd

    method visit( CmdNecessary cmd ).Cmd
      cmd.operand.dispatch( this )
      write_jump( cmd.t, Op.jump_if_false_to_offset_n, "unsatisfied_" + cmd.target_id )
      return cmd

    method visit( CmdSufficient cmd ).Cmd
      cmd.operand.dispatch( this )
      write_jump( cmd.t, Op.jump_if_true_to_offset_n, "satisfied_" + cmd.target_id )
      return cmd

      throw cmd.t.error( "No enclosing 'contingent' for 'sufficient' clause." )

    method visit( CmdEscapeContingent cmd ).Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( CmdAnonymousBlock cmd ).Cmd
      cmd.body.dispatch( this )
      return cmd

    method visit( CmdWhile cmd ).Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "next_iteration_" + cmd.control_id )

      define_label( "body_" + cmd.control_id )
      cmd.body.dispatch( this )

      define_label( "next_iteration_" + cmd.control_id )
      cmd.condition.dispatch( this )

      write_jump( cmd.t, Op.jump_if_true_to_offset_n, "body_" + cmd.control_id )

      define_label( "end_" + cmd.control_id )

      return cmd

    method visit( CmdEscapeWhile cmd ).Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( CmdLoop cmd ).Cmd
      #write_jump( cmd.t, Op.jump_to_offset_n, "loop_" + cmd.control_id)

      define_label( "loop_" + cmd.control_id )
      define_label( "next_iteration_" + cmd.control_id )
      cmd.body.dispatch( this )

      write_jump( cmd.t, Op.jump_to_offset_n, "next_iteration_" + cmd.control_id)

      define_label( "end_" + cmd.control_id )

      return cmd

    method visit( CmdTry cmd ).Cmd
      local var ip_start = code.count
      cmd.body.dispatch( this )
      local var ip_limit = code.count
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )

      local var m = Analyzer.context.this_method
      m.exception_handlers.add( ExceptionHandler(ip_start,ip_limit) )

      local var catch_index = 0
      forEach (cur_catch in cmd.catches)
        Analyzer.context.push_local_scope
        Analyzer.add_local( cur_catch.local_info )
        local var label_name = "catch_$_$_$" (cmd.control_id,m.exception_handlers.count-1,catch_index)
        define_label( label_name )
        m.exception_handlers.last.catches.add( ExceptionHandlerCatch(cur_catch.local_info,label_name) )
        cur_catch.body.dispatch( this )
        write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )
        Analyzer.context.pop_local_scope
        ++catch_index
      endForEach

      define_label( "end_" + cmd.control_id )

      return cmd

    method visit( CmdThrow cmd ).Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.throw_exception )
      return cmd

    method visit( CmdEscapeLoop cmd ).Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( CmdEscapeForEach cmd ).Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( CmdEscapeIf cmd ).Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( CmdEscapeTry cmd ).Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( CmdNextIteration cmd ).Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "next_iteration_" + cmd.target_id )
      return cmd

    method visit( CmdLiteralReal cmd ).Cmd
      local var integer_value = Integer(cmd.value)
      if (integer_value == cmd.value and integer_value >= min_embedded_n and integer_value <= max_embedded_n)
        write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_integer_n_as_real, integer_value ) )
      else
        write_code( cmd.t, Op.push_literal_real )
        local var real_slot = collect_real( cmd.value )
        write_code( cmd.t, real_slot )
      endIf
      return cmd

    method visit( CmdLiteralString cmd ).Cmd
      write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_string_n, collect_string(cmd.value) ) );
      return cmd

    method visit( CmdLiteralNull cmd ).Cmd
      write_code( cmd.t, Op.push_literal_object_null );
      return cmd

    method visit( CmdLiteralInteger cmd ).Cmd
      if (cmd.value >= min_embedded_n and cmd.value <= max_embedded_n)
        write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_integer_n, cmd.value ) )
      else
        write_code( cmd.t, Op.push_literal_integer )
        write_code( cmd.t, cmd.value )
      endIf
      return cmd

    method visit( CmdLiteralByte cmd ).Cmd
      write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_integer_n, cmd.value ) )
      return cmd

    method visit( CmdLiteralArray cmd ).Cmd
      local var t = cmd.t
      local var slot_count = cmd.element_type.slot_count
      local var element_type_classification = cmd.element_type.classification
      local var elements = cmd.elements

      write_code_with_arg_n( t, Op.push_literal_integer_n, cmd.elements.count )  # size arg
      write_code_with_arg_n( t, Op.create_array_type_n, cmd.array_type.index )
      write_code( t, cmd.element_type.index )

      forEach (index of elements)
        # Index to write new value at.
        if (index < max_embedded_n)
          write_code_with_arg_n( t, Op.push_literal_integer_n, index )
        else
          write_code( t, Op.push_literal_integer )
          write_code( t, index )
        endIf

        # Value to store at index
        elements[index].dispatch( this )

        # Determine opcode
        local var opcode = -1
        which (element_type_classification)
          case Type.reference_type: opcode = Op.write_array_element_object
          case Type.real_type:      opcode = Op.write_array_element_real
          case Type.integer_type:   opcode = Op.write_array_element_integer
          case Type.character_type: opcode = Op.write_array_element_character
          case Type.byte_type:      opcode = Op.write_array_element_byte
          case Type.logical_type:   opcode = Op.write_array_element_byte
          case Type.compound_type
            write_code_with_arg_n( t, Op.write_array_element_compound_n_slots, slot_count )
            return cmd
          others: throw Error()
        endWhich

        if (opcode != -1) write_code( t, opcode )
      endForEach

      return cmd

    method visit( CmdLiteralCharacter cmd ).Cmd
      write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_integer_n, Integer(cmd.value) ) )
      return cmd

    method visit( CmdLiteralLogical cmd ).Cmd
      local var value = 0
      if (cmd.value?) value = 1
      write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_integer_n, value ) )
      return cmd

    method visit( CmdReadLocal cmd ).Cmd
      local var type = cmd.local_info.type
      local var opcode = 0
      which (type.classification)
        case Type.reference_type: opcode = Op.read_local_object_n
        case Type.real_type:      opcode = Op.read_local_real_n
        case Type.integer_type:   opcode = Op.read_local_integer_n
        case Type.character_type: opcode = Op.read_local_integer_n
        case Type.byte_type:      opcode = Op.read_local_integer_n
        case Type.logical_type:   opcode = Op.read_local_integer_n
        case Type.compound_type
          local var v = cmd.local_info
          write_code( cmd.t, opcode_with_embedded_a_b(Op.read_local_compound_slot_a_size_b,-v.slot_index,v.type.slot_count) )
          return cmd
        others
        throw Error( "TODO: type " + type )
      endWhich
      write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.local_info.slot_index) )
      return cmd

    method visit( CmdWriteLocal cmd ).Cmd
      cmd.new_value.dispatch( this )

      local var type = cmd.local_info.type
      local var opcode = 0
      which (type.classification)
        case Type.reference_type: opcode = Op.write_local_object_n
        case Type.real_type:      opcode = Op.write_local_real_n
        case Type.integer_type:   opcode = Op.write_local_integer_n
        case Type.character_type: opcode = Op.write_local_integer_n
        case Type.byte_type:      opcode = Op.write_local_integer_n
        case Type.logical_type:   opcode = Op.write_local_integer_n
        case Type.compound_type
          local var v = cmd.local_info
          write_code( cmd.t, opcode_with_embedded_a_b(Op.write_local_compound_slot_a_size_b,-v.slot_index,v.type.slot_count) )
          return cmd
        others
          throw Error("TODO")
      endWhich

      write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.local_info.slot_index) )
      return cmd

    method visit( CmdWriteLocalDefault cmd ).Cmd
      local var v = cmd.local_info
      local var type = v.type
      local var opcode = -1
      which (type.classification)
        case Type.reference_type: opcode = Op.clear_local_object_n
        case Type.real_type:      opcode = Op.clear_local_real_n
        case Type.integer_type:   opcode = Op.clear_local_integer_n
        case Type.character_type: opcode = Op.clear_local_integer_n
        case Type.byte_type:      opcode = Op.clear_local_integer_n
        case Type.logical_type:   opcode = Op.clear_local_integer_n
        case Type.compound_type
          write_code( cmd.t, opcode_with_embedded_a_b(Op.clear_local_compound_slot_a_size_b,-v.slot_index,type.slot_count) )
        others
        throw cmd.t.error( "CmdWriteLocalDefault not implemented for type $." (type) )
      endWhich

      write_code( cmd.t, opcode_with_embedded_n(opcode,v.slot_index) )

      return cmd

    method visit( CmdInstanceOf cmd ).Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, opcode_with_embedded_n(Op.instance_of_type_index_n,cmd.target_type.index) )
      return cmd

    method generate_local_op_assign( CmdOpAssignLocal cmd, Integer opcode, Integer mask )
      local var t = cmd.t
      local var slot_index = cmd.local_info.slot_index

      write_code_with_arg_n( t, Op.read_local_integer_n, slot_index )
      cmd.new_value.dispatch( this )
      write_code( t, opcode )
      write_code_with_arg_n( t, Op.push_literal_integer_n, mask )
      write_code( t, Op.bitwise_and_integer )
      write_code_with_arg_n( t, Op.write_local_integer_n, slot_index )

    method write_local_op_assign( CmdOpAssignLocal cmd, Integer real_opcode, Integer integer_opcode, Integer other_opcode ).Cmd
      local var v = cmd.local_info
      local var slot_index = v.slot_index
      which (v.type.classification)
        case Type.real_type
          if (real_opcode == -1) escapeWhich
          cmd.new_value.dispatch( this )
          write_code_with_arg_n( cmd.t, real_opcode, slot_index )

        case Type.integer_type
          cmd.new_value.dispatch( this )
          write_code_with_arg_n( cmd.t, integer_opcode, slot_index )

        case Type.character_type
          generate_local_op_assign( cmd, other_opcode, 65535 )

        case Type.byte_type
          generate_local_op_assign( cmd, other_opcode, 255 )

        others
          throw cmd.t.error( "Variable type $ does not support '$' operation." (v.type,cmd.name) )
      endWhich

      return cmd

    method visit( CmdAddAssignLocal cmd ).Cmd
      return write_local_op_assign( cmd, Op.add_assign_local_real_n, Op.add_assign_local_integer_n, Op.add_integer )

    method visit( CmdSubtractAssignLocal cmd ).Cmd
      return write_local_op_assign( cmd, Op.subtract_assign_local_real_n, Op.subtract_assign_local_integer_n, Op.subtract_integer )

    method visit( CmdMultiplyAssignLocal cmd ).Cmd
      return write_local_op_assign( cmd, Op.multiply_assign_local_real_n, Op.multiply_assign_local_integer_n, Op.multiply_integer )

    method visit( CmdDivideAssignLocal cmd ).Cmd
      return write_local_op_assign( cmd, Op.divide_assign_local_real_n, Op.divide_assign_local_integer_n, Op.divide_integer )

    method visit( CmdModAssignLocal cmd ).Cmd
      return write_local_op_assign( cmd, Op.mod_assign_local_real_n, Op.mod_assign_local_integer_n, Op.mod_integer )

    method visit( CmdPowerAssignLocal cmd ).Cmd
      return write_local_op_assign( cmd, Op.power_assign_local_real_n, Op.power_assign_local_integer_n, Op.power_integer )

    method visit( CmdBitwiseAndAssignLocal cmd ).Cmd
      return write_local_op_assign( cmd, -1, Op.bitwise_and_assign_local_integer_n, Op.bitwise_and_integer )

    method visit( CmdBitwiseOrAssignLocal cmd ).Cmd
      return write_local_op_assign( cmd, -1, Op.bitwise_or_assign_local_integer_n, Op.bitwise_or_integer )

    method visit( CmdBitwiseXorAssignLocal cmd ).Cmd
      return write_local_op_assign( cmd, -1, Op.bitwise_xor_assign_local_integer_n, Op.logical_xor )

    method visit( CmdAccessAssignLocal cmd ).Cmd
      cmd.access.dispatch( this )

      local var opcode = 0
      which (cmd.access.type.classification)
        case Type.reference_type: opcode = Op.write_local_object_n
        case Type.real_type:      opcode = Op.write_local_real_n
        case Type.integer_type:   opcode = Op.write_local_integer_n
        case Type.character_type: opcode = Op.write_local_integer_n
        case Type.byte_type:      opcode = Op.write_local_integer_n
        case Type.logical_type:   opcode = Op.write_local_integer_n
        case Type.compound_type
          local var v = cmd.local_info
          write_code( cmd.t, opcode_with_embedded_a_b(Op.write_local_compound_slot_a_size_b,-v.slot_index,v.type.slot_count) )
          return cmd
        others
          throw Error("TODO")
      endWhich

      write_code_with_arg_n( cmd.t, opcode, cmd.local_info.slot_index )

      return cmd

    method visit( CmdAccessAssignSetting cmd ).Cmd
      cmd.access.dispatch( this )
      write_code_with_arg_n( cmd.t, Op.resolve_write_setting_index_n, cmd.setting.index )
      write_code( cmd.t, cmd.setting.type_context.index )

      return cmd

    method visit( CmdIncrementLocal cmd ).Cmd
      which (cmd.local_info.type.classification)
        case Type.real_type
          write_code( cmd.t, opcode_with_embedded_n(Op.increment_local_real_n,cmd.local_info.slot_index) )

        case Type.integer_type
          write_code( cmd.t, opcode_with_embedded_n(Op.increment_local_integer_n,cmd.local_info.slot_index) )

        case Type.character_type
          write_code( cmd.t, opcode_with_embedded_n(Op.increment_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.read_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,65535) )
          write_code( cmd.t, Op.bitwise_and_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.write_local_integer_n,cmd.local_info.slot_index) )

        case Type.byte_type
          write_code( cmd.t, opcode_with_embedded_n(Op.increment_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.read_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,255) )
          write_code( cmd.t, Op.bitwise_and_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.write_local_integer_n,cmd.local_info.slot_index) )

        others
          throw cmd.t.error( "Cannot increment a value of type $." (cmd.local_info.type) )
      endWhich

      return cmd

    method write_increment_setting( CmdIncrementSetting cmd, Integer mask )
      if (cmd.context?) cmd.context.dispatch( this )

    method visit( CmdIncrementSetting cmd ).Cmd
      local var cmd_t = cmd.t
      local var setting_index = cmd.setting.index

      if (cmd.context?)
        cmd.context.dispatch( this )
        if (cmd.context.type.is_compound)
          write_code( cmd_t, opcode_with_embedded_n( Op.resolve_pop_discard_compound_type_n, cmd.context.type.index) )
        else
          write_code( cmd_t, Op.pop_discard )
        endIf
      endIf

      local var setting_type_index = cmd.setting.type_context.index

      write_code_with_arg_n( cmd_t, Op.resolve_read_setting_index_n, setting_index )
      write_code( cmd_t, setting_type_index )

      which (cmd.setting.type.classification)
        case Type.real_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n_as_real, 1 )
          write_code( cmd_t, Op.add_real )

        case Type.integer_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.add_integer )

        case Type.character_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.add_integer )
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 65535 )
          write_code( cmd_t, Op.bitwise_and_integer )

        case Type.byte_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.add_integer )
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 255 )
          write_code( cmd_t, Op.bitwise_and_integer )

        others
          throw cmd_t.error( "Cannot increment a value of type $." (cmd.setting.type) )
      endWhich

      write_code_with_arg_n( cmd.t, Op.resolve_write_setting_index_n, setting_index )
      write_code( cmd.t, setting_type_index )

      return cmd

    method visit( CmdDecrementSetting cmd ).Cmd
      local var cmd_t = cmd.t
      local var setting_index = cmd.setting.index

      if (cmd.context?)
        cmd.context.dispatch( this )
        if (cmd.context.type.is_compound)
          write_code( cmd_t, opcode_with_embedded_n( Op.resolve_pop_discard_compound_type_n, cmd.context.type.index) )
        else
          write_code( cmd_t, Op.pop_discard )
        endIf
      endIf

      local var setting_type_index = cmd.setting.type_context.index

      write_code_with_arg_n( cmd_t, Op.resolve_read_setting_index_n, setting_index )
      write_code( cmd_t, setting_type_index )

      which (cmd.setting.type.classification)
        case Type.real_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n_as_real, 1 )
          write_code( cmd_t, Op.subtract_real )

        case Type.integer_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.subtract_integer )

        case Type.character_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.subtract_integer )
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 65535 )
          write_code( cmd_t, Op.bitwise_and_integer )

        case Type.byte_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.subtract_integer )
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 255 )
          write_code( cmd_t, Op.bitwise_and_integer )

        others
          throw cmd_t.error( "Cannot decrement a value of type $." (cmd.setting.type) )
      endWhich

      write_code_with_arg_n( cmd.t, Op.resolve_write_setting_index_n, setting_index )
      write_code( cmd.t, setting_type_index )

      return cmd


    method visit( CmdIncrementProperty cmd ).Cmd
      if (cmd.context?) cmd.context.dispatch( this )

      local var property_index = cmd.property.index
      local var classification = cmd.property.type.classification
      which (classification)
        case Type.real_type, Type.integer_type
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_increment_property, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_increment_this_property,property_index )

        case Type.character_type
          if (cmd.context?)
            write_code( cmd.t, Op.duplicate_object )
            write_code_with_arg_n( cmd.t, Op.resolve_read_property_index_n, property_index )
          else
            write_code_with_arg_n( cmd.t, Op.resolve_read_this_property_index_n, property_index )
          endIf
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,1) )
          write_code( cmd.t, Op.add_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,65535) )
          write_code( cmd.t, Op.bitwise_and_integer )
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_write_property_index_n, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_write_this_property_index_n, property_index )

        case Type.byte_type
          if (cmd.context?)
            write_code( cmd.t, Op.duplicate_object )
            write_code_with_arg_n( cmd.t, Op.resolve_read_property_index_n, property_index )
          else
            write_code_with_arg_n( cmd.t, Op.resolve_read_this_property_index_n, property_index )
          endIf
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,1) )
          write_code( cmd.t, Op.add_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,255) )
          write_code( cmd.t, Op.bitwise_and_integer )
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_write_property_index_n, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_write_this_property_index_n, property_index )

        others
        throw cmd.t.error( "Cannot increment a value of type $." (cmd.property.type) )
      endWhich
      return cmd

    method visit( CmdDecrementLocal cmd ).Cmd
      which (cmd.local_info.type.classification)
        case Type.real_type
          write_code( cmd.t, opcode_with_embedded_n(Op.decrement_local_real_n,cmd.local_info.slot_index) )

        case Type.integer_type
          write_code( cmd.t, opcode_with_embedded_n(Op.decrement_local_integer_n,cmd.local_info.slot_index) )

        case Type.character_type
          write_code( cmd.t, opcode_with_embedded_n(Op.decrement_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.read_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,65535) )
          write_code( cmd.t, Op.bitwise_and_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.write_local_integer_n,cmd.local_info.slot_index) )

        case Type.byte_type
          write_code( cmd.t, opcode_with_embedded_n(Op.decrement_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.read_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,255) )
          write_code( cmd.t, Op.bitwise_and_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.write_local_integer_n,cmd.local_info.slot_index) )

        others
          throw cmd.t.error( "Cannot decrement a value of type $." (cmd.local_info.type) )
      endWhich

      return cmd


    method visit( CmdDecrementProperty cmd ).Cmd
      if (cmd.context?) cmd.context.dispatch( this )

      local var property_index = cmd.property.index
      local var classification = cmd.property.type.classification
      which (classification)
        case Type.real_type, Type.integer_type
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_decrement_property, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_decrement_this_property,property_index )

        case Type.character_type
          if (cmd.context?)
            write_code( cmd.t, Op.duplicate_object )
            write_code_with_arg_n( cmd.t, Op.resolve_read_property_index_n, property_index )
          else
            write_code_with_arg_n( cmd.t, Op.resolve_read_this_property_index_n, property_index )
          endIf
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,1) )
          write_code( cmd.t, Op.subtract_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,65535) )
          write_code( cmd.t, Op.bitwise_and_integer )
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_write_property_index_n, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_write_this_property_index_n, property_index )

        case Type.byte_type
          if (cmd.context?)
            write_code( cmd.t, Op.duplicate_object )
            write_code_with_arg_n( cmd.t, Op.resolve_read_property_index_n, property_index )
          else
            write_code_with_arg_n( cmd.t, Op.resolve_read_this_property_index_n, property_index )
          endIf
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,1) )
          write_code( cmd.t, Op.subtract_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,255) )
          write_code( cmd.t, Op.bitwise_and_integer )
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_write_property_index_n, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_write_this_property_index_n, property_index )

        others
        throw cmd.t.error( "Cannot decrement a value of type $." (cmd.property.type) )
      endWhich
      return cmd


    method visit( CmdNewObject cmd ).Cmd
      write_code( cmd.t, opcode_with_embedded_n(Op.create_object_of_type_index_n,cmd.of_type.index) )
      if (cmd.args?) cmd.args.dispatch( this )
      write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,cmd.init_method.global_index) )
      return cmd

    method visit( CmdThis cmd ).Cmd
      if (this_type.is_compound)
        write_code( cmd.t, opcode_with_embedded_n(Op.push_this_compound_n_slots,this_type.slot_count) )
      elseIf (this_type.is_primitive)
        if (this_type.is_Real) write_code( cmd.t, Op.push_this_real )
        else                   write_code( cmd.t, Op.push_this_integer )
      else
        write_code( cmd.t, Op.push_this )
      endIf
      return cmd

    method visit( CmdReadSingleton cmd ).Cmd
      if (cmd.of_type.is_aspect)
        throw cmd.t.error( "Illegal reference - aspects do not have singleton objects." )
      elseIf (cmd.of_type.is_reference)
        write_code( cmd.t, opcode_with_embedded_n(Op.read_singleton_of_type_index_n,cmd.of_type.index) )
      else
        write_code( cmd.t, opcode_with_embedded_n(Op.read_singleton_compound_of_type_index_n,cmd.of_type.index) )
      endIf
      return cmd

    method visit( CmdReadSetting cmd ).Cmd
      local var setting_type = cmd.setting.type

      local Type context_type
      if (cmd.context?) context_type = cmd.context.type
      else              context_type = this_type

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        # Arbitrary context (non-'this')
        if (cmd.context notInstanceOf CmdReadSingleton)
          cmd.context.dispatch( this )
          if (cmd.context.type.is_compound)
            write_code( cmd.t, opcode_with_embedded_n( Op.resolve_pop_discard_compound_type_n, cmd.context.type.index) )
          else
            write_code( cmd.t, Op.pop_discard )
          endIf
        endIf

        write_code( cmd.t, opcode_with_embedded_n(Op.resolve_read_setting_index_n,cmd.setting.index) )

      else
        # Read setting with no context needing discarding.
        write_code( cmd.t, opcode_with_embedded_n(Op.resolve_read_setting_index_n,cmd.setting.index) )
      endIf
      write_code( cmd.t, cmd.setting.type_context.index )

      # Extra arg space for object setting that is a compound
      if (setting_type.is_compound) write_code( cmd.t, Op.halt )

      return cmd

    method visit( CmdReadProperty cmd ).Cmd
      local var opcode = 0

      local var property_type = cmd.property.type

      local Type context_type
      if (cmd.context?) context_type = cmd.context.type
      else              context_type = this_type

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        # Arbitrary context (non-'this')
        if (context_type.is_compound)
          # Element of a compound
          cmd.context.dispatch( this )
          local var delta_sp      = context_type.slot_count - property_type.slot_count
          if (delta_sp?)
            which (property_type.classification)
              case Type.reference_type: opcode = Op.read_compound_object_offset_a_delta_sp_b
              case Type.real_type:      opcode = Op.read_compound_real_offset_a_delta_sp_b
              case Type.integer_type:   opcode = Op.read_compound_integer_offset_a_delta_sp_b
              case Type.character_type: opcode = Op.read_compound_integer_offset_a_delta_sp_b
              case Type.byte_type:      opcode = Op.read_compound_integer_offset_a_delta_sp_b
              case Type.logical_type:   opcode = Op.read_compound_integer_offset_a_delta_sp_b
              case Type.compound_type
                # Replace a compound on the stack with its subset
                write_code( cmd.t, opcode_with_embedded_a_b(Op.read_compound_subset_offset_a_delta_sp_b, cmd.property.slot_index, delta_sp) )
                write_code( cmd.t, property_type.slot_count )  # Element slot size is a separate parameter
                return cmd
            endWhich
            write_code( cmd.t, opcode_with_embedded_a_b(opcode, cmd.property.slot_index, delta_sp) )
          endIf
          return cmd
        else
          # Regular object property
          cmd.context.dispatch( this )
          opcode = Op.resolve_read_property_index_n

          write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.property.index) )

          # Extra arg space for object property that is a compound
          if (property_type.is_compound) write_code( cmd.t, Op.halt )
        endIf

      else
        # Read 'this' property.
        if (context_type.is_compound)
          which (property_type.classification)
            case Type.reference_type: opcode = Op.read_this_compound_object_offset_n
            case Type.real_type:      opcode = Op.read_this_compound_real_offset_n
            case Type.integer_type:   opcode = Op.read_this_compound_integer_offset_n
            case Type.character_type: opcode = Op.read_this_compound_integer_offset_n
            case Type.byte_type:      opcode = Op.read_this_compound_integer_offset_n
            case Type.logical_type:   opcode = Op.read_this_compound_integer_offset_n
            case Type.compound_type
              # Replace a compound on the stack with its subset
              write_code( cmd.t, opcode_with_embedded_a_b(Op.read_this_compound_subset_offset_a_slot_count_b, ...
                  cmd.property.slot_index, property_type.slot_count) )
              return cmd
          endWhich
          write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.property.slot_index) )
        else
          opcode = Op.resolve_read_this_property_index_n
          write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.property.index) )

          if (property_type.is_compound) write_code( cmd.t, cmd.property.type.slot_count )
        endIf
      endIf

      return cmd

    method visit( CmdWriteSetting cmd ).Cmd
      local var is_compound = cmd.setting.type.is_compound
      local var opcode = 0

      local Type context_type
      if (cmd.context?) context_type = cmd.context.type
      else              context_type = this_type

      if (context_type.is_compound)
        throw cmd.t.error( "Compound properties cannot be individually reassigned.  A new compound must be created using the new properties." )
      endIf

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        if (cmd.context notInstanceOf CmdReadSingleton)
          cmd.context.dispatch( this )
          if (cmd.context.type.is_compound)
            write_code( cmd.t, opcode_with_embedded_n( Op.resolve_pop_discard_compound_type_n, cmd.context.type.index) )
          else
            write_code( cmd.t, Op.pop_discard )
          endIf
        endIf
      endIf

      if (is_compound) opcode = Op.resolve_write_setting_compound_index_n
      else             opcode = Op.resolve_write_setting_index_n

      cmd.new_value.dispatch( this )

      write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.setting.index) )
      write_code( cmd.t, cmd.setting.type_context.index )
      if (is_compound) write_code( cmd.t, cmd.setting.type.slot_count )

      return cmd

    method visit( CmdWriteProperty cmd ).Cmd
      local var is_compound = cmd.property.type.is_compound
      local var opcode = 0

      local Type context_type
      if (cmd.context?) context_type = cmd.context.type
      else              context_type = this_type

      if (context_type.is_compound)
        throw cmd.t.error( "Compound properties cannot be individually reassigned.  A new compound must be created using the new properties." )
      endIf

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        cmd.context.dispatch( this )

        if (is_compound) opcode = Op.resolve_write_property_compound_index_n
        else             opcode = Op.resolve_write_property_index_n

      else
        opcode = Op.resolve_write_this_property_index_n
      endIf

      cmd.new_value.dispatch( this )

      write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.property.index) )

      if (is_compound) write_code( cmd.t, cmd.property.type.slot_count )

      return cmd

    method visit( CmdStaticCall cmd ).Cmd
      if (cmd.context?)
        local var context_type = cmd.context.type
        context_type.resolve( cmd.t )
        if (context_type.is_compound)
          if (cmd.method_info.name == "create")
            if (cmd.method_info.attributes.is_automatic)
              # The automatic create() method is the one that mirrors/defines the
              # composition of the compound.  Pushing its args on the stack in
              # reverse order to create the compound.
              forEach (arg in cmd.args.reverse_order)
                #println( "Arg $ has slot_index $" (arg.type.name,arg.type.slot_index))
                arg.dispatch( this )
              endForEach
              return cmd
              #else
              #throw cmd.t.error( "TODO: write developer-defined compound create() call" )
            endIf
          endIf
        endIf

        cmd.context.dispatch( this )
      else
        if (this_type.is_compound)
          write_code( cmd.t, opcode_with_embedded_n(Op.push_this_compound_n_slots,this_type.slot_count) )
        elseIf (this_type.is_primitive)
          if (this_type.is_Real) write_code( cmd.t, Op.push_this_real )
          else                   write_code( cmd.t, Op.push_this_integer )
        else
          write_code( cmd.t, Op.push_this )
        endIf
      endIf

      forEach (arg in cmd.args)
        arg.dispatch( this )
      endForEach

      local var m_index = cmd.method_info.global_index

      write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,m_index) )

      return cmd

    method visit( CmdDynamicCall cmd ).Cmd
      if (cmd.context?)
        cmd.context.dispatch( this )
      else
        if (this_type.is_compound)
          write_code( cmd.t, opcode_with_embedded_n(Op.push_this_compound_n_slots,this_type.slot_count) )
        elseIf (this_type.is_primitive)
          if (this_type.is_Real) write_code( cmd.t, Op.push_this_real )
          else                   write_code( cmd.t, Op.push_this_integer )
        else
          write_code( cmd.t, Op.push_this )
        endIf
      endIf

      forEach (arg in cmd.args)
        arg.dispatch( this )
      endForEach

      local Type context_type
      contingent
        necessary (cmd.context?)
        context_type = cmd.context.type
        necessary (context_type.is_aspect)
      satisfied
        write_code( cmd.t, opcode_with_embedded_n(Op.aspect_call_with_n_parameters,cmd.method_info.parameters.count) )
        write_code( cmd.t, context_type.index )
      unsatisfied
        write_code( cmd.t, opcode_with_embedded_n(Op.dynamic_call_with_n_parameters,cmd.method_info.parameters.count) )
      endContingent
      #if (cmd.method_info.call_signature == "resolve()" or cmd.method_info.call_signature=="instance_of(Type)")
      #println( "cmd.method_info? " + cmd.method_info? )
      #println( "cmd.method_info.signature? " + cmd.method_info.signature? )
      #println( "@$ Calling $::$ with method index $" (code.count,cmd.method_info.type_context.name,cmd.method_info.signature,cmd.method_info.local_index))
      #endIf
      write_code( cmd.t, cmd.method_info.local_index )

      return cmd

    method visit( CmdAdd cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.add_real
      elseIf (type.is_Integer) opcode = Op.add_integer
      else throw cmd.error( "TODO: CmdAdd for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdSubtract cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.subtract_real
      elseIf (type.is_Integer) opcode = Op.subtract_integer
      else throw cmd.error( "TODO: CmdAdd for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdMultiply cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.multiply_real
      elseIf (type.is_Integer) opcode = Op.multiply_integer
      else throw cmd.error( "TODO: CmdMultiply for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdDivide cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.divide_real
      elseIf (type.is_Integer) opcode = Op.divide_real
      else throw cmd.error( "TODO: CmdDivide for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdMod cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.mod_real
      elseIf (type.is_Integer) opcode = Op.mod_integer
      else throw cmd.error( "TODO: CmdMod for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdPower cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.power_real
      elseIf (type.is_Integer) opcode = Op.power_integer
      else throw cmd.error( "TODO: CmdPower for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdBitwiseAnd cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.bitwise_and_integer
      else throw cmd.error( "Unhandled type $ in CmdBitwiseAnd " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdBitwiseOr cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.bitwise_or_integer
      else throw cmd.error( "Unhandled type $ in CmdBitwiseOr " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdBitwiseXor cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.bitwise_xor_integer
      else throw cmd.error( "Unhandled type $ in CmdBitwiseXor " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdNegate cmd ).Cmd
      local var opcode = 0
      local var type = cmd.operand.type
      if (type.is_Real)        opcode = Op.negate_real
      elseIf (type.is_Integer) opcode = Op.negate_integer
      elseIf (type.is_Logical) opcode = Op.negate_logical
      else throw cmd.error( "Unhandled type $ in CmdNegate " (type) )

      cmd.operand.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdLogicalize cmd ).Cmd
      cmd.operand.dispatch( this )

      local var opcode = 0
      local var type = cmd.operand.type
      which (type.classification)
        case Type.reference_type: opcode = Op.logicalize_object
        case Type.real_type:      opcode = Op.logicalize_real
        case Type.integer_type:   opcode = Op.logicalize_integer
        case Type.character_type: opcode = Op.logicalize_integer
        case Type.byte_type:      opcode = Op.logicalize_integer
        case Type.logical_type:   return cmd
        case Type.compound_type
          throw Error("TODO: logicalize compound")
      endWhich

      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdBitwiseNot cmd ).Cmd
      local var opcode = 0
      local var type = cmd.operand.type
      if (type.is_Integer) opcode = Op.bitwise_not_integer
      else throw cmd.error( "Unhandled type $ in CmdBitwiseNot " (type) )

      cmd.operand.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdBitwiseSHL cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.shl_integer
      else throw cmd.error( "Unhandled type $ in CmdBitwiseSHL " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdBitwiseSHR cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.shr_integer
      else throw cmd.error( "Unhandled type $ in CmdBitwiseSHR " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdBitwiseSHRX cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.shrx_integer
      else throw cmd.error( "Unhandled type $ in CmdBitwiseSHRX " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdLogicalAnd cmd ).Cmd
      cmd.lhs.dispatch( this )

      local var control_id = next_control_id
      write_jump( cmd.t, Op.if_false_push_false_and_jump_to_offset_n, "end_and_" + control_id )

      cmd.rhs.dispatch( this )
      define_label( "end_and_" + control_id )

      return cmd

    method visit( CmdLogicalOr cmd ).Cmd
      cmd.lhs.dispatch( this )

      local var control_id = next_control_id
      write_jump( cmd.t, Op.if_true_push_true_and_jump_to_offset_n, "end_or_" + control_id )

      cmd.rhs.dispatch( this )
      define_label( "end_or_" + control_id )

      return cmd

    method visit( CmdLogicalNot cmd ).Cmd
      local var opcode = 0
      cmd.operand.dispatch( this )

      which (cmd.operand.type.classification)
        case Type.logical_type: opcode = Op.logical_not
        others:                 throw cmd.error( "Unhandled type $ in CmdLogicalNot" (cmd.operand.type) )
      endWhich

      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdLogicalXor cmd ).Cmd
      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, Op.logical_xor )
      return cmd

    method visit( CmdCompareEQ cmd ).Cmd
      local var opcode = 0
      which (cmd.lhs.type.classification)
        case Type.real_type:      opcode = Op.eq_real
        case Type.integer_type:   opcode = Op.eq_integer
        case Type.character_type: opcode = Op.eq_integer
        case Type.byte_type:      opcode = Op.eq_integer
        case Type.logical_type:   opcode = Op.eq_integer
        others:                   throw cmd.error( "Unhandled type $ in CmdCompareEQ" (cmd.lhs.type) )
      endWhich

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdCompareIs cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if (type.is_reference) opcode = Op.is_object
      else throw cmd.error( "Unhandled type $ in CmdCompareIs" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdCompareNE cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if     (type.is_Real)      opcode = Op.ne_real
      elseIf (type.is_Integer)   opcode = Op.ne_integer
      elseIf (type.is_Character) opcode = Op.ne_integer
      elseIf (type.is_Logical)   opcode = Op.ne_integer
      else throw cmd.error( "Unhandled type $ in CmdCompareNE" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdCompareIsNot cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if (type.is_reference) opcode = Op.is_not_object
      else throw cmd.error( "Unhandled type $ in CmdCompareIsNot" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdCompareLT cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if     (type.is_Real)      opcode = Op.lt_real
      elseIf (type.is_Integer)   opcode = Op.lt_integer
      elseIf (type.is_Character) opcode = Op.lt_integer
      else throw cmd.error( "Unhandled type $ in CmdCompareLT" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdCompareLE cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if     (type.is_Real)      opcode = Op.le_real
      elseIf (type.is_Integer)   opcode = Op.le_integer
      elseIf (type.is_Character) opcode = Op.le_integer
      else throw cmd.error( "Unhandled type $ in CmdCompareLE" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdCompareGT cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if     (type.is_Real)      opcode = Op.gt_real
      elseIf (type.is_Integer)   opcode = Op.gt_integer
      elseIf (type.is_Character) opcode = Op.gt_integer
      else throw cmd.error( "Unhandled type $ in CmdCompareGT" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( CmdCompareGE cmd ).Cmd
      local var opcode = 0
      local var type = cmd.lhs.type
      if     (type.is_Real)      opcode = Op.ge_real
      elseIf (type.is_Integer)   opcode = Op.ge_integer
      elseIf (type.is_Character) opcode = Op.ge_integer
      else throw cmd.error( "Unhandled type $ in CmdCompareGE" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method write_op_assign_property( CmdOpAssignProperty cmd, Integer read_op, Integer math_op, Integer write_op ).Cmd
      local var t = cmd.t
      local var property_index = cmd.property.index

      cmd.context.dispatch( this )
      write_code( t, Op.duplicate_object )

      write_code_with_arg_n( t, read_op, property_index )
      cmd.new_value.dispatch( this )
      write_code( t, math_op )
      write_code_with_arg_n( t, write_op, property_index )

      return cmd

    method write_op_assign_this_property( CmdOpAssignProperty cmd, Integer read_op, Integer math_op, Integer write_op ).Cmd
      local var t = cmd.t
      local var property_index = cmd.property.index

      write_code_with_arg_n( t, read_op, property_index )
      cmd.new_value.dispatch( this )
      write_code( t, math_op )
      write_code_with_arg_n( t, write_op, property_index )

      return cmd

    method visit( CmdAddAssignProperty cmd ).Cmd
      local var t = cmd.t
      local var property_index = cmd.property.index

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        which (cmd.property.type.classification)
          case Type.real_type
            cmd.context.dispatch( this )
            cmd.new_value.dispatch( this )
            write_code_with_arg_n( t, Op.resolve_add_assign_property_real_index_n, property_index )

          case Type.integer_type
            cmd.context.dispatch( this )
            cmd.new_value.dispatch( this )
            write_code_with_arg_n( t, Op.resolve_add_assign_property_integer_index_n, property_index )

          case Type.character_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.add_integer, Op.resolve_write_property_index_n )

          case Type.byte_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.add_integer, Op.resolve_write_property_index_n )

          case Type.logical_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_or_integer, Op.resolve_write_property_index_n )

          others
            throw Error("TODO: type $ ($)" (cmd.property.type,cmd.property.type.classification))

        endWhich

      else
        which (cmd.property.type.classification)
          case Type.real_type
            cmd.new_value.dispatch( this )
            write_code_with_arg_n( t, Op.resolve_add_assign_this_property_real_index_n, property_index )

          case Type.integer_type
            cmd.new_value.dispatch( this )
            write_code_with_arg_n( t, Op.resolve_add_assign_this_property_integer_index_n, property_index )

          case Type.character_type
            return write_op_assign_property( cmd, Op.resolve_read_this_property_index_n, Op.add_integer, Op.resolve_write_this_property_index_n )

          case Type.byte_type
            return write_op_assign_property( cmd, Op.resolve_read_this_property_index_n, Op.add_integer, Op.resolve_write_this_property_index_n )

          case Type.logical_type
            return write_op_assign_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_or_integer, Op.resolve_write_this_property_index_n )

          others
          throw Error("TODO: type " + cmd.property.type)

        endWhich
      endIf
      return cmd

    method visit( CmdSubtractAssignProperty cmd ).Cmd
      local var t = cmd.t
      local var property_index = cmd.property.index

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        which (cmd.property.type.classification)
          case Type.real_type
            cmd.context.dispatch( this )
            cmd.new_value.dispatch( this )
            write_code_with_arg_n( t, Op.resolve_subtract_assign_property_real_index_n, property_index )

          case Type.integer_type
            cmd.context.dispatch( this )
            cmd.new_value.dispatch( this )
            write_code_with_arg_n( t, Op.resolve_subtract_assign_property_integer_index_n, property_index )

          case Type.character_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.subtract_integer, Op.resolve_write_property_index_n )

          case Type.byte_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.subtract_integer, Op.resolve_write_property_index_n )

          others
            throw Error("TODO")

        endWhich

      else
        which (cmd.property.type.classification)
          case Type.real_type
            cmd.new_value.dispatch( this )
            write_code_with_arg_n( t, Op.resolve_subtract_assign_this_property_real_index_n, property_index )

          case Type.integer_type
            cmd.new_value.dispatch( this )
            write_code_with_arg_n( t, Op.resolve_subtract_assign_this_property_integer_index_n, property_index )

          case Type.character_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.subtract_integer, 
              Op.resolve_write_this_property_index_n )

          case Type.byte_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.subtract_integer, 
              Op.resolve_write_this_property_index_n )

          case Type.logical_type
            throw cmd.t.error( "Type Logical is not supported for this operation." )

          others
            throw Error("TODO")

        endWhich
      endIf
      return cmd

    method visit( CmdMultiplyAssignProperty cmd ).Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)

        which (cmd.property.type.classification)
          case Type.real_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.multiply_real, Op.resolve_write_property_index_n )

          case Type.integer_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.multiply_integer, Op.resolve_write_property_index_n )

          case Type.character_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.multiply_integer, Op.resolve_write_property_index_n )

          case Type.byte_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.multiply_integer, Op.resolve_write_property_index_n )

          case Type.logical_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.multiply_integer, Op.resolve_write_property_index_n )

          others
            throw Error("TODO")

        endWhich

      else
        which (cmd.property.type.classification)
          case Type.real_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.multiply_real, 
                Op.resolve_write_this_property_index_n )

          case Type.integer_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.multiply_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.character_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.multiply_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.byte_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.multiply_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.logical_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_and_integer, 
                Op.resolve_write_this_property_index_n )

          others
            throw Error("TODO")

        endWhich
      endIf
      return cmd

    method visit( CmdDivideAssignProperty cmd ).Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)

        which (cmd.property.type.classification)
          case Type.real_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.divide_real, Op.resolve_write_property_index_n )

          case Type.integer_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.divide_integer, Op.resolve_write_property_index_n )

          case Type.character_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.divide_integer, Op.resolve_write_property_index_n )

          case Type.byte_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.divide_integer, Op.resolve_write_property_index_n )

          case Type.logical_type
            throw cmd.t.error( "Type Logical is not supported for this operation." )

          others
            throw Error("TODO")

        endWhich

      else
        which (cmd.property.type.classification)
          case Type.real_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.divide_real, 
                Op.resolve_write_this_property_index_n )

          case Type.integer_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.divide_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.character_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.divide_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.byte_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.divide_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.logical_type
            throw cmd.t.error( "Type Logical is not supported for this operation." )

          others
            throw Error("TODO")

        endWhich
      endIf
      return cmd

    method visit( CmdModAssignProperty cmd ).Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)

        which (cmd.property.type.classification)
          case Type.real_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.mod_real, Op.resolve_write_property_index_n )

          case Type.integer_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.mod_integer, Op.resolve_write_property_index_n )

          case Type.character_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.mod_integer, Op.resolve_write_property_index_n )

          case Type.byte_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.mod_integer, Op.resolve_write_property_index_n )

          case Type.logical_type
            throw cmd.t.error( "Type Logical is not supported for this operation." )

          others
            throw Error("TODO")

        endWhich

      else
        which (cmd.property.type.classification)
          case Type.real_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.mod_real, 
                Op.resolve_write_this_property_index_n )

          case Type.integer_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.mod_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.character_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.mod_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.byte_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.mod_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.logical_type
            throw cmd.t.error( "Type Logical is not supported for this operation." )

          others
            throw Error("TODO")

        endWhich
      endIf
      return cmd


    method visit( CmdPowerAssignProperty cmd ).Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)

        which (cmd.property.type.classification)
          case Type.real_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.power_real, Op.resolve_write_property_index_n )

          case Type.integer_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.power_integer, Op.resolve_write_property_index_n )

          case Type.character_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.power_integer, Op.resolve_write_property_index_n )

          case Type.byte_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.power_integer, Op.resolve_write_property_index_n )

          case Type.logical_type
            throw cmd.t.error( "Type Logical is not supported for this operation." )

          others
            throw Error("TODO")

        endWhich

      else
        which (cmd.property.type.classification)
          case Type.real_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.power_real, 
                Op.resolve_write_this_property_index_n )

          case Type.integer_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.power_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.character_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.power_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.byte_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.power_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.logical_type
            throw cmd.t.error( "Type Logical is not supported for this operation." )

          others
            throw Error("TODO")

        endWhich
      endIf
      return cmd


    method visit( CmdBitwiseAndAssignProperty cmd ).Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)

        which (cmd.property.type.classification)
          case Type.real_type
            throw cmd.t.error( "Type Real is not supported for this operation." )

          case Type.integer_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_and_integer, Op.resolve_write_property_index_n )

          case Type.character_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_and_integer, Op.resolve_write_property_index_n )

          case Type.byte_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_and_integer, Op.resolve_write_property_index_n )

          case Type.logical_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_and_integer, Op.resolve_write_property_index_n )

          others
            throw Error("TODO")

        endWhich

      else
        which (cmd.property.type.classification)
          case Type.real_type
            throw cmd.t.error( "Type Real is not supported for this operation." )

          case Type.integer_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_and_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.character_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_and_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.byte_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_and_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.logical_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_and_integer, 
                Op.resolve_write_this_property_index_n )

          others
            throw Error("TODO")

        endWhich
      endIf
      return cmd

    method visit( CmdBitwiseOrAssignProperty cmd ).Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)

        which (cmd.property.type.classification)
          case Type.real_type
            throw cmd.t.error( "Type Real is not supported for this operation." )

          case Type.integer_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_or_integer, Op.resolve_write_property_index_n )

          case Type.character_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_or_integer, Op.resolve_write_property_index_n )

          case Type.byte_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_or_integer, Op.resolve_write_property_index_n )

          case Type.logical_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_or_integer, Op.resolve_write_property_index_n )

          others
            throw Error("TODO")

        endWhich

      else
        which (cmd.property.type.classification)
          case Type.real_type
            throw cmd.t.error( "Type Real is not supported for this operation." )

          case Type.integer_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_or_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.character_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_or_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.byte_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_or_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.logical_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_or_integer, 
                Op.resolve_write_this_property_index_n )

          others
            throw Error("TODO")

        endWhich
      endIf
      return cmd

    method visit( CmdBitwiseXorAssignProperty cmd ).Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)

        which (cmd.property.type.classification)
          case Type.real_type
            throw cmd.t.error( "Type Real is not supported for this operation." )

          case Type.integer_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_xor_integer, Op.resolve_write_property_index_n )

          case Type.character_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_xor_integer, Op.resolve_write_property_index_n )

          case Type.byte_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.bitwise_xor_integer, Op.resolve_write_property_index_n )

          case Type.logical_type
            return write_op_assign_property( cmd, Op.resolve_read_property_index_n, Op.logical_xor, Op.resolve_write_property_index_n )

          others
            throw Error("TODO")

        endWhich

      else
        which (cmd.property.type.classification)
          case Type.real_type
            throw cmd.t.error( "Type Real is not supported for this operation." )

          case Type.integer_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_xor_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.character_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_xor_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.byte_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.bitwise_xor_integer, 
                Op.resolve_write_this_property_index_n )

          case Type.logical_type
            return write_op_assign_this_property( cmd, Op.resolve_read_this_property_index_n, Op.logical_xor, 
                Op.resolve_write_this_property_index_n )

          others
            throw Error("TODO")

        endWhich
      endIf
      return cmd

    method write_op_assign_setting( CmdOpAssignSetting cmd, Integer read_op, Integer math_op, Integer write_op ).Cmd
      local var t = cmd.t
      local var setting_index = cmd.setting.index
      local var setting_type_index = cmd.setting.type_context.index

      if (cmd.context?)
        cmd.context.dispatch( this )
        local var context_type = cmd.context.type
        if (context_type.is_primitive or context_type.is_reference)
          write_code( t, Op.pop_discard )
        else
          write_code_with_arg_n( t, Op.resolve_pop_discard_compound_type_n, context_type.index )
        endIf
      endIf

      write_code_with_arg_n( t, read_op, setting_index )
      write_code( t, setting_type_index )
      cmd.new_value.dispatch( this )
      write_code( t, math_op )
      write_code_with_arg_n( t, write_op, setting_index )
      write_code( t, setting_type_index )

      return cmd

    method visit( CmdAddAssignSetting cmd ).Cmd
      which (cmd.setting.type.classification)
        case Type.real_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.add_real, Op.resolve_write_setting_index_n )

        case Type.integer_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.add_integer, Op.resolve_write_setting_index_n )

        case Type.character_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.add_integer, Op.resolve_write_setting_index_n )

        case Type.byte_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.add_integer, Op.resolve_write_setting_index_n )

        case Type.logical_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.add_integer, Op.resolve_write_setting_index_n )

        others
          throw Error("TODO")

      endWhich

    method visit( CmdSubtractAssignSetting cmd ).Cmd
      which (cmd.setting.type.classification)
        case Type.real_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.subtract_real, Op.resolve_write_setting_index_n )

        case Type.integer_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.subtract_integer, Op.resolve_write_setting_index_n )

        case Type.character_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.subtract_integer, Op.resolve_write_setting_index_n )

        case Type.byte_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.subtract_integer, Op.resolve_write_setting_index_n )

        case Type.logical_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.subtract_integer, Op.resolve_write_setting_index_n )

        others
          throw Error("TODO")

      endWhich

    method visit( CmdMultiplyAssignSetting cmd ).Cmd
      which (cmd.setting.type.classification)
        case Type.real_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.multiply_real, Op.resolve_write_setting_index_n )

        case Type.integer_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.multiply_integer, Op.resolve_write_setting_index_n )

        case Type.character_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.multiply_integer, Op.resolve_write_setting_index_n )

        case Type.byte_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.multiply_integer, Op.resolve_write_setting_index_n )

        case Type.logical_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.multiply_integer, Op.resolve_write_setting_index_n )

        others
          throw Error("TODO")

      endWhich

    method visit( CmdDivideAssignSetting cmd ).Cmd
      which (cmd.setting.type.classification)
        case Type.real_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.divide_real, Op.resolve_write_setting_index_n )

        case Type.integer_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.divide_integer, Op.resolve_write_setting_index_n )

        case Type.character_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.divide_integer, Op.resolve_write_setting_index_n )

        case Type.byte_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.divide_integer, Op.resolve_write_setting_index_n )

        case Type.logical_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.divide_integer, Op.resolve_write_setting_index_n )

        others
          throw Error("TODO")

      endWhich

    method visit( CmdModAssignSetting cmd ).Cmd
      which (cmd.setting.type.classification)
        case Type.real_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.mod_real, Op.resolve_write_setting_index_n )

        case Type.integer_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.mod_integer, Op.resolve_write_setting_index_n )

        case Type.character_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.mod_integer, Op.resolve_write_setting_index_n )

        case Type.byte_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.mod_integer, Op.resolve_write_setting_index_n )

        case Type.logical_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.mod_integer, Op.resolve_write_setting_index_n )

        others
          throw Error("TODO")

      endWhich

    method visit( CmdPowerAssignSetting cmd ).Cmd
      which (cmd.setting.type.classification)
        case Type.real_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.power_real, Op.resolve_write_setting_index_n )

        case Type.integer_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.power_integer, Op.resolve_write_setting_index_n )

        case Type.character_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.power_integer, Op.resolve_write_setting_index_n )

        case Type.byte_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.power_integer, Op.resolve_write_setting_index_n )

        case Type.logical_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.power_integer, Op.resolve_write_setting_index_n )

        others
          throw Error("TODO")

      endWhich

    method visit( CmdBitwiseAndAssignSetting cmd ).Cmd
      which (cmd.setting.type.classification)
        case Type.real_type
          throw cmd.t.error( "Type Real is not supported for this operation." )

        case Type.integer_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.bitwise_and_integer, Op.resolve_write_setting_index_n )

        case Type.character_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.bitwise_and_integer, Op.resolve_write_setting_index_n )

        case Type.byte_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.bitwise_and_integer, Op.resolve_write_setting_index_n )

        case Type.logical_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.bitwise_and_integer, Op.resolve_write_setting_index_n )

        others
          throw Error("TODO")

      endWhich

    method visit( CmdBitwiseOrAssignSetting cmd ).Cmd
      which (cmd.setting.type.classification)
        case Type.real_type
          throw cmd.t.error( "Type Real is not supported for this operation." )

        case Type.integer_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.bitwise_or_integer, Op.resolve_write_setting_index_n )

        case Type.character_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.bitwise_or_integer, Op.resolve_write_setting_index_n )

        case Type.byte_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.bitwise_or_integer, Op.resolve_write_setting_index_n )

        case Type.logical_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.bitwise_or_integer, Op.resolve_write_setting_index_n )

        others
          throw Error("TODO")

      endWhich

    method visit( CmdBitwiseXorAssignSetting cmd ).Cmd
      which (cmd.setting.type.classification)
        case Type.real_type
          throw cmd.t.error( "Type Real is not supported for this operation." )

        case Type.integer_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.bitwise_xor_integer, Op.resolve_write_setting_index_n )

        case Type.character_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.bitwise_xor_integer, Op.resolve_write_setting_index_n )

        case Type.byte_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.bitwise_xor_integer, Op.resolve_write_setting_index_n )

        case Type.logical_type
          return write_op_assign_setting( cmd, Op.resolve_read_setting_index_n, Op.logical_xor, Op.resolve_write_setting_index_n )

        others
          throw Error("TODO")

      endWhich

    method visit( CmdCreateArray cmd ).Cmd
      cmd.size_expression.dispatch( this )
      write_code_with_arg_n( cmd.t, Op.create_array_type_n, cmd.array_type.index )
      write_code( cmd.t, cmd.element_type.index )
      return cmd

    method visit( CmdArrayCount cmd ).Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.array_count )
      return cmd

    method visit( CmdReadArrayElement cmd ).Cmd
      cmd.operand.dispatch( this )
      cmd.index_expression.dispatch( this )

      local var opcode = -1
      which (cmd.element_type.classification)
        case Type.reference_type: opcode = Op.read_array_element_object
        case Type.real_type:      opcode = Op.read_array_element_real
        case Type.integer_type:   opcode = Op.read_array_element_integer
        case Type.character_type: opcode = Op.read_array_element_character
        case Type.byte_type:      opcode = Op.read_array_element_byte
        case Type.logical_type:   opcode = Op.read_array_element_byte
        case Type.compound_type
          write_code_with_arg_n( cmd.t, Op.read_array_element_compound_n_slots, cmd.element_type.slot_count )
          return cmd
        others: throw Error()
      endWhich

      write_code( cmd.t, opcode )
      return cmd

    method visit( CmdWriteArrayElement cmd ).Cmd
      cmd.operand.dispatch( this )
      cmd.index_expression.dispatch( this )
      cmd.new_value.dispatch( this )

      local var opcode = -1
      which (cmd.element_type.classification)
        case Type.reference_type: opcode = Op.write_array_element_object
        case Type.real_type:      opcode = Op.write_array_element_real
        case Type.integer_type:   opcode = Op.write_array_element_integer
        case Type.character_type: opcode = Op.write_array_element_character
        case Type.byte_type:      opcode = Op.write_array_element_byte
        case Type.logical_type:   opcode = Op.write_array_element_byte
        case Type.compound_type
          write_code_with_arg_n( cmd.t, Op.write_array_element_compound_n_slots, cmd.element_type.slot_count )
          return cmd
        others: throw Error()
      endWhich

      write_code( cmd.t, opcode )

      return cmd
endClass

