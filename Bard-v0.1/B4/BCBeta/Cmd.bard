<<include "Op.bard">>

class Cmd
  PROPERTIES
    t : Token

  METHODS
    method init( t )

    method clone->Cmd
      # FIXME throw t.error( "clone() not defined for " + type_name + "." )
      throw t.error( "clone() not defined for <type_name>." )

    method clone( cmd:Cmd )->Cmd
      if (cmd is null) return null
      return cmd.clone

    method clone( args:CmdArgs )->CmdArgs
      if (args is null) return null
      return args.clone

    method clone( statements:CmdStatementList )->CmdStatementList
      if (statements is null) return null
      return statements.clone

    method error( message:String )->BardError
      return t.error( message )

    method implicit_type->Type
      return null

    method dispatch( v:Visitor )->Cmd [propagated]
      return v.visit( this )

    method is_complex_reference->Logical
      # Used to determine whether or not the context of a property op+assign should
      # be first stored into a separate localiable.
      return false

    method type->Type
      return null

    method instance_of( ancestor:Type)->Logical
      return type.instance_of( ancestor )

    method variable_name->String
      return null

    method print( buffer:StringBuilder )
      #throw t.error( "print(StringBuilder) not defined for " + type_name + "." )
      throw t.error( "print(StringBuilder) not defined for <type_name>." )

    method resolve->Cmd
      #throw t.error( "resolve() not defined for " + type_name + "." )
      throw t.error( "resolve() not defined for <type_name>." )

    method resolve_with_type_hint( as_type:Type)->Cmd
      return resolve  # ignore the type hint by default

    method resolve_increment->Cmd
      throw error( "Cannot increment given value.  Target must be a localiable or a property." )

    method resolve_decrement->Cmd
      throw error( "Cannot decrement given value.  Target must be a localiable or a property." )

    method resolve_assignment( new_value:Cmd, operation:Integer)->Cmd
      throw t.error( "Invalid target for assignment." )

    method to->String
      local buffer = StringBuilder()
      print( buffer )
      return buffer->String

    method require_logical->Cmd
      if (type? and type.is_Logical) return this
      throw t.error( "true:Logical or false value expected." )

    method require_value->Cmd
      if (type is null)
        throw t.error( "Value expected." )
      endIf
      return this

    method require_integer->Cmd
      if (type is null or type isNot Types.type_Integer)
        throw t.error( "value:expected:Integer." )
      endIf
      return this

      #{
    method require_value( allow_unchecked:Logical )->Cmd
      local _type = type
      if (type is null) throw t.error( "Value expected." )
      #if (type.possibly_null and not allow_unchecked)
      #throw t.error( "Null-checked value required." )
      #endIf
      return this
      }#

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (type is to_type) return this
      local result = CmdImplicitCastToType( cast_t, this, to_type )
      return result

    method common_type( lhs:Cmd, rhs:Cmd )->Type
      local lhs_type = lhs.type
      local rhs_type = rhs.type

      if (lhs_type is rhs_type and not lhs_type.is_Character)
        #if (lhs_type is rhs_type)
        return lhs_type
      endIf

      if (lhs_type.is_primitive and rhs_type.is_primitive)
        if (lhs_type.is_Logical or rhs_type.is_Logical)
          throw t.error( "Invalid mix of and:Logical non-types:Logical." )
        endIf
        if (lhs_type.is_Real or rhs_type.is_Real) return Types.type_Real

        return Types.type_Integer
      else
        #{
        if (lhs_type is rhs_type def)
          # Mix of checked and unchecked values
          return lhs_type.unchecked_type
        endIf
        }#
        if (lhs_type.instance_of(rhs_type)) return rhs_type
        if (rhs_type.instance_of(lhs_type)) return lhs_type
        return Types.type_Object
      endIf
endClass

class CmdStatementList : Cmd[]
  METHODS
    method init
      prior.init

    method init( initial_capacity:Integer)
      prior.init( initial_capacity )

    method init( statement:Cmd )
      init
      add( statement )

    method init( statement1:Cmd, statement2:Cmd )
      init
      add( statement1 ).add( statement2 )

    method clone->CmdStatementList
      local result = CmdStatementList( count )
      forEach (cmd in this) result.add( cmd.clone )
      return result

    method dispatch( v:Visitor ) [propagated]
      v.visit( this )

    method print( buffer:StringBuilder )
      Analyzer.context.push_local_scope
      forEach (statement in this)
        buffer.print( "      " )
        statement.print( buffer )
        buffer.println
      endForEach
      Analyzer.context.pop_local_scope

    method resolve
      Analyzer.context.push_local_scope
      forEach (i in this.indices)
        this[i] = this[i].resolve
      endForEach
      Analyzer.context.pop_local_scope

endClass

class CmdArgs : CmdStatementList
  METHODS
    method clone->CmdArgs
      local result = CmdArgs( count )
      forEach (cmd in this) result.add( cmd.clone )
      return result

    method resolve
      forEach (i in this.indices)
        this[i] = this[i].resolve.require_value
      endForEach

    method print( buffer:StringBuilder )
      local first = true
      forEach (arg in this)
        if (first) first = false
        else       buffer.print(',')
        arg.print( buffer )
      endForEach

    # TODO:
    method cast_to( m:Method )->CmdArgs
      #{
      if (m.parameters.count == 1 and m.parameters.first.type == Types.type_DataStack)
        local CmdArgs result()
        local cmd = CmdAccess( m.t, "DataStack" )
        cmd = CmdAccess( m.t, cmd, "push_frame", null )
        forEach(arg in this)
          cmd = CmdAccess( m.t, cmd, "push", CmdArgs( arg.resolve ) )
        endForEach
        result.add(cmd)
        return result
      else
        }#
        local i = 0
        forEach (arg in this)
          # println (arg)
          # println(parameters[i])
          data[i] = arg.cast_to( arg.t, m.parameters[i].type )
          ++i
        endForEach
        #endIf

      return this

    method cast_to( parameters:Local[] )
      # Cast each argument its corresponding method parameter type
      # println(this)
      local i = 0
      forEach (arg in this)
        # println (arg)
        # println(parameters[i])
        data[i] = arg.cast_to( arg.t, parameters[i].type )
        ++i
      endForEach

endClass

class CmdLiteral : Cmd
  METHODS
    method implicit_type->Type
      return type

    method resolve->Cmd
      return this

endClass

class CmdLiteralReal : CmdLiteral
  PROPERTIES
    value : Real

  METHODS
    method init( t, value )

    method clone->CmdLiteralReal
      return CmdLiteralReal( t, value )

    method type->Type
      return Types.type_Real

    method to->String
      return ""+value

    method print( buffer:StringBuilder )
      buffer.print( value )

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (to_type.is_Real) return this

      if (to_type.is_Integer)
        return CmdLiteralInteger( t, value->Real )

      elseIf (to_type.is_Character)
        throw t.error( //Invalid conversion from to:Real Character.// )

      elseIf (to_type.is_Logical)
        throw t.error( //Invalid conversion from to:Real Logical.  Use "value?" instead.// )

      elseIf (to_type.is_String)
        return CmdLiteralString( t, ""+value )

        #{
      elseIf (to_type is Types.type_Object)
        return CmdBoxReal( t, value )
        }#

      else
        throw t.error( "TODO: CmdLiteralReal::cast_to()." )
      endIf

endClass

class CmdLiteralInteger : CmdLiteral
  PROPERTIES
    value : Integer

  METHODS
    method init( t, value )

    method clone->CmdLiteralInteger
      return CmdLiteralInteger( t, value )

    method type->Type
      return Types.type_Integer

    method to->String
      return "" + value

    method print( buffer:StringBuilder )
      buffer.print( value )

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (to_type.is_Integer) return this

      if (to_type.is_Real)
        return CmdLiteralReal( t, value )

      elseIf (to_type.is_Character)
        return CmdLiteralCharacter( t, value->Character )

      elseIf (to_type.is_Byte)
        return CmdLiteralByte( t, (value&255)->Byte )

      elseIf (to_type.is_Logical)
        throw t.error( //Invalid conversion from to:Logical:Integer.  Use "value?" instead.// )

      elseIf (to_type.is_String)
        return CmdLiteralString( t, ""+value )

      #elseIf (to_type.def is TypeDefs.type_IntegerObject or to_type.is_Object)
        #return CmdAccess( t, "IntegerObject", CmdArgs(this) ).resolve

      else
        throw t.error( "Invalid cast from to::Integer" + to_type.name + "." )
      endIf

endClass

class CmdLiteralCharacter : CmdLiteral
  PROPERTIES
    value : Character

  METHODS
    method init( t, value )

    method clone->CmdLiteralCharacter
      return CmdLiteralCharacter( t, value )

    method type->Type
      return Types.type_Character

    method to->String
      if (value == '\'' or value == '\\') return "\\" + value
      if (value == '\n') return "\\n"
      if (value < 32 or (value > 126 and value <= 255)) return "\\" + value->Integer.to_hex_string(2)
      if (value >= 256) return "\\u" + value->Integer.to_hex_string(4)
      return ""+value

    method print( buffer:StringBuilder )
      buffer.print( '\'' )
      buffer.print( this->String )
      buffer.print( '\'' )

    method cast_to( cast_t:Token, to_type:Type )->Cmd
# print(cast_t)
# println(to_type)
      if (to_type.is_Character) return this

      if (to_type.is_Real)
        throw t.error( //Invalid conversion from to:Character Real.// )

      elseIf (to_type.is_Integer)
        return CmdLiteralInteger( t, value->Integer)

      elseIf (to_type.is_Logical)
        throw t.error( //Invalid conversion from to:Character Logical.  Use "ch?" instead.// )

      elseIf (to_type.is_String)
        return CmdLiteralString( t, ""+value )

      else
        throw t.error( "TODO: CmdLiteralCharacter::cast_to()." )
      endIf

endClass

class CmdLiteralByte : CmdLiteral
  PROPERTIES
    value : Integer

  METHODS
    method init( t, value )
      value &= 255

    method clone->CmdLiteralByte
      return CmdLiteralByte( t, value )

    method type->Type
      return Types.type_Byte

    method to->String
      return "" + value

    method print( buffer:StringBuilder )
      buffer.print( "Byte(" )
      buffer.print( value )
      buffer.print( ")" )

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (to_type.is_Byte) return this

      if (to_type.is_Real)
        return CmdLiteralReal( t, value )

      elseIf (to_type.is_Integer)
        return CmdLiteralInteger( t, value->Integer )

      elseIf (to_type.is_Character)
        return CmdLiteralCharacter( t, value->Character )

      elseIf (to_type.is_Logical)
        throw t.error( //Invalid conversion from Byte to Logical.  Use "value?" instead.// )

      elseIf (to_type.is_String)
        return CmdLiteralString( t, ""+value )

      #elseIf (to_type.def is TypeDefs.type_IntegerObject or to_type.is_Object)
        #return CmdAccess( t, "IntegerObject", CmdArgs(this) ).resolve

      else
        throw t.error( "Invalid cast from Byte to " + to_type.name + "." )
      endIf

endClass

class CmdLiteralLogical : CmdLiteral
  PROPERTIES
    value : Logical

  METHODS
    method init( t, value )

    method clone->CmdLiteralLogical
      return CmdLiteralLogical( t, value )

    method type->Type
      return Types.type_Logical

    method to->String
      if (value) return "true"
      else       return "false"

    method print( buffer:StringBuilder )
      buffer.print( this->String )

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (to_type.is_Logical) return this

      if (to_type.is_Real)
        throw t.error( //Invalid conversion from to:Logical Real.// )

      elseIf (to_type.is_Integer)
        return CmdConvertLogicalToInteger( t, this )

      elseIf (to_type.is_Character)
        throw t.error( //Invalid conversion from to:Logical Character.// )

      elseIf (to_type.is_String)
        if (value) return CmdLiteralString( t, "true" )
        else       return CmdLiteralString( t, "false" )

      else
        throw t.error( "TODO: CmdLiteralLogical::cast_to()." )
      endIf

endClass

class CmdLiteralString : CmdLiteral
  PROPERTIES
    value : String

  METHODS
    method init( t, value )

    method clone->CmdLiteralString
      return CmdLiteralString( t, value )

    method type->Type
      return Types.type_String

    method to->String
      return "$" (value)

    method print( buffer:StringBuilder )
      #buffer.print( //"$"// (value) )
      buffer.print( //"// + value + //"// )

endClass

class CmdLiteralNull : CmdLiteral
  PROPERTIES
    of_type : Type

  METHODS
    method init( t )
      init( t, Types.type_Object )

    method init( t, of_type )

    method clone->CmdLiteralNull
      return CmdLiteralNull( t, of_type )

    method type->Type
      return of_type

    method instance_of( ancestor:Type)->Logical
      return ancestor.is_reference

    method to->String
      return "null"

    method print( buffer:StringBuilder )
      buffer.print( "null" )

    #method require_value( allow_unchecked:Logical ).Cmd
    method require_value->Cmd
      local _type = type
      if (type is null) throw t.error( "Value expected." )
      #if (not allow_unchecked)
      #throw t.error( "Non-null value required for method with a null-checked return type." )
      #endIf
      return this

    method resolve->Cmd
      of_type.resolve(t)
      return this

    method cast_to( cast_t:Token, to_type:Type )->Cmd
      if (to_type.is_reference)
        of_type = to_type
      else
        #throw cast_t.error( "Cannot cast a null reference to type $." (to_type) )
        throw cast_t.error( "Cannot cast a null reference to type " + to_type.name + "." )
      endIf
      return this


endClass

class CmdLiteralList : CmdLiteral
  PROPERTIES
    args : CmdArgs

  METHODS
    method init( t )
      args = CmdArgs()

    method init( t, args )

    method clone->CmdLiteralList
      return CmdLiteralList( t, args.clone )

    method implicit_type->Type
      local common_type : Type

      forEach (arg in args)
        local arg_type = arg.implicit_type
        if (arg_type is null) return null

        if (common_type?)
          if (common_type isNot arg_type)
            if (common_type.is_primitive and arg_type.is_primitive)
              if (common_type.is_Logical or arg_type.is_Logical) return null
              if (common_type.is_Real or arg_type.is_Real) return Types.reference(t,"Real[]")
              return Types.reference(t,"Integer[]")
            else
              return null
            endIf
          endIf
        else
          common_type = arg_type
        endIf
      endForEach

      if (common_type is null) return null

      return Types.reference( t, common_type.name + "[]" ).resolve(t)

    method is_complex_reference->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print('[')
      local first = true
      forEach (arg in args)
        if (first) first = false
        else       buffer.print(',')
        arg.print( buffer )
      endForEach
      buffer.print(']')

    method resolve->Cmd
      local common_type : Type

      forEach (index in args.indices)
        local arg = args[index].resolve.require_value
        args[index] = arg

        local arg_type = arg.type

        if (common_type?)
          if (common_type isNot arg_type)
            if (common_type.is_primitive and arg_type.is_primitive)
              if (common_type.is_Logical or arg_type.is_Logical)
                throw arg.t.error( "TODO: promote list to an Object list with boxed primitives." )
              endIf
              if (common_type.is_Real or arg_type.is_Real) common_type = Types.type_Real
              else                                         common_type = Types.type_Integer
            else
              throw arg.t.error( "TODO: promote list to an Object list with boxed primitives." )
            endIf
          endIf
        else
          common_type = arg_type
        endIf
      endForEach

      local all_literals = true
      forEach (index in args.indices)
        local arg = args[index]
        args[index] = arg.cast_to( arg.t, common_type )
        if (arg notInstanceOf CmdLiteral) all_literals = false
      endForEach

      if (common_type.is_Integer)
        return CmdNewObject( t, Types.reference(t,"Integer[]"), CmdArgs( CmdLiteralArray(t, "Integer", args, all_literals) ) )

      elseIf (common_type.is_Real)
        return CmdNewObject( t, Types.reference(t,"Real[]"), CmdArgs( CmdLiteralArray(t, "Real", args, all_literals) ) )

      elseIf (common_type.is_reference)
        return CmdNewObject( t, Types.reference(t,common_type.name+"[]"), CmdArgs( CmdLiteralArray(t, common_type.name, args, all_literals) ) )

      elseIf (common_type.is_Character)
        return CmdNewObject( t, Types.reference(t,"Character[]"),
          CmdArgs( CmdLiteralArray(t, "Character", args, all_literals) ) )

      elseIf (common_type.is_Logical)
        return CmdNewObject( t, Types.reference(t,"Logical[]"),
          CmdArgs( CmdLiteralArray(t, "Logical", args, all_literals) ) )

      endIf

      throw t.error( "TODO: CmdLiteralList of type " + common_type )
endClass


class CmdLiteralArray : Cmd
  PROPERTIES
    array_type   : Type
    element_type : Type
    elements     : CmdArgs
    all_literals : Logical

  METHODS
    method init( t, element_name:String, elements, all_literals )
      element_type = Types.reference( t, element_name )
      array_type = Types.reference( t, "Array<<" + element_name + ">>" )

    method init( t, array_type, element_type, elements, all_literals )

    method clone->CmdLiteralArray
      return CmdLiteralArray( t, array_type, element_type, elements, all_literals )

    method implicit_type->Type
      return array_type

    method is_complex_reference->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( array_type )
      buffer.print( "[" )
      local first = true
      forEach (element in elements)
        if (first) first = false
        else       buffer.print(',')
        element.print( buffer )
      endForEach
      buffer.print( "]" )

    method type->Type
      return array_type

    method resolve->Cmd
      array_type.resolve
      element_type.resolve
      elements.resolve
      return this
endClass


class CmdUnary : Cmd
  PROPERTIES
    operand     : Cmd
    opcode = -1 : Integer

  METHODS
    method init( t, operand )

    method is_complex_reference->Logical
      return true

    method type->Type
      return operand.type

    method name->String
      return "[unnamed unary op]"

    method print( buffer:StringBuilder )
      buffer.print( '(' )
      buffer.print( name )
      buffer.print( ' ' )
      operand.print( buffer )
      buffer.print( ')' )

    method resolve->Cmd
      operand = operand.resolve.require_value
      local operand_type = operand.type

      if (operand instanceOf CmdLiteral)
        if (operand_type.is_Real)
          local result = resolve_for_literal_real_operand( (operand as CmdLiteralReal).value )
          if (result?) return result
        elseIf (operand_type.is_Integer)
          local result = resolve_for_literal_integer_operand( (operand as CmdLiteralInteger).value )
          if (result?) return result
        elseIf (operand_type.is_Logical)
          local result = resolve_for_literal_logical_operand( (operand as CmdLiteralLogical).value )
          if (result?) return result
        else
          local result = resolve_for_literal_operand
          if (result?) return result
        endIf
      endIf

      if (operand_type.is_reference)
        local result = resolve_for_reference_operand
        if (result?) return result
      endIf

      return resolve_for_operand_type( operand_type )

    method resolve_for_literal_real_operand( operand_value:Real )->Cmd
      return null

    method resolve_for_literal_integer_operand( operand_value:Integer)->Cmd
      return null

    method resolve_for_literal_logical_operand( operand_value:Logical )->Cmd
      return null

    method resolve_for_literal_operand->Cmd
      return null

    method resolve_for_operand_type( operand_type:Type )->Cmd
      return this

    method resolve_for_reference_operand->Cmd
      return null
endClass

class CmdLogicalNot : CmdUnary
  METHODS
    method clone->CmdLogicalNot
      return CmdLogicalNot( t, operand )

    method name->String
      return "not"

    method implicit_type->Type
      return Types.type_Logical

    method resolve_for_literal_real_operand( operand_value:Real )->Cmd
      # TODO
      return null

    method resolve_for_literal_integer_operand( operand_value:Integer)->Cmd
      # TODO
      return null

    method resolve_for_literal_logical_operand( operand_value:Logical )->Cmd
      return CmdLiteralLogical( t, (not operand_value) )

endClass

class CmdNegate : CmdUnary
  METHODS
    method clone->CmdNegate
      return CmdNegate( t, operand )

    method name->String
      return "-"

    method implicit_type->Type
      return operand.implicit_type

    method resolve_for_literal_real_operand( operand_value:Real )->Cmd
      return CmdLiteralReal( t, -operand_value )

    method resolve_for_literal_integer_operand( operand_value:Integer)->Cmd
      return CmdLiteralInteger( t, -operand_value )

    method resolve_for_literal_logical_operand( operand_value:Logical )->Cmd
      return CmdLiteralLogical( t, (not operand_value) )

    method resolve_for_reference_operand->Cmd
      return CmdAccess( t, operand, "operator-", null ).resolve.require_value

    method resolve_for_operand_type( operand_type:Type )->Cmd
      if (operand_type.is_Real or operand_type.is_Integer)
        return this
      elseIf (operand_type.is_Character or operand_type.is_Byte)
        local result = CmdNegate( t, operand.cast_to(t, Types.type_Integer) ).resolve
        return result
      endIf
      return this

endClass

class CmdBitwiseNot : CmdUnary
  METHODS
    method clone->CmdBitwiseNot
      return CmdBitwiseNot( t, operand )

    method name->String
      return "!"

    method implicit_type->Type
      return operand.implicit_type

    method resolve_for_literal_integer_operand( operand_value:Integer)->Cmd
      # TODO
      # return CmdLiteralInteger( t, !operand_value )
      return null

    method resolve_for_literal_logical_operand( operand_value:Logical )->Cmd
      return CmdLiteralLogical( t, (not operand_value) )

    method resolve_for_integer_operand->Cmd
      opcode = Op.bitwise_not_integer
      return this

    method resolve_for_logical_operand->Cmd
      opcode = Op.logical_not
      return this

    method resolve_for_reference_operand->Cmd
      return CmdAccess( t, operand, "operator!", null ).resolve.require_value
endClass

class CmdLogicalize : CmdUnary
  METHODS
    method clone->CmdLogicalize
      return CmdLogicalize( t, operand )

    method name->String
      return "?"

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( '?' )

    method implicit_type->Type
      return Types.type_Logical

    method type->Type
      return Types.type_Logical

    method resolve_for_literal_real_operand( operand_value:Real )->Cmd
      return CmdLiteralLogical( t, operand_value? )

    method resolve_for_literal_integer_operand( operand_value:Integer)->Cmd
      return CmdLiteralLogical( t, operand_value? )

    method resolve->Cmd
      operand = operand.resolve.require_value
      if (operand.type.is_Logical) return operand

      return prior.resolve

endClass


class CmdAccess : Cmd
  PROPERTIES
    operand     : Cmd
    name        : String
    args        : CmdArgs

  METHODS
    method init( t, name )

    method init( t, name, args )

    method init( t, operand, name, args )

    method clone->CmdAccess
      return CmdAccess( t, clone(operand), name, clone(args) )

    method implicit_type->Type
      local as_type = Types.find_type_or_template( t, name )
      if (as_type?)
        return as_type
      else
        if (operand is null and args is null)
          local v = Analyzer.context.find_local( name )
          if (v?) return v.type
        endIf
      endIf
      return null

    method print( buffer:StringBuilder )
      if (operand?)
        operand.print( buffer )
        buffer.print( '.' )
      endIf
      buffer.print( name )
      if (args?)
        buffer.print( '(' )
        args.print( buffer )
        buffer.print( ')' )
      endIf

    method resolve->Cmd
      return resolve_with_type_hint( null )

    method resolve_with_type_hint( type_hint:Type )->Cmd
      if (operand?)
        operand = operand.resolve.require_value
      endIf

      local as_type = Types.find_type_or_template( t, name )

      if (operand?)
        # Explicit context
        operand = operand.resolve_with_type_hint( as_type ).require_value

        local operand_type = operand.type
        operand_type.resolve
        #{
        if (operand_type.is_primitive)
          # Primitive context
          if (as_type? and args is null)
            return operand.cast_to(t,as_type).resolve
          endIf
          throw t.error( "TODO: CmdAccess::resolve with primitive context" )
        else
          }#
          # Object context

          # An object is calling to-type for its own type (e.g. "ABC".String).
          # Strip the call.
          if (operand_type is type_hint) return operand

          # Check for methods first
          local result = Analyzer.resolve_call( t, operand_type, operand, name, args, false )
          if (result?) return result

          # Then check for property access
          local p = operand_type.find_property( name )
          if (p?) return CmdReadProperty(t,operand,p).resolve

          local s = operand_type.find_setting( name )
          if (s?) return CmdReadSetting(t,operand,s).resolve

          #println( "TODO: check for Object::[TypeName]." )

          # Throw an error while allowing possible candidate methods to print out
          result = Analyzer.resolve_call( t, operand_type, operand, name, args, true )
          return null  # never happens

          #endIf

      else
        # Implicit/'this' context
        if (args is null)
          local v = Analyzer.context.find_local( name )
          if (v?)
            return CmdReadLocal( t, v )
          endIf
        endIf

        if (as_type?)
          if (args? or name.ends_with(']'))
            # New object
            if (args is null) args = CmdArgs()
            return CmdNewObject( t, as_type, args ).resolve
          else
            # Singleton access
            if (as_type.generic_base?) throw t.error( "Attempt to read generic-type singleton; generic types do not have singletons." )
            return CmdReadSingleton( t, as_type ).resolve
          endIf
        endIf

        # Check for a method call with an optional return type hint
        local result = Analyzer.resolve_call( t, Analyzer.context.this_type, null, name, args, false )
        if (result?) return result

        # Check for property access
        local p = Analyzer.context.this_type.find_property( name )
        if (p?) return CmdReadProperty( t, null, p ).resolve

        local s = Analyzer.context.this_type.find_setting( name )
        if (s?) return CmdReadSetting(t,null,s).resolve

        Analyzer.resolve_call( t, Analyzer.context.this_type, null, name, args, true )  # will generate an error
      endIf

      throw t.error( "TODO: CmdAccess::resolve()" )

    method resolve_increment->Cmd
      if (operand?)
        operand = operand.resolve
        local p = operand.type.find_property( name )
        if (p?) return CmdIncrementProperty( t, operand, p ).resolve

        p = operand.type.must_find_setting( t, name )
        return CmdIncrementSetting( t, operand, p ).resolve
      else
        local v = Analyzer.context.find_local( name )
        if (v?)
          return CmdIncrementLocal(t,v).resolve
        endIf

        local this_type = Analyzer.context.this_type
        local p = this_type.find_property( name )
        if (p?) return CmdIncrementProperty( t, operand, p ).resolve

        p = this_type.must_find_setting( t, name )
        return CmdIncrementSetting( t, operand, p ).resolve
      endIf

    method resolve_decrement->Cmd
      if (operand?)
        operand = operand.resolve
        local p = operand.type.find_property( name )
        if (p?) return CmdDecrementProperty( t, operand, p ).resolve

        p = operand.type.must_find_setting( t, name )
        return CmdDecrementSetting( t, operand, p ).resolve
      else
        local v = Analyzer.context.find_local( name )
        if (v?)
          return CmdDecrementLocal(t,v).resolve
        endIf

        local this_type = Analyzer.context.this_type
        local p = this_type.find_property( name )
        if (p?) return CmdDecrementProperty( t, null, p ).resolve

        p = this_type.must_find_setting( t, name )
        return CmdDecrementSetting( t, operand, p ).resolve
      endIf

    method resolve_assignment( new_value:Cmd, operation:Integer)->Cmd
      if (args?)
        throw t.error( "Illegal target for assignment." )
      endIf

      local context_type : Type
      if (operand?)
        operand = operand.resolve.require_value
        context_type = operand.type
      else
        context_type = Analyzer.context.this_method.type_context
      endIf

      if (name[0] != '@')
        # Try "[obj.]name = value" -> [obj.]name( value )
        if (context_type.find_method( name, 1 )?)
          local cmd = Analyzer.resolve_call( t, context_type, operand, name, CmdArgs(new_value), false )
          if (cmd?) return cmd
        endIf
      endIf

      if (operand?)
        operand = operand.resolve.require_value
        local operand_type = operand.type
        if (args is null)
          # Most likely to be a property so we'll check for that first
          local p = operand_type.find_property( name )
          if (p?)
            which (operation)
              case 0:                                   return CmdWriteProperty(t,operand,p,new_value).resolve
              case Token.symbol_add_assign:         return CmdAddAssignProperty(t,operand,p,new_value).resolve
              case Token.symbol_subtract_assign:    return CmdSubtractAssignProperty(t,operand,p,new_value).resolve
              case Token.symbol_multiply_assign:    return CmdMultiplyAssignProperty(t,operand,p,new_value).resolve
              case Token.symbol_divide_assign:      return CmdDivideAssignProperty(t,operand,p,new_value).resolve
              case Token.symbol_mod_assign:         return CmdModAssignProperty(t,operand,p,new_value).resolve
              case Token.symbol_power_assign:       return CmdPowerAssignProperty(t,operand,p,new_value).resolve
              case Token.symbol_bitwise_and_assign: return CmdBitwiseAndAssignProperty(t,operand,p,new_value).resolve
              case Token.symbol_bitwise_or_assign:  return CmdBitwiseOrAssignProperty(t,operand,p,new_value).resolve
              case Token.symbol_bitwise_xor_assign: return CmdBitwiseXorAssignProperty(t,operand,p,new_value).resolve
              others:                                   throw Error( "TODO" )
            endWhich
          endIf

          # Check for setting
          p = operand_type.find_setting( name )
          if (p?)
            which (operation)
              case 0:                                   return CmdWriteSetting(t,operand,p,new_value).resolve
              case Token.symbol_add_assign:         return CmdAddAssignSetting(t,operand,p,new_value).resolve
              case Token.symbol_subtract_assign:    return CmdSubtractAssignSetting(t,operand,p,new_value).resolve
              case Token.symbol_multiply_assign:    return CmdMultiplyAssignSetting(t,operand,p,new_value).resolve
              case Token.symbol_divide_assign:      return CmdDivideAssignSetting(t,operand,p,new_value).resolve
              case Token.symbol_mod_assign:         return CmdModAssignSetting(t,operand,p,new_value).resolve
              case Token.symbol_power_assign:       return CmdPowerAssignSetting(t,operand,p,new_value).resolve
              case Token.symbol_bitwise_and_assign: return CmdBitwiseAndAssignSetting(t,operand,p,new_value).resolve
              case Token.symbol_bitwise_or_assign:  return CmdBitwiseOrAssignSetting(t,operand,p,new_value).resolve
              case Token.symbol_bitwise_xor_assign: return CmdBitwiseXorAssignSetting(t,operand,p,new_value).resolve
              others:                                   throw Error( "TODO" )
            endWhich
          endIf

        endIf
        throw t.error( "Cannot find property " + name + " in CmdAccess::resolve_assignment().  TODO: add check for implicit write method." )
      endIf

      local v = Analyzer.context.find_local( name )
      if (v?)
        which (operation)
          case 0:                                   return CmdWriteLocal(t,v,new_value).resolve
          case Token.symbol_add_assign:         return CmdAddAssignLocal(t,v,new_value).resolve
          case Token.symbol_subtract_assign:    return CmdSubtractAssignLocal(t,v,new_value).resolve
          case Token.symbol_multiply_assign:    return CmdMultiplyAssignLocal(t,v,new_value).resolve
          case Token.symbol_divide_assign:      return CmdDivideAssignLocal(t,v,new_value).resolve
          case Token.symbol_mod_assign:         return CmdModAssignLocal(t,v,new_value).resolve
          case Token.symbol_power_assign:       return CmdPowerAssignLocal(t,v,new_value).resolve
          case Token.symbol_bitwise_and_assign: return CmdBitwiseAndAssignLocal(t,v,new_value).resolve
          case Token.symbol_bitwise_or_assign:  return CmdBitwiseOrAssignLocal(t,v,new_value).resolve
          case Token.symbol_bitwise_xor_assign: return CmdBitwiseXorAssignLocal(t,v,new_value).resolve
          others:                               throw Error( "TODO" )
        endWhich
      endIf

      # Check for property
      local p = Analyzer.context.this_type.find_property( name )
      if (p?)
        which (operation)
          case 0:                                   return CmdWriteProperty(t,null,p,new_value).resolve
          case Token.symbol_add_assign:         return CmdAddAssignProperty(t,null,p,new_value).resolve
          case Token.symbol_subtract_assign:    return CmdSubtractAssignProperty(t,null,p,new_value).resolve
          case Token.symbol_multiply_assign:    return CmdMultiplyAssignProperty(t,null,p,new_value).resolve
          case Token.symbol_divide_assign:      return CmdDivideAssignProperty(t,null,p,new_value).resolve
          case Token.symbol_mod_assign:         return CmdModAssignProperty(t,null,p,new_value).resolve
          case Token.symbol_power_assign:       return CmdPowerAssignProperty(t,null,p,new_value).resolve
          case Token.symbol_bitwise_and_assign: return CmdBitwiseAndAssignProperty(t,null,p,new_value).resolve
          case Token.symbol_bitwise_or_assign:  return CmdBitwiseOrAssignProperty(t,null,p,new_value).resolve
          case Token.symbol_bitwise_xor_assign: return CmdBitwiseXorAssignProperty(t,null,p,new_value).resolve
          others:                                   throw Error( "TODO" )
        endWhich
      endIf

      # Check for setting
      local s = Analyzer.context.this_type.find_setting( name )
      if (s?)
        which (operation)
          case 0:                                   return CmdWriteSetting(t,null,s,new_value).resolve
          case Token.symbol_add_assign:         return CmdAddAssignSetting(t,null,s,new_value).resolve
          case Token.symbol_subtract_assign:    return CmdSubtractAssignSetting(t,null,s,new_value).resolve
          case Token.symbol_multiply_assign:    return CmdMultiplyAssignSetting(t,null,s,new_value).resolve
          case Token.symbol_divide_assign:      return CmdDivideAssignSetting(t,null,s,new_value).resolve
          case Token.symbol_mod_assign:         return CmdModAssignSetting(t,null,s,new_value).resolve
          case Token.symbol_power_assign:       return CmdPowerAssignSetting(t,null,s,new_value).resolve
          case Token.symbol_bitwise_and_assign: return CmdBitwiseAndAssignSetting(t,null,s,new_value).resolve
          case Token.symbol_bitwise_or_assign:  return CmdBitwiseOrAssignSetting(t,null,s,new_value).resolve
          case Token.symbol_bitwise_xor_assign: return CmdBitwiseXorAssignSetting(t,null,s,new_value).resolve
          others:                                   throw Error( "TODO" )
        endWhich
      endIf

      #throw t.error( //"$" is undefined.// (name) )
      throw t.error( //"// + name + //" is undefined.// )


endClass

class CmdElementAccess : Cmd
  PROPERTIES
    operand : Cmd
    args    : CmdArgs

  METHODS
    method init( t, operand )
      args = CmdArgs()

    method init( t, operand, args )

    method clone->CmdElementAccess
      return CmdElementAccess( t, clone(operand), clone(args) )

    method is_complex_reference->Logical
      return true

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print('[')
      args.print( buffer )
      buffer.print(']')

    method resolve->Cmd
      return Analyzer.resolve_call( t, null, operand, "get", args, true )

    method resolve_with_type_hint( type_hint:Type )->Cmd
      return Analyzer.resolve_call( t, null, operand, "get", args, true )

    method resolve_assignment( new_value:Cmd, operation:Integer)->Cmd
      if (operation?) throw Error("TODO")
      args.add( new_value )
      return Analyzer.resolve_call( t, null, operand, "set", args, true )

endClass

class CmdLocalDeclaration : CmdStatement
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method clone->CmdLocalDeclaration
      return CmdLocalDeclaration( t, local_info )

    method print( buffer:StringBuilder )
      buffer.print( "local " )
      buffer.print( local_info.name )
      if (local_info.type?)
        buffer.print( " : " )
        buffer.print( local_info.type )
      endIf

    method resolve->Cmd
      if (local_info.type?) local_info.type.resolve

      local existing_p = Analyzer.context.this_type.find_property( local_info.name )
      if (existing_p?)
        #throw local_info.t.error( "A property named '$' already exists in class $." (local_info.name,Analyzer.context.this_type) )
        throw local_info.t.error( "A property named '" + local_info.name + "' already exists in class " +  Analyzer.context.this_type + "." )
      endIf

# print(local_info.name)
# print(" ")
# println(local_info.type)
# println
      Analyzer.add_local( local_info )
      return this

endClass

class CmdAssign : CmdStatementWithOperand
  PROPERTIES
    new_value : Cmd

  METHODS
    method init( t, operand, new_value )

    method clone->CmdAssign
      return CmdAssign( t, clone(operand), clone(new_value) )

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( " = " )
      new_value.print( buffer )

    method resolve->Cmd
      return operand.resolve_assignment( new_value, 0 )
endClass

class CmdReadLocal : Cmd
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method init( local_info )
      t = local_info.t

    method clone->CmdReadLocal
      return CmdReadLocal( t, local_info )

    method type->Type
      return local_info.type

    method variable_name->String
      return local_info.name

    method print( buffer:StringBuilder )
      buffer.print( local_info.name )

    method resolve->Cmd
      return this

endClass

class CmdWriteLocal : CmdStatement
  PROPERTIES
    local_info : Local
    new_value  : Cmd

  METHODS
    method init( t, local_info, new_value )

    method init( local_info, new_value )
      t = local_info.t

    method clone->CmdWriteLocal
      return CmdWriteLocal( t, local_info, clone(new_value) )

    method print( buffer:StringBuilder )
      buffer.print( local_info.name )
      buffer.print( " = " )
      new_value.print( buffer )

    method resolve->Cmd
      new_value = new_value.resolve.require_value
      local new_value_type = new_value.type

      if (local_info.type is null)
        local_info.type = new_value_type
        new_value_type.resolve
      endIf

      if (local_info.type.is_reference)
        local result = resolve_reference_assignment
        if (result?) return result
      endIf

      #if (new_value_type.possibly_null and not local_info.type.possibly_null)
      #throw t.error( "'" + local_info.name + "' can only store null-checked references." )
      #endIf

      new_value = new_value.cast_to(t,local_info.type).resolve

      return this

    method resolve_reference_assignment->Cmd
      return null

endClass

class CmdWriteLocalDefault : CmdStatement
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )
      if (local_info.type is null)
        local_info.type = Types.type_Object
      endIf

    method clone->CmdWriteLocalDefault
      return CmdWriteLocalDefault( t, local_info )

    method print( buffer:StringBuilder )
      buffer.print( local_info.name )
      buffer.print( " = " )
      buffer.print( "(default value)" )

    method resolve->Cmd
      return this

endClass

class CmdIncrement : CmdStatementWithOperand
  METHODS
    method clone->CmdIncrement
      return CmdIncrement( t, clone(operand) )

    method print( buffer:StringBuilder )
      buffer.print( "++" )
      operand.print( buffer )

    method resolve->Cmd
      return operand.resolve_increment
endClass

class CmdIncrementLocal : Cmd
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method clone->CmdIncrementLocal
      return CmdIncrementLocal( t, local_info )

    method print( buffer:StringBuilder )
      buffer.print( "++" )
      buffer.print( local_info.name )

    method resolve->Cmd
      if (local_info.type.is_compound)
        throw t.error( "Cannot increment a compound." )
      elseIf (local_info.type.is_reference)
        return CmdAccess( t, CmdReadLocal(t,local_info), "operator++", null ).resolve
      endIf

      return this
endClass

class CmdIncrementSetting : Cmd
  PROPERTIES
    context  : Cmd
    setting : Property

  METHODS
    method init( t, context, setting )

    method clone->CmdIncrementSetting
      return CmdIncrementSetting( t, clone(context), setting )

    method print( buffer:StringBuilder )
      buffer.print( "++" )
      buffer.print( setting.name )

    method resolve->Cmd
      if (context?) context = context.resolve

      if (setting.type.is_compound)
        throw t.error( "Cannot increment a compound." )
      elseIf (setting.type.is_reference)
        return CmdAccess( t, CmdReadSetting(t,context,setting), "operator++", null ).resolve
      endIf

      return this
endClass

class CmdIncrementProperty : Cmd
  PROPERTIES
    context  : Cmd
    property : Property

  METHODS
    method init( t, context, property )

    method clone->CmdIncrementProperty
      return CmdIncrementProperty( t, clone(context), property )

    method print( buffer:StringBuilder )
      buffer.print( "++" )
      buffer.print( property.name )

    method resolve->Cmd
      if (context?) context = context.resolve

      if (property.type.is_compound)
        throw t.error( "Cannot increment a compound." )
      elseIf (property.type.is_reference)
        return CmdAccess( t, CmdReadProperty(t,context,property), "operator++", null ).resolve
      endIf

      return this
endClass

class CmdDecrement : CmdStatementWithOperand
  METHODS
    method clone->CmdDecrement
      return CmdDecrement( t, clone(operand) )

    method print( buffer:StringBuilder )
      buffer.print( "--" )
      operand.print( buffer )

    method resolve->Cmd
      return operand.resolve_decrement
endClass

class CmdDecrementLocal : Cmd
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method clone->CmdDecrementLocal
      return CmdDecrementLocal( t, local_info )

    method print( buffer:StringBuilder )
      buffer.print( "--" )
      buffer.print( local_info.name )

    method resolve->Cmd
      return this
endClass

class CmdDecrementSetting : Cmd
  PROPERTIES
    context : Cmd
    setting : Property

  METHODS
    method init( t, context, setting )

    method clone->CmdDecrementSetting
      return CmdDecrementSetting( t,clone(context), setting )

    method print( buffer:StringBuilder )
      buffer.print( "--" )
      buffer.print( setting.name )

    method resolve->Cmd
      if (context?) context = context.resolve.require_value

      if (not (setting.type.is_primitive))
        throw t.error( "Cannot decrement a value of type " + setting.type.name + "." )
      endIf

      return this
endClass

class CmdDecrementProperty : Cmd
  PROPERTIES
    context  : Cmd
    property : Property

  METHODS
    method init( t, context, property )

    method clone->CmdDecrementProperty
      return CmdDecrementProperty( t,clone(context), property )

    method print( buffer:StringBuilder )
      buffer.print( "--" )
      buffer.print( property.name )

    method resolve->Cmd
      if (context?) context = context.resolve.require_value

      if (not (property.type.is_primitive))
        #throw t.error( "Cannot decrement a value of type $." (property.type) )
        throw t.error( "Cannot decrement a value of type " + property.type.name + "." )
      endIf

      return this
endClass

class CmdThis( t, this_type:Type ) : Cmd
  METHODS
    method clone->CmdThis
      return CmdThis( t, this_type )

    method type->Type
      return this_type

    method print( buffer:StringBuilder )
      buffer.print( "this" )

    method resolve->Cmd
      # Update type in case of propagated method
      this_type = Analyzer.context.this_type
      return this
endClass

class CmdReadSingleton : Cmd
  PROPERTIES
    of_type     : Type

  METHODS
    method init( t, of_type )

    method clone->CmdReadSingleton
      return CmdReadSingleton( t, of_type )

    method type->Type
      return of_type

    method implicit_type->Type
      return of_type

    method print( buffer:StringBuilder )
      buffer.print( of_type )

    method resolve->Cmd
      of_type.resolve(t)

      return this

endClass

class CmdReadSetting : Cmd
  PROPERTIES
    context  : Cmd
    setting : Property

  METHODS
    method init( t, context, setting )

    method clone->CmdReadSetting
      return CmdReadSetting( t, clone(context), setting )

    method type->Type
      return setting.type

    method variable_name->String
      return setting.name

    method print( buffer:StringBuilder )
      if (context?)
        context.print( buffer )
        buffer.print( '.' )
      endIf
      buffer.print( setting.name )

    method resolve->Cmd
      setting.type.resolve(t)
      if (context?)
        context = context.resolve
        #if (context.type.possibly_null) throw t.error( "Unchecked reference access." )
      endIf
      return this
endClass

class CmdReadProperty : Cmd
  PROPERTIES
    context  : Cmd
    property : Property

  METHODS
    method init( t, context, property )

    method init( local_info:Local, _property:Property )
      init( local_info.t, CmdReadLocal(local_info.t, local_info), _property )

    method clone->CmdReadProperty
      return CmdReadProperty( t, clone(context), property )

    method type->Type
      return property.type

    method variable_name->String
      return property.name

    method print( buffer:StringBuilder )
      if (context?)
        context.print( buffer )
        buffer.print( '.' )
      endIf
      buffer.print( property.name )

    method resolve->Cmd
      if (context?)
        context = context.resolve
        #if (context.type.possibly_null) throw t.error( "Unchecked reference access." )
      endIf
      property.type.resolve(t)
      return this
endClass

class CmdWriteSetting : Cmd
  PROPERTIES
    context   : Cmd
    setting   : Property
    new_value : Cmd

  METHODS
    method init( t, context, setting, new_value )

    method clone->CmdWriteSetting
      return CmdWriteSetting( t, clone(context), setting, clone(new_value) )

    method type->Type
      return null

    method name->String
      return "="

    method print( buffer:StringBuilder )
      if (context?)
        context.print( buffer )
        buffer.print( '.' )
      endIf
      buffer.print( setting.name )
      buffer.print( ' ' )
      buffer.print( name )
      buffer.print( ' ' )
      new_value.print( buffer )

    method resolve->Cmd
      setting.type.resolve(t)
      new_value = new_value.resolve.require_value

      #if (new_value.type.possibly_null and not setting.type.possibly_null)
      #throw t.error( "'" + setting.name + "' can only store null-checked references." )
      #endIf

      if (context?) context = context.resolve

      if (setting.type.is_reference)
        local result = resolve_reference_assignment
        if (result?) return result
      endIf

      new_value = new_value.resolve.cast_to(t,setting.type).resolve
      return this

    method resolve_reference_assignment->Cmd
      return null

endClass

class CmdWriteProperty : Cmd
  PROPERTIES
    context   : Cmd
    property  : Property
    new_value : Cmd

  METHODS
    method init( t, context, property, new_value )

    method clone->CmdWriteProperty
      return CmdWriteProperty( t, clone(context), property, clone(new_value) )

    method is_op_assign->Logical
      return false

    method type->Type
      return null

    method name->String
      return "="

    method print( buffer:StringBuilder )
      if (context?)
        context.print( buffer )
        buffer.print( '.' )
      endIf
      buffer.print( property.name )
      buffer.print( ' ' )
      buffer.print( name )
      buffer.print( ' ' )
      new_value.print( buffer )

    method resolve->Cmd
      property.type.resolve(t)
      new_value = new_value.resolve.require_value

      #if (new_value.type.possibly_null and not property.type.possibly_null)
      #throw t.error( "'" + property.name + "' can only store null-checked references." )
      #endIf

      #{
      if (context?)
        context = context.resolve.require_value
        if (is_op_assign and context.is_complex_reference)
          # Refactor:
          #   context.property += result
          #
          # into:
          #   local temp = context
          #   temp.property += result
          #
          # so that it may also be written as:
          #   local temp = context
          #   temp.property = temp.property + result
        endIf
      endIf
      }#

      if (property.type.is_reference)
        local result = resolve_reference_assignment
        if (result?) return result
      endIf

      new_value = new_value.resolve.cast_to(t,property.type).resolve
      return this

    method resolve_reference_assignment->Cmd
      return null

endClass

class CmdNewObject : Cmd
  PROPERTIES
    of_type     : Type
    init_method : Method
    args        : CmdArgs

  METHODS
    method init( t, of_type )

    method init( t, of_type, args )

    method init( t, of_type, args, init_method )

    method clone->CmdNewObject
      return CmdNewObject( t, of_type, clone(args), init_method )

    method is_complex_reference->Logical
      return true

    method type->Type
      return of_type

    method print( buffer:StringBuilder )
      buffer.print( of_type )
      buffer.print( '(' )
      args.print( buffer )
      buffer.print( ')' )

    method resolve->Cmd
      of_type.resolve(t)

      if (of_type.is_native)
        return CmdAccess( t, CmdReadSingleton(t,of_type), "create", args ).resolve
      endIf

      if (args?) args.resolve

      local create_method = Analyzer.find_method( t, of_type, "create", args, false )
      if (create_method?)
        return CmdAccess( t, CmdReadSingleton(t,of_type), "create", args ).resolve
      endIf

      init_method = Analyzer.find_method( t, of_type, "init", args, false )
      if (init_method?)
        if (args?) args.cast_to( init_method.parameters )
      else
        local buffer = StringBuilder()
        buffer.print( "No 'create' or 'init' method matching signature (" )
        if (args?)
          local first = true
          forEach (arg in args)
            if (first) first = false
            else       buffer.print(',')
            buffer.print( arg.type )
          endForEach
        endIf
        buffer.print( ") in class " )
        buffer.print( of_type )
        buffer.print( '.' )
        throw t.error( buffer->String )
      endIf
      return this

endClass

class CmdCall : Cmd
  PROPERTIES
    context           : Cmd
    method_info       : Method
    args              : CmdArgs
    clone : Logical

  METHODS
    method init( t, context, method_info )
      args = Analyzer.empty_args

    method init( t, context, method_info, args )
      if (args is null) args = Analyzer.empty_args

    method clone->CmdCall
      return CmdCall( t, clone(context), method_info, clone(args) )

    method is_complex_reference->Logical
      return true

    method type->Type
      return method_info.return_type

    method variable_name->String
      return method_info.name

    method print( buffer:StringBuilder )
      buffer.print( '(' )

      if (context?)
        context.print( buffer )
        buffer.print( '.' )
      endIf

      buffer.print( method_info.type_context.name )
      buffer.print( "::" )

      buffer.print( method_info.name )
      buffer.print( '(' )
      args.print( buffer )
      buffer.print( ')' )
      if (method_info.return_type?)
        buffer.print( "->" )
        buffer.print( method_info.return_type )
      endIf
      buffer.print( ')' )

    method resolve->Cmd
      if (context?)
        context = context.resolve.require_value
        context.type.resolve( t )
        #local context_type = context.type
        #if (context_type.possibly_null) throw t.error( "Unchecked reference access." )
      endIf
      args.resolve
      return this

endClass

class CmdStaticCall : CmdCall
  METHODS
    method clone->CmdStaticCall
      return CmdStaticCall( t, clone(context), method_info, clone(args) )
endClass

class CmdDynamicCall : CmdCall
  METHODS
    method init( t, context, method_info )
      args = Analyzer.empty_args

    method init( t, context, method_info, args )
      if (args is null) args = Analyzer.empty_args

    method init( local_info:Local, method_info )
      init( local_info.t, CmdReadLocal(local_info.t, local_info), method_info, null )

    method init( local_info:Local, method_info, args )
      init( local_info.t, CmdReadLocal(local_info.t, local_info), method_info, args )

    method clone->CmdDynamicCall
      return CmdDynamicCall( t, clone(context), method_info, clone(args) )

    method resolve->Cmd
      if (method_info.name == "create") return CmdStaticCall( t, context, method_info, args ).resolve

      if (context?)
        context = context.resolve.require_value
      endIf

      args.resolve
      return this

      return prior.resolve
endClass

class CmdPriorCall( t, name:String, args:CmdArgs ) : Cmd
  METHODS
    method clone->CmdPriorCall
      return CmdPriorCall( t, name, clone(args) )

    method is_complex_reference->Logical
      return true

    method resolve->Cmd
      return resolve_with_type_hint( null )

    method resolve_with_type_hint( type_hint:Type )->Cmd
      local cur_m = Analyzer.find_method( t, Analyzer.context.this_type, name, args, true )
      if (cur_m.is_initializer and Analyzer.context.this_type isNot cur_m.type_context)
        return CmdStaticCall( t, null, cur_m, args ).resolve
      else
        local cur_type = cur_m.type_context
        #if (cur_type.base_types.count == 0) throw t.error( "No prior definition of $::$." (cur_type,cur_m.signature) )
        if (cur_type.base_types.count == 0) throw t.error( "No prior definition of " + cur_type.name + "::" + cur_m.signature + "." )
        local m = Analyzer.find_method( t, cur_type.base_types.first, name, args, true )
        return CmdStaticCall( t, null, m, args ).resolve
      endIf
endClass

class CmdStatement : Cmd
  METHODS
    method type->Type
      return null

    method resolve->Cmd
      return this
endClass

class CmdControlStructure : CmdStatement
  PROPERTIES
    control_id=Analyzer.unique_id  : String
    control_id_used_in_nested_code : Logical
endClass

class CmdIf : CmdControlStructure
  PROPERTIES
    condition           : Cmd
    body                : CmdStatementList
    elseIf_conditions   = Cmd[]
    elseIf_bodies       = CmdStatementList[]
    else_body           : CmdStatementList

  METHODS
    method init( t, condition )
      body = CmdStatementList()

    method clone->CmdIf
      local result = CmdIf( t, clone(condition) )
      result.body = clone(body)
      forEach (elseIf_c in elseIf_conditions) result.elseIf_conditions.add( clone(elseIf_c) )
      forEach (elseIf_b in elseIf_bodies) result.elseIf_bodies.add( clone(elseIf_b) )
      result.else_body = clone( else_body )
      return result

    method print( buffer:StringBuilder )
      buffer.print( "if (" )
      condition.print( buffer )
      buffer.println( ')' )

      body.print( buffer )

      forEach (index in elseIf_conditions.indices)
        buffer.print( "      elseIf (" )
        elseIf_conditions[index].print( buffer )
        buffer.println( ")" )
        elseIf_bodies[index].print( buffer )
      endForEach

      if (else_body?)
        buffer.println( "      else" )
        else_body.print( buffer )
      endIf
      buffer.println( "      endIf" )

    method resolve->Cmd
      condition = condition.resolve.require_value
      local condition_type = condition.type
      #{
      if (condition_type.is_reference)
        return CmdIfNonNull( t, condition, body, else_body ).resolve
      endIf
      }#

      condition.require_logical

      Analyzer.context.control_structure_stack.add( this )
      body.resolve

      forEach (index in elseIf_conditions.indices)
        elseIf_conditions[index] = elseIf_conditions[index].resolve.require_value
        elseIf_bodies[index].resolve
      endForEach

      if (else_body?) else_body.resolve

      Analyzer.context.control_structure_stack.remove_last
      return this
endClass

class CmdWhich : CmdControlStructure
  PROPERTIES
    expression       : Cmd
    cases            = CmdWhichCase[](1)
    others_case      : CmdStatementList

    which_is = false : Logical

  METHODS
    method init( t, expression, which_is )

    method clone->CmdWhich
      local result = CmdWhich( t, clone(expression), which_is )
      forEach (c in cases) result.cases.add( clone(c) as CmdWhichCase )
      result.others_case = clone( others_case )
      return result

    method resolve->Cmd
      expression = expression.resolve

      local cmd_if : CmdIf
      forEach (c in cases)
        local ors=CmdLiteralLogical( t, false ) : Cmd # Seed for the OR expression
        forEach(v in c.values)
          local cmp:Cmd
          if (not which_is) cmp = CmdCompareEQ( t, expression, v)
          else              cmp = CmdCompareIs( t, expression, v)

          ors = CmdLogicalOr(t, ors, cmp ) # "Append" next or to expression
        endForEach

        if (cmd_if?)
          cmd_if.elseIf_conditions.add( ors )
          cmd_if.elseIf_bodies.add( c.body )
        else
          cmd_if = CmdIf( t, ors )
          cmd_if.body = c.body
        endIf
      endForEach

      if (others_case?)
        cmd_if.else_body = others_case
      endIf

      return cmd_if.resolve

endClass

class CmdWhichCase : Cmd
  PROPERTIES
    values    = Cmd[](1)
    body      : CmdStatementList

  METHODS
    method init( t )
      body = CmdStatementList()

    method clone->CmdWhichCase
      local result = CmdWhichCase( t )
      forEach (v in values) result.values.add( clone(v) )
      result.body = clone( body )
      return result

    method resolve->Cmd
      throw t.error( "resolve() not implemented for CmdWhichCase." )

endClass

class CmdContingent : CmdControlStructure
  PROPERTIES
    body             : CmdStatementList
    satisfied_body   : CmdStatementList
    unsatisfied_body : CmdStatementList

  METHODS
    method init( t )
      body = CmdStatementList()

    method init( t, body )

    method clone->CmdContingent
      local result = CmdContingent( t, clone(body) )
      result.satisfied_body = clone( satisfied_body )
      result.unsatisfied_body = clone( unsatisfied_body )
      return result

    method print( buffer:StringBuilder )
      buffer.println( "contingent" )
      body.print( buffer )
      if (satisfied_body?)
        buffer.println( "satisfied" )
        satisfied_body.print( buffer )
      endIf

      if (unsatisfied_body?)
        buffer.println( "unsatisfied" )
        unsatisfied_body.print( buffer )
      endIf

    method resolve->Cmd
      Analyzer.context.control_structure_stack.add( this )
      body.resolve

      if (satisfied_body?) satisfied_body.resolve
      if (unsatisfied_body?) unsatisfied_body.resolve

      Analyzer.context.control_structure_stack.remove_last

      return this
endClass

class CmdContingentControlStructure : CmdStatementWithOperand
  PROPERTIES
    label     : String
    target_id : String
endClass

class CmdNecessary : CmdContingentControlStructure
  METHODS
    method clone->CmdNecessary
      return CmdNecessary( t, clone(operand) )

    method print( buffer:StringBuilder )
      buffer.print( "necessary " )
      operand.print( buffer )

    method resolve->Cmd
      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure instanceOf CmdContingent)
          target_id = control_structure.control_id
          operand = operand.resolve.require_logical
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'contingent' for 'necessary' clause." )
endClass

class CmdSufficient : CmdContingentControlStructure
  METHODS
    method clone->CmdSufficient
      return CmdSufficient( t, clone(operand) )

    method print( buffer:StringBuilder )
      buffer.print( "sufficient " )
      operand.print( buffer )

    method resolve->Cmd
      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure instanceOf CmdContingent)
          target_id = control_structure.control_id
          operand = operand.resolve.require_logical
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach
      throw t.error( "No enclosing 'contingent' for 'sufficient' clause." )
endClass

class CmdAnonymousBlock : CmdControlStructure
  PROPERTIES
    body : CmdStatementList

  METHODS
    method init( t )
      body=CmdStatementList()

    method init( t, body )

    method clone->CmdAnonymousBlock
      return CmdAnonymousBlock( t, clone(body) )

    method print( buffer:StringBuilder )
      body.print( buffer )

    method resolve->Cmd
      body.resolve
      return this
endClass

class CmdDelegate : Cmd
  PROPERTIES
    context_cmd         : Cmd
    params              : Local[]
    ret_type            : Type
    method_name         : String
    base_class_name     : String
    extended_class_name : String
    method_signature    : String

  METHODS
    method init( t, context_cmd, method_name, method_signature, ...
                 base_class_name, extended_class_name, params, ret_type )

    method is_complex_reference->Logical
      return true

    method resolve->Cmd
      local buffer = StringBuilder()
      context_cmd = context_cmd.resolve

      if (Templates.find( base_class_name ) is null)
        Analyzer.create_base_delegate_type( t, base_class_name, params, ret_type )
      endIf


      local obj_class = context_cmd.type
      # println("found method with signature: " + obj_class.find_method( method_signature ))
      # println("and params: " + obj_class.find_method( method_signature ).parameters[0].type)
      # println(obj_class.find_methods_with_name(method_name))

      local extended_delegate_type   = Types.reference( t, extended_class_name )
      local extended_class_string : String
      if (not extended_delegate_type.is_defined)
        local call_buffer = StringBuilder()
        buffer.println( "class " + extended_class_name + " : " + base_class_name )
        buffer.println( "  PROPERTIES" )
        buffer.println( "    context : " + context_cmd.type.name )
        buffer.println( "  METHODS" )
        buffer.println( "    method init( context )" )
        buffer.print( "    method call( " )
        if (ret_type?) call_buffer.print( "      return context." + method_name )
        else call_buffer.print( "      context." + method_name )
        call_buffer.print( "( " )
        local i = 0
        if(params? and params.count?)
          while (i < params.count - 1)
            buffer.print( "p" + i + ":" + params[i].type.name + ", " )
            call_buffer.print( "p" + i + ", " )
            ++i
          endWhile
          buffer.print( "p" + (params.count-1) + ":" + params.last.type.name + " )" )
          call_buffer.print( "p" + (params.count-1) + " )" )
        else
          buffer.print( " )" )
          call_buffer.print( " )" )
        endIf
        if (ret_type?) buffer.println( "->" + ret_type.name )
        else buffer.println
        buffer.println(call_buffer)
        buffer.println( "endClass" )

        extended_class_string = buffer->String
#println "EXTENDED CLASS STRING: " + extended_class_string
        Parser( "[Internal]", extended_class_string ).parse_content
        extended_delegate_type = Types.reference(t,extended_class_name).resolve
        buffer.clear
      endIf

      return CmdNewObject( t, extended_delegate_type, CmdArgs(context_cmd) ).resolve

endClass


class CmdIterationControlStructure : CmdControlStructure
  PROPERTIES
    body : CmdStatementList
endClass

class CmdWhile : CmdIterationControlStructure
  PROPERTIES
    condition         : Cmd
    original_for_each : CmdForEach

  METHODS
    method init( t, condition )
      body=CmdStatementList()

    method init( t, condition, body )

    method clone->CmdWhile
      return CmdWhile( t, clone(condition), clone(body) )

    method print( buffer:StringBuilder )
      buffer.print( "while (" )
      condition.print( buffer )
      buffer.println( ')' )

      body.print( buffer )

      buffer.println( "      endWhile" )

    method resolve->Cmd
      condition = condition.resolve.require_value
      local condition_type = condition.type
      #{
      if (condition_type.is_reference)
        return CmdIfNonNull( t, condition, body, else_body ).resolve
      endIf
      }#

      condition.require_logical

      if (original_for_each?)
        original_for_each.control_id = control_id
        Analyzer.context.control_structure_stack.add( original_for_each )
      else
        Analyzer.context.control_structure_stack.add( this )
      endIf

      body.resolve

      Analyzer.context.control_structure_stack.remove_last

      return this

endClass

class CmdForEach : CmdIterationControlStructure
endClass

class CmdForEachElementInCollection : CmdForEach
  PROPERTIES
    element_t    : Token
    element_name : String
    element_info   : Local
    collection   : Cmd
    step_size=1  : Integer

  METHODS
    method init( t, element_t, element_name, collection )
      body = CmdStatementList()

    method init( t, element_t, element_name, collection, body )

    method clone->CmdForEachElementInCollection
      local result = CmdForEachElementInCollection( t, element_t, element_name, clone(collection), clone(body)  )
      result.step_size = step_size
      return result

    method print( buffer:StringBuilder )
      buffer.print( "forEach (" )
      buffer.print( element_name )
      buffer.print( ':' )
      buffer.print( element_info.type )
      buffer.print( " in " )
      collection.print( buffer )
      buffer.println( ")" )
      body.print( buffer )
      buffer.println( "      endForEach" )

    method resolve->Cmd
      if (element_info?) return this

      collection = collection.resolve.require_value

      local collection_type = collection.type
      collection_type.resolve

      local m_count = collection_type.find_method( "count()->Integer" )
      local p_count : Property
      if (m_count is null) p_count = collection_type.find_property( "count" )
      local has_count = m_count? or p_count?

      local m_get   = collection_type.find_method( "at(Integer)" )
      if (m_get is null) m_get = collection_type.find_method( "get(Integer)" )

      if (has_count and m_get?)
        #if (m_get.return_type is null) throw collection.error( "Implicit call to $ returns nil." (m_get.signature) )
        if (m_get.return_type is null) throw collection.error( "Implicit call to " + m_get.signature + " returns nil." )
        element_info = Local( element_t, element_name, m_get.return_type )
      else
        throw t.error( "TODO: forEach-in with non-indexed collection." )
      endIf

      local index_name = ".index_" + Analyzer.unique_id
      local index_info = Local( t, index_name, Types.type_Integer)

      local collection_name = ".collection_" + Analyzer.unique_id
      local collection_info = Local( collection.t, collection_name, collection_type )

      Analyzer.context.this_method.add_local( index_info )
      Analyzer.context.this_method.add_local( collection_info )
      Analyzer.context.this_method.add_local( element_info )

      Analyzer.add_local( index_info )
      Analyzer.add_local( collection_info )
      Analyzer.add_local( element_info )

      local count_cmd:Cmd
      if (m_count?) count_cmd = CmdDynamicCall( collection_info, m_count )
      else          count_cmd = CmdReadProperty( collection_info, p_count )

      local condition = CmdCompareLT( index_info.t, CmdReadLocal(index_info), count_cmd )

      local cmd_while = CmdWhile( t, condition, body )
      cmd_while.original_for_each = this

      body.insert( CmdIncrementLocal( index_info.t, index_info ) )
      body.insert( CmdWriteLocal( element_info, CmdDynamicCall(collection_info,m_get,CmdArgs(CmdReadLocal(index_info))) ) )
      body.insert( CmdLocalDeclaration(t,element_info) )

      local result = CmdStatementList()
      result.add( CmdLocalDeclaration(t,index_info) )
      result.add( CmdLocalDeclaration(t,collection_info) )
      result.add( CmdWriteLocalDefault(t,index_info) )
      result.add( CmdAssign( collection.t, CmdAccess(collection.t,collection_name), collection ) )
      result.add( cmd_while )

      return CmdAnonymousBlock( t, result ).resolve

      #Analyzer.context.push_local_scope
      #Analyzer.add_local( element_info )
      #body.resolve
      #Analyzer.context.pop_local_scope
      #return this

endClass

class CmdForEachIndexOfCollection : CmdForEach
  PROPERTIES
    element_t    : Token
    element_name : String
    element_info : Local
    collection   : Cmd
    step_size=1  : Integer

  METHODS
    method init( t, element_t, element_name, collection )
      body=CmdStatementList()

    method init( t, element_t, element_name, collection, body )

    method clone->CmdForEachIndexOfCollection
      local result = CmdForEachIndexOfCollection( t, element_t, element_name, clone(collection), clone(body)  )
      result.step_size = step_size
      return result

    method print( buffer:StringBuilder )
      buffer.print( "forEach (" )
      buffer.print( element_name )
      buffer.print( ':' )
      buffer.print( element_info.type )
      buffer.print( " of " )
      collection.print( buffer )
      buffer.println( ")" )
      body.print( buffer )
      buffer.println( "      endForEach" )

    method resolve->Cmd
      if (element_info?) return this

      collection = collection.resolve.require_value

      local collection_type = collection.type
      collection_type.resolve

      local m_count = collection_type.find_method( "count()->Integer" )
      local p_count : Property
      if (m_count is null) p_count = collection_type.find_property( "count" )
      local has_count = m_count? or p_count?

      local m_get   = collection_type.find_method( "at(Integer)" )
      if (m_get is null) m_get = collection_type.find_method( "get(Integer)" )

      if (has_count and m_get?)
        #if (m_get.return_type is null) throw collection.error( "Implicit call to $ returns nil." (m_get.signature) )
        if (m_get.return_type is null) throw collection.error( "Implicit call to " + m_get.signature + " returns nil." )
        element_info = Local( element_t, element_name, m_get.return_type )
      else
        throw t.error( "TODO: forEach-of with non-indexed collection." )
      endIf

      element_info = Local( t, element_name, Types.type_Integer)

      local collection_name = ".collection_" + Analyzer.unique_id
      local collection_info = Local( collection.t, collection_name, collection_type )

      Analyzer.context.this_method.add_local( collection_info )
      Analyzer.context.this_method.add_local( element_info )

      Analyzer.add_local( collection_info )
      Analyzer.add_local( element_info )

      local count_cmd:Cmd
      if (m_count?) count_cmd = CmdDynamicCall( collection_info, m_count )
      else          count_cmd = CmdReadProperty( collection_info, p_count )

      local con_t = element_info.t
      local condition = CmdCompareLT( con_t, CmdReadLocal(element_info),
        CmdSubtract(con_t, count_cmd, CmdLiteralInteger(con_t,1)) )

      local cmd_while = CmdWhile( t, condition, body )
      cmd_while.original_for_each = this

      body.insert( CmdIncrementLocal( element_info.t, element_info ) )

      local result = CmdStatementList()
      result.add( CmdLocalDeclaration(t,element_info) )
      result.add( CmdLocalDeclaration(t,collection_info) )
      result.add( CmdWriteLocal(element_info,CmdLiteralInteger(element_info.t,-1)) )
      result.add( CmdAssign( collection.t, CmdAccess(collection.t,collection_name), collection ) )
      result.add( cmd_while )

      return CmdAnonymousBlock( t, result ).resolve

endClass

class CmdLoop : CmdIterationControlStructure
  METHODS
    method init( t )
      body=CmdStatementList()

    method init( t, body )

    method clone->CmdLoop
      return CmdLoop( t, clone(body) )

    method print( buffer:StringBuilder )
      buffer.println( "loop" )
      body.print( buffer )
      buffer.println( "      endLoop" )

    method resolve->Cmd
      Analyzer.context.control_structure_stack.add( this )
      body.resolve
      Analyzer.context.control_structure_stack.remove_last
      return this

endClass

class CmdTry : CmdControlStructure
  PROPERTIES
    body      : CmdStatementList
    catches   = CmdCatch[]

  METHODS
    method init( t )
      body=CmdStatementList()

    method init( t, body )

    method clone->CmdTry
      local result = CmdTry( t, clone(body) )
      forEach (c in catches) result.catches.add( clone(c) as CmdCatch )
      return result

    method resolve->Cmd
      Analyzer.context.control_structure_stack.add( this )

      body.resolve
      forEach (cur_catch in catches) cur_catch.resolve

      Analyzer.context.control_structure_stack.remove_last

      return this
endClass

class CmdCatch : Cmd
  PROPERTIES
    parent     : CmdTry
    local_name : String
    local_type : Type
    local_info : Local
    body       : CmdStatementList

  METHODS
    method init( t, parent )
      body = CmdStatementList()

    method init( t, parent, body )

    method clone->CmdCatch
      local result = CmdCatch( t, parent, clone(body) )
      result.local_name = local_name
      result.local_type = local_type
      result.local_info = local_info
      return result

    method resolve->Cmd
      if (local_info is null)
        local_type.resolve
        local_info = Local( t, local_name, local_type )
        Analyzer.context.this_method.add_local( local_info )
      endIf

      Analyzer.context.push_local_scope
      Analyzer.add_local( local_info )

      body.resolve

      Analyzer.context.pop_local_scope
      return this
endClass

class CmdThrow : CmdStatementWithOperand
  METHODS
    method clone->CmdThrow
      return CmdThrow( t, clone(operand) )

    method print( buffer:StringBuilder )
      buffer.print( "throw " )
      operand.print( buffer )

    method resolve->Cmd
      operand = operand.resolve.require_value
      if (not operand.type.instance_of(Types.type_Exception))
        throw operand.t.error( "Thrown object must be instance of Exception." )
      endIf
      return this
endClass

class CmdControlReset : CmdStatement
  PROPERTIES
    label     : String
    target_id : String
endClass

class CmdEscapeContingent : CmdControlReset
  METHODS
    method init ( t )

    method clone->CmdEscapeContingent
      return CmdEscapeContingent( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeContingent" )

    method resolve->Cmd
      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure instanceOf CmdContingent)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach
      throw t.error( "No enclosing 'contingent' to escape from." )
endClass

class CmdEscapeForEach : CmdControlReset
  METHODS
    method init( t )

    method clone->CmdEscapeForEach
      return CmdEscapeForEach( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeForEach" )

    method resolve->Cmd
      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure instanceOf CmdForEach)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'forEach' to escape from." )
endClass

class CmdEscapeIf : CmdControlReset
  METHODS
    method init( t )

    method clone->CmdEscapeIf
      return CmdEscapeIf( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeIf" )

    method resolve->Cmd
      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure instanceOf CmdIf)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'if' to escape from." )
endClass

class CmdEscapeLoop : CmdControlReset
  METHODS
    method init( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeLoop" )

    method resolve->Cmd
      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure instanceOf CmdLoop)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'loop' to escape from." )
endClass

class CmdEscapeTry : CmdControlReset
  METHODS
    method init( t )

    method clone->CmdEscapeTry
      return CmdEscapeTry( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeTry" )

    method resolve->Cmd
      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure instanceOf CmdTry)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'try' to escape from." )
endClass

class CmdEscapeWhile : CmdControlReset
  METHODS
    method init( t )

    method clone->CmdEscapeWhile
      return CmdEscapeWhile( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeWhile" )

    method resolve->Cmd
      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure instanceOf CmdWhile)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing 'while' to escape from." )
endClass

class CmdNextIteration : CmdControlReset
  METHODS
    method init( t )

    method clone->CmdNextIteration
      return CmdNextIteration( t )

    method print( buffer:StringBuilder )
      buffer.print( "escapeNextIteration" )

    method resolve->Cmd
      forEach (control_structure in Analyzer.context.control_structure_stack.reverse_order)
        if (control_structure instanceOf CmdIterationControlStructure)
          target_id = control_structure.control_id
          control_structure.control_id_used_in_nested_code = true
          return this
        endIf
      endForEach

      throw t.error( "No enclosing iterator to escape from." )
endClass

class CmdStatementWithOperand : CmdStatement
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method type->Type
      return null

    method resolve->Cmd
      operand = operand.resolve.require_value
      return this
endClass

class CmdTrace : CmdStatement
  PROPERTIES
    method_context : Method
    labels         = String[]
    expressions    = Cmd[]
    command        : Cmd

  METHODS
    method clone->CmdTrace
      local result = CmdTrace( t )
      result.labels = labels.clone
      result.expressions = expressions.clone
      result.command = clone(command)
      return result

    method resolve->Cmd
      if (command?) return this

      #command = CmdLiteralString( t, "[$ line $, $::$]  " (File(t.filepath).filename,t.line,method_context.type_context,method_context.signature) )
      command = CmdLiteralString( t, "[" + File(t.filepath).filename + " line " + t.line + ", " + method_context.type_context.name + "::" + method_context.signature )

      forEach (i in expressions.indices)
        local expression = expressions[i].resolve.require_value
        if (expression instanceOf CmdLiteralString)
          command = CmdAdd( t, command, expression )
        else
          command = CmdAdd( t, command, CmdLiteralString(t,labels[i]+":") )
          command = CmdAdd( t, command, expression )
        endIf
      endForEach

      return CmdAccess( t, CmdReadSingleton(t,Types.type_Global), "println", CmdArgs(command) ).resolve
endClass

class CmdThrowMissingReturn : CmdStatement
  METHODS
    method clone->CmdThrowMissingReturn
      return CmdThrowMissingReturn( t )

    method print( buffer:StringBuilder )
      buffer.print( "throw MissingReturnError()" )
endClass

class CmdTron : CmdStatement
  METHODS
    method clone->CmdTron
      return CmdTron( t )

    method print( buffer:StringBuilder )
      buffer.print( "tron" )
endClass

class CmdTroff : CmdStatement
  METHODS
    method clone->CmdTroff
      return CmdTroff( t )

    method print( buffer:StringBuilder )
      buffer.print( "troff" )
endClass

class CmdReturn : CmdStatement
    method clone->CmdReturn
      return CmdReturn( t )
endClass

class CmdReturnNil : CmdReturn
  METHODS
    method clone->CmdReturnNil
      return CmdReturnNil( t )

    method print( buffer:StringBuilder )
      buffer.print( "return" )

    method resolve->Cmd
      if (Analyzer.context.this_method.name == "init")
        return CmdReturnThis( t, Analyzer.context.this_method.type_context ).resolve
      endIf
      return this
endClass

class CmdReturnNull : CmdReturn
  METHODS
    method clone->CmdReturnNull
      return CmdReturnNull( t )

    method print( buffer:StringBuilder )
      buffer.print( "return null" )

    method resolve->Cmd
      local return_type = Analyzer.context.this_method.return_type
      if (return_type is null)
        throw t.error( "Method is not declared as returning a value." )
      endIf
      #if (not return_type.possibly_null) throw t.error( "Non-null return value required." )
      return this

endClass

class CmdReturnThis : CmdReturn
  PROPERTIES
    return_type : Type

  METHODS
    method init( t, return_type )

    method clone->CmdReturnThis
      return CmdReturnThis( t, return_type )

    method print( buffer:StringBuilder )
      buffer.print( "return this" )

    method resolve->Cmd
      return_type.resolve(t)
      if (Analyzer.context.this_method.return_type is null)
        throw t.error( "Method is not declared as returning a value." )
      endIf
      return this

endClass

class CmdReturnValue : CmdReturn
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method clone->CmdReturnValue
      return CmdReturnValue( t, clone(operand) )

    method type->Type
      return null

    method print( buffer:StringBuilder )
      buffer.print( "return " )
      operand.print( buffer )

    method resolve->Cmd
      operand = operand.resolve.require_value
      local return_type = Analyzer.context.this_method.return_type
      if (return_type is null)
        throw t.error( "Method is not declared as returning a value." )
      endIf
      operand.require_value

      return_type.resolve
      operand.type.resolve

      #operand.require_value( return_type.possibly_null )
      operand = operand.cast_to( t, Analyzer.context.this_method.return_type ).resolve
      return this

endClass

class CmdCast : CmdUnary
  METHODS
    method is_complex_reference->Logical
      return true

endClass

class CmdImplicitCastToType : CmdCast
  # In Bard terminology a 'cast' can be either a conversion or a coercion.
  # Operations such as variable assignments and method calls convert their
  # operands and arguments to a specific target type using an 'implicit cast'
  # that resolves to either a conversion, a coercion, or an error.
  #
  # IMPLICIT CAST MECHANISMS USED
  #
  # SRC TYPE  | TARGET TYPE
  #           | Object       Reference    Primitive    Compound
  # Object    | N/A          to->:Type    to->:Type    to->Type
  # Reference | Generalize   Generalize/E ERROR        ERROR
  # Primitive | Box          ERROR        Convert      ERROR
  # Compound  | Box          ERROR        ERROR        ERROR
  #
  PROPERTIES
    to_type : Type

  METHODS
    method init( t, operand, to_type )

    method clone->CmdImplicitCastToType
      return CmdImplicitCastToType( t, clone(operand), to_type )

    method type->Type
      return to_type

    method implicit_type->Type
      return to_type

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( " castTo " )
      buffer.print( to_type )

    method resolve->Cmd
      to_type.resolve(t)

      operand = operand.resolve_with_type_hint(to_type).require_value
      local from_type = operand.type

      if (from_type is to_type) return operand

      if (from_type.is_primitive and to_type.is_primitive)
        return CmdConvertToType( t, operand, to_type ).resolve
      endIf

      if (from_type is Types.type_Object)
        return CmdAccess( t, operand, "to_"+to_type, null ).cast_to(t,to_type).resolve

      elseIf (from_type.is_reference)
        if (to_type.is_reference)
          if (from_type.instance_of( to_type)) return CmdGeneralizeReference( t, operand,  to_type).resolve
          else throw t.error( "Type " + from_type.name + " cannot be implicitly cast to type " + to_type.name + ".  Explicitly convert obj->" + to_type.name + " or recast (obj as " + to_type.name + ")." )

          #else throw t.error( "Type $ cannot be implicitly cast to type $.  Explicitly convert obj->$ or recast (obj as $)." (from_type,to_type,to_type,to_type) )
        else
          #throw t.error( "Type $ cannot be implicitly cast to type $.  Explicit obj->$ conversion required." (from_type,to_type,to_type) )
          throw t.error( "Type " + from_type.name + " cannot be implicitly cast to type " + to_type.name + ".  Explicit obj->" + to_type.name + " conversion required." )
        endIf

      elseIf (from_type.is_primitive)
        #println( "From $ to $" (from_type,to_type))
        #println( System.stack_trace )
        if (to_type is Types.type_Object)
          throw t.error( "TODO: box primitive as Object (1)." )
        else
          #throw t.error( "Type $ cannot be implicitly cast to type $.  Explicit obj->$ conversion required." (from_type,to_type,to_type) )
          throw t.error( "Type " + from_type.name + " cannot be implicitly cast to type " + to_type.name + ".  Explicit obj->" + to_type.name + " conversion required." )
        endIf

      else
        # from_type is compound
        if (to_type is Types.type_Object)
          #println( "OPERAND:" + operand )
          throw Error("TODO")
          #return CmdImplicitCastToType( t, CmdNewObject(t, Types.reference(t,"Boxed<<$>>"(from_type.name)), CmdArgs(operand)), to_type ).resolve
        else
          #throw t.error( "Type $ cannot be implicitly cast to type $.  Explicit obj->$ conversion required." (from_type,to_type,to_type) )
          throw t.error( "Type " + from_type.name + " cannot be implicitly cast to type " + to_type.name + ".  Explicit obj->" + to_type.name + " conversion required." )
        endIf

      endIf

      throw t.error( "Unhandled cast: " + from_type.name + "->" + to_type.name )
endClass

class CmdConvertToType : CmdCast
  PROPERTIES
    to_type : Type

  METHODS
    method init( t, operand, to_type )

    method clone->CmdConvertToType
      return CmdConvertToType( t, clone(operand), to_type )

    method type->Type
      return to_type

    method implicit_type->Type
      return to_type

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->" )
      buffer.print( to_type )

    method resolve->Cmd
      to_type.resolve(t)

      operand = operand.resolve_with_type_hint(to_type).require_value
      local from_type = operand.type
      if (from_type is to_type) return operand

      #{
      if (from_type.def is to_type.def)
        #if (to_type.possibly_null) return CmdGeneralizeReference( t, operand, to_type )
        throw t.error( "Cannot cast a possibly null reference to a non-null reference type." )
      endIf
      }#

      #{
      if (from_type.is_primitive and to_type.is_reference)
        if (to_type.def is Types.type_IntegerObject or to_type.is_Object)
          return CmdAccess( t, "IntegerObject", CmdArgs(operand) ).resolve
        endIf
      endIf
      }#

      if (from_type.is_primitive and to_type.is_primitive)
        if (to_type.is_Real)
          if (from_type.is_Integer) return CmdConvertIntegerToReal( t, operand ).resolve
        elseIf (to_type.is_Integer)
          if     (from_type.is_Real)      return CmdConvertRealToInteger( t, operand ).resolve
          elseIf (from_type.is_Character) return CmdConvertCharacterToInteger( t, operand ).resolve
          elseIf (from_type.is_Byte)      return CmdConvertByteToInteger( t, operand ).resolve
          elseIf (from_type.is_Logical)   return CmdConvertLogicalToInteger( t, operand ).resolve
        elseIf (to_type.is_Character)
          if     (from_type.is_Integer)   return CmdConvertIntegerToCharacter( t, operand ).resolve
          else                            return operand.cast_to(t,Types.type_Integer).cast_to(t,Types.type_Character).resolve
        elseIf (to_type.is_Byte)
          if     (from_type.is_Integer)   return CmdConvertIntegerToByte( t, operand ).resolve
          else                            return operand.cast_to(t,Types.type_Integer).cast_to(t,Types.type_Byte).resolve
        endIf

      else
        # "obj->Type" -> "obj.to()->Type"
        local cmd = Analyzer.resolve_call( t, null, operand, "to_"+to_type, null, false )
        if (cmd?) return cmd

        #throw t.error( //:Type$ does not define conversion "method to->$".// (from_type,to_type) )
        throw t.error( //Type // + from_type.name + // does not define conversion "method to->// + to_type.name + //".// )
      endIf
endClass

class CmdRecastAsType : CmdCast
  PROPERTIES
    as_type : Type

  METHODS
    method init( t, operand, as_type )

    method clone->CmdRecastAsType
      return CmdRecastAsType( t, clone(operand), as_type )

    method type->Type
      return as_type

    method implicit_type->Type
      return as_type

    method print( buffer:StringBuilder )
      buffer.print( '(' )
      operand.print( buffer )
      buffer.print( " as " )
      buffer.print( as_type )
      buffer.print( ')' )

    method resolve->Cmd
      as_type.resolve(t)

      operand = operand.resolve_with_type_hint(as_type).require_value
      local from_type = operand.type
      if (from_type is as_type) return operand

      if (from_type.is_reference and as_type.is_reference)
        if (from_type.instance_of( as_type)) return CmdGeneralizeReference( t, operand,  as_type)
        else                                 return CmdSpecializeReference( t, operand,  as_type)
      endIf

      if (from_type.is_reference and not as_type.is_reference)
        #throw t.error( //Cannot recast a reference to a non-reference type.  You can write "ref->$" to call the to->$()() conversion method of the reference.// (as_type,as_type)  )
        throw t.error( //Cannot recast a reference to a non-reference type.  You can write "ref->// + as_type.name + //" to call the to->// + as_type.name + //()() conversion method of the reference.// )
      endIf

      if (not from_type.is_reference and as_type.is_reference)
        #throw t.error( //Cannot recast a value type to a reference type.  You can write "value->$" to call "$.create_from(value)" (compiler's first choice) or "$.to(value)->$()()" (compiler's second choice).// (as_type,as_type,from_type,as_type) )
        throw t.error( //Cannot recast a value type to a reference type.  You can write "value->// + as_type.name + //" to call "// + as_type.name + //.create_from(value)" (compiler's first choice) or "// + from_type.name + //.to(value)->// + as_type.name + //()()" (compiler's second choice).// )
      endIf

      #{
      if (as_type.is_Real)
        #if (from_type.is_Integer) return CmdConvertIntegerToReal( t, operand ).resolve
      elseIf (as_type.is_Integer)
        #if     (from_type.is_Real)      return CmdConvertRealToInteger( t, operand ).resolve
        if (from_type.is_Character) return CmdCharacterAsInteger( t, operand, as_type ).resolve
        #elseIf (from_type.is_Logical)   return CmdConvertLogicalToInteger( t, operand ).resolve
      elseIf (as_type.is_Character)
        #if     (from_type.is_Real)      return CmdConvertRealToInteger( t, operand ).resolve
        if (from_type.is_Integer)   return CmdIntegerAsCharacter( t, operand, as_type ).resolve
        #elseIf (from_type.is_Logical)   return CmdConvertLogicalToInteger( t, operand ).resolve
      endIf
      }#

      throw t.error( "Unhandled recast: " + from_type.name + " as " + as_type.name )
endClass

#{
class CmdCharacterAsInteger : CmdRecastAsType
  METHODS
    method resolve->Cmd
      operand = operand.resolve.require_value
      local literal_operand = operand as CmdLiteralCharacter
      if (literal_operand?)
        return CmdLiteralInteger( t, Integer(literal_operand.value) )
      endIf
      return this
endClass

class CmdIntegerAsCharacter : CmdRecastAsType
  METHODS
    method resolve->Cmd
      operand = operand.resolve.require_value
      local literal_operand = operand as CmdLiteralInteger
      if (literal_operand?)
        return CmdLiteralCharacter( t, literal_operand.value->Character )
      endIf
      return this
endClass
}#

class CmdGeneralizeReference : CmdRecastAsType
  METHODS
    method clone->CmdGeneralizeReference
      return CmdGeneralizeReference( t, clone(operand), as_type )

    method resolve->Cmd
      operand = operand.resolve.require_value
      return this

endClass

class CmdSpecializeReference : CmdRecastAsType
  METHODS
    method clone->CmdSpecializeReference
      return CmdSpecializeReference( t, clone(operand), as_type )

    method resolve->Cmd
      operand = operand.resolve.require_value
      return this

endClass

class CmdConvertIntegerToReal : CmdCast
  METHODS
    method type->Type
      return Types.type_Real

    method clone->CmdConvertIntegerToReal
      return CmdConvertIntegerToReal( t, clone(operand) )

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Real" )

    method resolve->Cmd
      operand = operand.resolve.require_value
      if (operand instanceOf CmdLiteral) return CmdLiteralReal( t, (operand as CmdLiteralInteger).value )
      return this

endClass

class CmdConvertRealToInteger : CmdCast
  METHODS
    method clone->CmdConvertRealToInteger
      return CmdConvertRealToInteger( t, clone(operand) )

    method type->Type
      return Types.type_Integer

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Integer" )

    method resolve->Cmd
      operand = operand.resolve.require_value
      if (operand instanceOf CmdLiteral) return CmdLiteralInteger( t, (operand as CmdLiteralReal).value )
      return this

endClass

class CmdConvertCharacterToInteger : CmdCast
  METHODS
    method clone->CmdConvertCharacterToInteger
      return CmdConvertCharacterToInteger( t, clone(operand) )

    method type->Type
      return Types.type_Integer

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Integer" )

    method resolve->Cmd
      operand = operand.resolve.require_value
      local character_operand = (operand as CmdLiteralCharacter)
      if (character_operand?)
        return CmdLiteralInteger( t, character_operand.value->Integer )
      endIf
      return this

endClass

class CmdConvertByteToInteger : CmdCast
  METHODS
    method clone->CmdConvertByteToInteger
      return CmdConvertByteToInteger( t, clone(operand) )

    method type->Type
      return Types.type_Integer

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Integer" )

    method resolve->Cmd
      operand = operand.resolve.require_value
      local byte_operand = (operand as CmdLiteralByte)
      if (byte_operand?)
        return CmdLiteralInteger( t, byte_operand.value->Integer )
      endIf
      return this

endClass

class CmdConvertIntegerToCharacter : CmdCast
  METHODS
    method clone->CmdConvertIntegerToCharacter
      return CmdConvertIntegerToCharacter( t, clone(operand) )

    method type->Type
      return Types.type_Character

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Character" )

    method resolve->Cmd
      operand = operand.resolve.require_value
      local integer_operand = (operand as CmdLiteralInteger)
      if (integer_operand?)
        return CmdLiteralCharacter( t, integer_operand.value->Character )
      endIf
      return this

endClass

class CmdConvertIntegerToByte : CmdCast
  METHODS
    method clone->CmdConvertIntegerToByte
      return CmdConvertIntegerToByte( t, clone(operand) )

    method type->Type
      return Types.type_Byte

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Byte" )

    method resolve->Cmd
      operand = operand.resolve.require_value
      local integer_operand = (operand as CmdLiteralInteger)
      if (integer_operand?)
        return CmdLiteralByte( t, integer_operand.value & 255 )
      endIf
      return this

endClass

class CmdConvertLogicalToInteger : CmdCast
  METHODS
    method clone->CmdConvertLogicalToInteger
      return CmdConvertLogicalToInteger( t, clone(operand) )

    method type->Type
      return Types.type_Integer

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( "->Integer" )

    method resolve->Cmd
      operand = operand.resolve.require_value
      if (operand instanceOf CmdLiteral)
        local value = 0
        if ((operand as CmdLiteralLogical).value) value = 1
        return CmdLiteralInteger( t, value )
      endIf
      return this

endClass

class CmdTypeManipulation : Cmd
  PROPERTIES
    operand : Cmd
    target_type : Type

  METHODS
    method init( t, operand, target_type )

    method is_complex_reference->Logical
      return true

    method resolve->Cmd
      target_type.resolve(t)
      return this

endClass

class CmdInstanceOf : CmdTypeManipulation
  METHODS
    method clone->CmdInstanceOf
      return CmdInstanceOf( t, clone(operand), target_type )

    method type->Type
      return Types.type_Logical

    method implicit_type->Type
      return Types.type_Logical

    method print( buffer:StringBuilder )
      buffer.print( '(' )
      operand.print( buffer )
      buffer.print( " instanceOf " )
      buffer.print( target_type )
      buffer.print( ')' )

    method resolve->Cmd
      operand = operand.resolve.require_value
      local operand_type = operand.type

      if (operand_type.instance_of(target_type)) return CmdLiteralLogical( t, true )

      if (operand_type.is_primitive) return CmdLiteralLogical( t, false )

      if (target_type.is_primitive)
        return CmdLiteralLogical( t, false )
      endIf

      return this

endClass


class CmdBinary : Cmd
  PROPERTIES
    lhs     : Cmd
    rhs     : Cmd
    opcode = -1 : Integer

  METHODS
    method init( t, lhs, rhs )

    method implicit_type->Type
      local lhs_type = lhs.implicit_type
      local rhs_type = rhs.implicit_type
      if (lhs_type is null or rhs_type is null) return null
      return common_type( lhs, rhs )

    method is_complex_reference->Logical
      return true

    method type->Type
      return lhs.type

    method name->String
      return "[unnamed binary op]"

    method print( buffer:StringBuilder )
      buffer.print( '(' )
      lhs.print( buffer )
      buffer.print( ' ' )
      buffer.print( name )
      buffer.print( ' ' )
      rhs.print( buffer )
      buffer.print( ')' )

    method resolve->Cmd
      lhs = lhs.resolve.require_value
      rhs = rhs.resolve.require_value
      local lhs_type = lhs.type
      local rhs_type = rhs.type

      return resolve_for_operand_types( lhs_type, rhs_type )

    method resolve_for_operand_types( lhs_type:Type, rhs_type:Type )->Cmd
      local result:Cmd

      if (lhs_type.is_reference) result = resolve_with_lhs_reference
      if (result?) return result

      if (rhs_type.is_reference) result = resolve_with_rhs_reference
      if (result?) return result

      if (lhs_type.is_compound)  result = resolve_with_lhs_reference
      if (result?) return result

      if (rhs_type.is_compound)  result = resolve_with_rhs_reference
      if (result?) return result

      local common_type = common_type( lhs, rhs )
      cast_to_common_type( common_type )
      return resolve_for_common_type( common_type )

    method resolve_with_lhs_reference->Cmd
      return null

    method resolve_with_rhs_reference->Cmd
      return null

    method resolve_for_common_type( common_type:Type )->Cmd
      if (common_type is null) common_type = common_type( lhs, rhs )

      if (lhs instanceOf CmdLiteral and rhs instanceOf CmdLiteral)
        if (common_type.is_Real)
          local result = combine_literal_Real_operands( (lhs as CmdLiteralReal).value, (rhs as CmdLiteralReal).value )
          if (result?) return result
        elseIf (common_type.is_Integer)
          local result = combine_literal_Integer_operands( (lhs as CmdLiteralInteger).value, (rhs as CmdLiteralInteger).value )
          if (result?) return result
        elseIf (common_type.is_Logical)
          local result = combine_literal_Logical_operands( (lhs as CmdLiteralLogical).value, (rhs as CmdLiteralLogical).value )
          if (result?) return result
        else
          local result = combine_literal_operands( common_type )
          if (result?) return result
        endIf
      endIf

      return this

    method cast_to_common_type( common_type:Type )
      lhs = lhs.cast_to( lhs.t, common_type ).resolve
      rhs = rhs.cast_to( rhs.t, common_type ).resolve

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return null

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return null

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return null

    method combine_literal_operands( common_type:Type )->Cmd
      return null

endClass

class CmdOpAssign : CmdAssign
  PROPERTIES
    operation : Integer

  METHODS
    method init( t, operand, new_value, operation )

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( ' ' )
      buffer.print( Token.name_of(operation) )
      buffer.print( ' ' )
      new_value.print( buffer )

    method resolve->Cmd
      return operand.resolve_assignment( new_value, operation )

endClass

class CmdOpAssignLocal : CmdWriteLocal
  METHODS
    method name->String
      return "?"

    method print( buffer:StringBuilder )
      buffer.print( local_info.name )
      buffer.print( ' ' )
      buffer.print( name )
      buffer.print( ' ' )
      new_value.print( buffer )

endClass

class CmdAddAssignLocal : CmdOpAssignLocal
  METHODS
    method clone->CmdAddAssignLocal
      return CmdAddAssignLocal( t, local_info, clone(new_value) )

    method name->String
      return "+="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignLocal( t, local_info, "operator+=", new_value ).resolve

endClass

class CmdSubtractAssignLocal : CmdOpAssignLocal
  METHODS
    method clone->CmdSubtractAssignLocal
      return CmdSubtractAssignLocal( t, local_info, clone(new_value) )

    method name->String
      return "-="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignLocal( t, local_info, "operator-=", new_value ).resolve
endClass

class CmdMultiplyAssignLocal : CmdOpAssignLocal
  METHODS
    method clone->CmdMultiplyAssignLocal
      return CmdMultiplyAssignLocal( t, local_info, clone(new_value) )

    method name->String
      return "*="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignLocal( t, local_info, "operator*=", new_value ).resolve
endClass

class CmdDivideAssignLocal : CmdOpAssignLocal
  METHODS
    method clone->CmdDivideAssignLocal
      return CmdDivideAssignLocal( t, local_info, clone(new_value) )

    method name->String
      return "/="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignLocal( t, local_info, "operator/=", new_value ).resolve
endClass

class CmdModAssignLocal : CmdOpAssignLocal
  METHODS
    method clone->CmdModAssignLocal
      return CmdModAssignLocal( t, local_info, clone(new_value) )

    method name->String
      return "%="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignLocal( t, local_info, "operator%=", new_value ).resolve
endClass

class CmdPowerAssignLocal : CmdOpAssignLocal
  METHODS
    method clone->CmdPowerAssignLocal
      return CmdPowerAssignLocal( t, local_info, clone(new_value) )

    method name->String
      return "^="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignLocal( t, local_info, "operator^=", new_value ).resolve
endClass

class CmdBitwiseAndAssignLocal : CmdOpAssignLocal
  METHODS
    method clone->CmdBitwiseAndAssignLocal
      return CmdBitwiseAndAssignLocal( t, local_info, clone(new_value) )

    method name->String
      return "&="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignLocal( t, local_info, "operator&=", new_value ).resolve
endClass

class CmdBitwiseOrAssignLocal : CmdOpAssignLocal
  METHODS
    method clone->CmdBitwiseOrAssignLocal
      return CmdBitwiseOrAssignLocal( t, local_info, clone(new_value) )

    method name->String
      return "|="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignLocal( t, local_info, "operator|=", new_value ).resolve
endClass

class CmdBitwiseXorAssignLocal : CmdOpAssignLocal
  METHODS
    method clone->CmdBitwiseXorAssignLocal
      return CmdBitwiseXorAssignLocal( t, local_info, clone(new_value) )

    method name->String
      return "~="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignLocal( t, local_info, "operator~=", new_value ).resolve
endClass

class CmdAccessAssignLocal : Cmd
  PROPERTIES
    local_info : Local
    access     : Cmd

  METHODS
    method init( t, local_info, name:String, new_value:Cmd)
      access = CmdAccess( t, CmdReadLocal(t,local_info), name, CmdArgs(new_value) ).resolve.require_value

    method resolve->Cmd
      return this
endClass


class CmdOpAssignProperty : CmdWriteProperty
  METHODS
    method name->String
      return "?"

    method is_op_assign->Logical
      return true

    method print( buffer:StringBuilder )
      buffer.print( property.name )
      buffer.print( ' ' )
      buffer.print( name )
      buffer.print( ' ' )
      new_value.print( buffer )

endClass

class CmdAddAssignProperty : CmdOpAssignProperty
  METHODS
    method clone->CmdAddAssignProperty
      return CmdAddAssignProperty( t, clone(context), property, clone(new_value) )

    method name->String
      return "+="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignProperty( t, context, property, "operator+=", new_value ).resolve
endClass

class CmdSubtractAssignProperty : CmdOpAssignProperty
  METHODS
    method clone->CmdSubtractAssignProperty
      return CmdSubtractAssignProperty( t, clone(context), property, clone(new_value) )

    method name->String
      return "-="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignProperty( t, context, property, "operator-=", new_value ).resolve
endClass

class CmdMultiplyAssignProperty : CmdOpAssignProperty
  METHODS
    method clone->CmdMultiplyAssignProperty
      return CmdMultiplyAssignProperty( t, clone(context), property, clone(new_value) )

    method name->String
      return "*="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignProperty( t, context, property, "operator*=", new_value ).resolve
endClass

class CmdDivideAssignProperty : CmdOpAssignProperty
  METHODS
    method clone->CmdDivideAssignProperty
      return CmdDivideAssignProperty( t, clone(context), property, clone(new_value) )

    method name->String
      return "/="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignProperty( t, context, property, "operator/=", new_value ).resolve
endClass

class CmdModAssignProperty : CmdOpAssignProperty
  METHODS
    method clone->CmdModAssignProperty
      return CmdModAssignProperty( t, clone(context), property, clone(new_value) )

    method name->String
      return "%="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignProperty( t, context, property, "operator%=", new_value ).resolve
endClass

class CmdPowerAssignProperty : CmdOpAssignProperty
  METHODS
    method clone->CmdPowerAssignProperty
      return CmdPowerAssignProperty( t, clone(context), property, clone(new_value) )

    method name->String
      return "^="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignProperty( t, context, property, "operator^=", new_value ).resolve
endClass

class CmdBitwiseAndAssignProperty : CmdOpAssignProperty
  METHODS
    method clone->CmdBitwiseAndAssignProperty
      return CmdBitwiseAndAssignProperty( t, clone(context), property, clone(new_value) )

    method name->String
      return "&="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignProperty( t, context, property, "operator&=", new_value ).resolve
endClass

class CmdBitwiseOrAssignProperty : CmdOpAssignProperty
  METHODS
    method clone->CmdBitwiseOrAssignProperty
      return CmdBitwiseOrAssignProperty( t, clone(context), property, clone(new_value) )

    method name->String
      return "|="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignProperty( t, context, property, "operator|=", new_value ).resolve
endClass

class CmdBitwiseXorAssignProperty : CmdOpAssignProperty
  METHODS
    method clone->CmdBitwiseXorAssignProperty
      return CmdBitwiseXorAssignProperty( t, clone(context), property, clone(new_value) )

    method name->String
      return "~="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignProperty( t, context, property, "operator~=", new_value ).resolve
endClass

class CmdAccessAssignProperty : CmdStatement
  PROPERTIES
    property  : Property
    context   : Cmd
    name      : String
    new_value : Cmd

  METHODS
    method init( t, context, property, name, new_value )

    method resolve->Cmd
      if (context?) 
        context = context.resolve.require_value
        local temp_name = "temp_" + property.name + "_" + Analyzer.unique_id
        local temp_info = Local( t, temp_name, context.type )
        local statements = CmdStatementList()
        statements.add( CmdWriteLocal( t, temp_info, context ) )
        local cmd_read_and_access = CmdAccess( t, CmdReadProperty(t,CmdReadLocal(t,temp_info),property), name, CmdArgs(new_value) )
        local cmd_assign = CmdWriteProperty( t, CmdReadLocal(t,temp_info), property, cmd_read_and_access )
        statements.add( cmd_assign )
        return CmdAnonymousBlock( t, statements ).resolve
      else
        return CmdWriteProperty( t, null, property, CmdAccess( t, CmdReadProperty(t,context,property), name, CmdArgs(new_value) ) ).resolve
      endIf
endClass


class CmdOpAssignSetting : CmdWriteSetting
  METHODS
    method name->String
      return "?"

    method print( buffer:StringBuilder )
      buffer.print( setting.name )
      buffer.print( ' ' )
      buffer.print( name )
      buffer.print( ' ' )
      new_value.print( buffer )
endClass

class CmdAddAssignSetting : CmdOpAssignSetting
  METHODS
    method clone->CmdAddAssignSetting
      return CmdAddAssignSetting( t, clone(context), setting, clone(new_value) )

    method name->String
      return "+="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignSetting( t, context, setting, "operator+=", new_value ).resolve
endClass

class CmdSubtractAssignSetting : CmdOpAssignSetting
  METHODS
    method clone->CmdSubtractAssignSetting
      return CmdSubtractAssignSetting( t, clone(context), setting, clone(new_value) )

    method name->String
      return "-="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignSetting( t, context, setting, "operator-=", new_value ).resolve
endClass

class CmdMultiplyAssignSetting : CmdOpAssignSetting
  METHODS
    method clone->CmdMultiplyAssignSetting
      return CmdMultiplyAssignSetting( t, clone(context), setting, clone(new_value) )

    method name->String
      return "*="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignSetting( t, context, setting, "operator*=", new_value ).resolve
endClass

class CmdDivideAssignSetting : CmdOpAssignSetting
  METHODS
    method clone->CmdDivideAssignSetting
      return CmdDivideAssignSetting( t, clone(context), setting, clone(new_value) )

    method name->String
      return "/="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignSetting( t, context, setting, "operator/=", new_value ).resolve
endClass

class CmdModAssignSetting : CmdOpAssignSetting
  METHODS
    method clone->CmdModAssignSetting
      return CmdModAssignSetting( t, clone(context), setting, clone(new_value) )

    method name->String
      return "%="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignSetting( t, context, setting, "operator%=", new_value ).resolve
endClass

class CmdPowerAssignSetting : CmdOpAssignSetting
  METHODS
    method clone->CmdPowerAssignSetting
      return CmdPowerAssignSetting( t, clone(context), setting, clone(new_value) )

    method name->String
      return "^="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignSetting( t, context, setting, "operator^=", new_value ).resolve
endClass

class CmdBitwiseAndAssignSetting : CmdOpAssignSetting
  METHODS
    method clone->CmdBitwiseAndAssignSetting
      return CmdBitwiseAndAssignSetting( t, clone(context), setting, clone(new_value) )

    method name->String
      return "&="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignSetting( t, context, setting, "operator&=", new_value ).resolve
endClass

class CmdBitwiseOrAssignSetting : CmdOpAssignSetting
  METHODS
    method clone->CmdBitwiseOrAssignSetting
      return CmdBitwiseOrAssignSetting( t, clone(context), setting, clone(new_value) )

    method name->String
      return "|="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignSetting( t, context, setting, "operator|=", new_value ).resolve
endClass

class CmdBitwiseXorAssignSetting : CmdOpAssignSetting
  METHODS
    method clone->CmdBitwiseXorAssignSetting
      return CmdBitwiseXorAssignSetting( t, clone(context), setting, clone(new_value) )

    method name->String
      return "~="

    method resolve_reference_assignment->Cmd
      return CmdAccessAssignSetting( t, context, setting, "operator~=", new_value ).resolve
endClass

class CmdAccessAssignSetting : CmdStatement
  PROPERTIES
    setting  : Property
    access   : Cmd

  METHODS
    method init( t, context:Cmd, setting, name:String, new_value:Cmd)
      access = CmdAccess( t, CmdReadSetting(t,context,setting), name, CmdArgs(new_value) ).resolve.require_value

    method resolve->Cmd
      return this
endClass


class CmdConcatenateStrings : CmdBinary
  PROPERTIES
    builder : Cmd
    # visited in Visitor::visit(CmdConcatenateStrings)

  METHODS
    method clone->CmdConcatenateStrings
      local result = CmdConcatenateStrings( t, clone(lhs), clone(rhs) )
      result.builder = clone( builder )
      return result

    method name->String
      return "+"

    method type->Type
      return Types.type_String

    method resolve->Cmd
      if (lhs.type.is_compound) lhs = CmdAccess( t, lhs, "to_String", null ).cast_to(t,Types.type_String).resolve
      if (rhs.type.is_compound) rhs = CmdAccess( t, rhs, "to_String", null ).cast_to(t,Types.type_String).resolve

      if (lhs instanceOf CmdConcatenateStrings)
        builder = CmdAccess( t, (lhs as CmdConcatenateStrings).builder, "print", CmdArgs(rhs) ).resolve
      else
        builder = CmdNewObject( t, Types.type_StringBuilder )
        builder = CmdAccess( t, builder, "print", CmdArgs(lhs) )
        builder = CmdAccess( t, builder, "print", CmdArgs(rhs) )
        builder = CmdAccess( t, builder, "to_String", null ).cast_to(t,Types.type_String)
        builder = builder.resolve
      endIf
      return this
endClass

class CmdAdd : CmdBinary
  METHODS
    method clone->CmdAdd
      return CmdAdd( t, clone(lhs), clone(rhs) )

    method name->String
      return "+"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value + rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value + rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value or rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        local lhs_value = (lhs as CmdLiteralCharacter).value
        local rhs_value = (rhs as CmdLiteralCharacter).value
        return CmdLiteralString( t, StringBuilder().print(lhs_value).print(rhs_value)->String )

      elseIf (common_type.is_String)
        return CmdLiteralString( t, (lhs as CmdLiteralString).value + (rhs as CmdLiteralString).value )

      else
        return null
      endIf

    method resolve->Cmd
      lhs = lhs.resolve.require_value
      rhs = rhs.resolve.require_value

      local lhs_type = lhs.type
      local rhs_type = rhs.type

      if (lhs instanceOf CmdLiteral and rhs instanceOf CmdLiteral)
        local lhs_is_string = lhs_type.instance_of(Types.type_String)
        local rhs_is_string = rhs_type.instance_of(Types.type_String)
        if (lhs_is_string or rhs_is_string)
          return CmdLiteralString( t, lhs->String + rhs->String )
        else
          return prior.resolve
        endIf
      endIf

      if (lhs_type.instance_of(Types.type_String) or rhs_type.instance_of(Types.type_String))
        return CmdConcatenateStrings( t, lhs, rhs ).resolve
      else
        return prior.resolve
      endIf

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator+", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator+", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdSubtract : CmdBinary
  METHODS
    method clone->CmdSubtract
      return CmdSubtract( t, clone(lhs), clone(rhs) )

    method name->String
      return "-"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value - rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value - rhs_value )

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator-", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator-", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdMultiply : CmdBinary
  METHODS
    method clone->CmdMultiply
      return CmdMultiply( t, clone(lhs), clone(rhs) )

    method name->String
      return "*"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value * rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value * rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value and rhs_value )

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator*", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator*", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdDivide : CmdBinary
  METHODS
    method clone->CmdDivide
      return CmdDivide( t, clone(lhs), clone(rhs) )

    method name->String
      return "/"

    method implicit_type->Type
      local lhs_type = lhs.implicit_type
      local rhs_type = rhs.implicit_type
      if (lhs_type is null or rhs_type is null) return null
      local result = common_type( lhs, rhs )
      if (result.is_Integer) return Types.type_Real
      return result

    method common_type( lhs:Cmd, rhs:Cmd )->Type
      local ctype = prior.common_type( lhs, rhs )
      if (ctype.is_Integer or ctype.is_Character) return Types.type_Real
      return ctype

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value / rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralReal( t, lhs_value->Real / rhs_value->Real )

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator/", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator/", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdMod : CmdBinary
  METHODS
    method name->String
      return "%"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value % rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value % rhs_value )

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator%", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator%", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdPower : CmdBinary
  METHODS
    method clone->CmdPower
      return CmdPower( t, clone(lhs), clone(rhs) )

    method name->String
      return "^"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralReal( t, lhs_value ^ rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value ^ rhs_value )

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator^", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator^", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdBitwiseAnd : CmdBinary
  METHODS
    method clone->CmdBitwiseAnd
      return CmdBitwiseAnd( t, clone(lhs), clone(rhs) )

    method name->String
      return "&"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value & rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value and rhs_value )

    method resolve_for_Logical_operands->Cmd
      opcode = Op.bitwise_and_integer
      return this

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator&", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator&", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdBitwiseOr : CmdBinary
  METHODS
    method clone->CmdBitwiseOr
      return CmdBitwiseOr( t, clone(lhs), clone(rhs) )

    method name->String
      return "|"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value | rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value or rhs_value )

    method resolve_for_Logical_operands->Cmd
      opcode = Op.bitwise_or_integer
      return this

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator|", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator|", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdBitwiseXor : CmdBinary
  METHODS
    method clone->CmdBitwiseXor
      return CmdBitwiseXor( t, clone(lhs), clone(rhs) )

    method name->String
      return "~"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value ~ rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, (lhs_value and not rhs_value) or (not lhs_value and rhs_value) )

    method resolve_for_Logical_operands->Cmd
      opcode = Op.bitwise_xor_integer
      return this

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator~", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator~", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdBitwiseSHL : CmdBinary
  METHODS
    method clone->CmdBitwiseSHL
      return CmdBitwiseSHL( t, clone(lhs), clone(rhs) )

    method name->String
      return ":<<:"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value :<<: rhs_value )

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,lhs.type), "operator:<<:", CmdArgs(lhs,rhs) ).resolve.require_value

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, CmdReadSingleton(t,rhs.type), "operator:<<:", CmdArgs(lhs,rhs) ).resolve.require_value
endClass

class CmdBitwiseSHR : CmdBinary
  METHODS
    method clone->CmdBitwiseSHR
      return CmdBitwiseSHR( t, clone(lhs), clone(rhs) )

    method name->String
      return ":>>:"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value :>>: rhs_value )

endClass

class CmdBitwiseSHRX : CmdBinary
  METHODS
    method clone->CmdBitwiseSHRX
      return CmdBitwiseSHRX( t, clone(lhs), clone(rhs) )

    method name->String
      return ":>>>:"

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralInteger( t, lhs_value :>>>: rhs_value )

endClass

class CmdLogicalAnd : CmdBinary
  METHODS
    method init( t, lhs, rhs )

    method clone->CmdLogicalAnd
      return CmdLogicalAnd( t, clone(lhs), clone(rhs) )

    method name->String
      return "and"

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value and rhs_value )

    method resolve_for_Logical_operands->Cmd
      return this
endClass

class CmdLogicalOr : CmdBinary
  METHODS
    method clone->CmdLogicalOr
      return CmdLogicalOr( t, clone(lhs), clone(rhs) )

    method name->String
      return "or"

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value or rhs_value )

    method resolve_for_operand_types( lhs_type:Type, rhs_type:Type )->Cmd
      local common_type = common_type( lhs, rhs )

      if (common_type.is_reference)
        throw error( "TODO: || with reference types." )
        #{
        local lhs_type = lhs.type
        local rhs_type = rhs.type
        if (lhs_type.is_reference and rhs_type.is_reference)
          if (not lhs_type.possibly_null) return lhs
          #if (not rhs_type.possibly_null and common_type.possibly_null) common_type = common_type.checked_type
          return CmdEitherOr( t, lhs, rhs, common_type ).resolve
        endIf
        }#
      endIf

      cast_to_common_type( common_type )
      return resolve_for_common_type( common_type )

    method resolve_for_Logical_operands->Cmd
      return this

endClass

#{
class CmdEitherOr : CmdBinary
  PROPERTIES
    common_type : Type

  METHODS
    method init( t, lhs, rhs, common_type )

    method name->String
      return "or"

    method type->Type
      return common_type

    method resolve->Cmd
      # lhs and rhs have already been individually resolved
      if (lhs instanceOf CmdLiteralNull) return rhs
      if (rhs instanceOf CmdLiteralNull) return lhs
      return this

      #{
    method compile( writer:BCWriter )
      local label = writer.next_control_id + ""
      lhs.compile( writer )
      writer.write( Op.jump_if_not_null )
      writer.write_address( label )
      rhs.compile( writer )
      writer.define_label( label )
      }#
endClass
}#

class CmdLogicalXor : CmdBinary
  METHODS
    method clone->CmdLogicalXor
      return CmdLogicalXor( t, clone(lhs), clone(rhs) )

    method name->String
      return "xor"

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, (lhs_value and not rhs_value) or (not lhs_value and rhs_value) )

    method resolve_for_Logical_operands->Cmd
      opcode = Op.bitwise_xor_integer
      return this

    method resolve->Cmd
      lhs = lhs.resolve.require_logical
      rhs = rhs.resolve.require_logical
      return prior.resolve
endClass

class CmdComparison : CmdBinary
  METHODS
    method type->Type
      return Types.type_Logical

    method implicit_type->Type
      return Types.type_Logical

endClass

class CmdCompareEQ : CmdComparison
  METHODS
    method clone->CmdCompareEQ
      return CmdCompareEQ( t, clone(lhs), clone(rhs) )

    method name->String
      return "=="

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value == rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value == rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value == rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value == (rhs as CmdLiteralCharacter).value )

      elseIf (common_type.is_Byte)
        return CmdLiteralLogical( t, (lhs as CmdLiteralByte).value == (rhs as CmdLiteralByte).value )

      elseIf (common_type.is_String)
        return CmdLiteralLogical( t, (lhs as CmdLiteralString).value == (rhs as CmdLiteralString).value )

      else
        return null
      endIf

    method resolve_with_lhs_reference->Cmd
      return CmdAccess( t, lhs, "equals", CmdArgs(rhs) ).resolve.require_logical

    method resolve_with_rhs_reference->Cmd
      return CmdAccess( t, rhs, "equals", CmdArgs(lhs) ).resolve.require_logical

endClass

class CmdCompareIs : CmdComparison
  METHODS
    method clone->CmdCompareIs
      return CmdCompareIs( t, clone(lhs), clone(rhs) )

    method name->String
      return "is"

    method resolve->Cmd
      lhs = lhs.resolve
      rhs = rhs.resolve

      local lhs_type = lhs.type
      local rhs_type = rhs.type

      if (not lhs_type.is_reference or not rhs_type.is_reference)
        return CmdCompareEQ(t, lhs, rhs).resolve
      endIf

      if (lhs instanceOf CmdLiteralNull)
        if (rhs instanceOf CmdLiteralNull) return CmdLiteralLogical( t, true )
      endIf

      return this


    # method resolve_with_lhs_reference.Cmd
    #   return CmdAccess( t, lhs, "==", CmdArgs(rhs) ).resolve.require_logical

    # method resolve_with_rhs_reference.Cmd
    #   return null

endClass

class CmdCompareNE : CmdComparison
  METHODS
    method clone->CmdCompareNE
      return CmdCompareNE( t, clone(lhs), clone(rhs) )

    method name->String
      return "!="

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value != rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value != rhs_value )

    method combine_literal_Logical_operands( lhs_value:Logical, rhs_value:Logical )->Cmd
      return CmdLiteralLogical( t, lhs_value != rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value != (rhs as CmdLiteralCharacter).value )

      elseIf (common_type.is_String)
        return CmdLiteralLogical( t, (lhs as CmdLiteralString).value != (rhs as CmdLiteralString).value )

      else
        return null
      endIf

    method resolve_with_lhs_reference->Cmd
      return CmdNegate( t, CmdAccess(t, lhs, "equals", CmdArgs(rhs)).resolve.require_logical ).resolve

    method resolve_with_rhs_reference->Cmd
      return CmdNegate( t, CmdAccess(t, rhs, "equals", CmdArgs(lhs)).resolve.require_logical ).resolve

endClass

class CmdCompareIsNot : CmdComparison
  METHODS
    method clone->CmdCompareIsNot
      return CmdCompareIsNot( t, clone(lhs), clone(rhs) )

    method name->String
      return "isNot"

endClass

class CmdCompareLT : CmdComparison
  METHODS
    method clone->CmdCompareLT
      return CmdCompareLT( t, clone(lhs), clone(rhs) )

    method name->String
      return "<"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value < rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value < rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value < (rhs as CmdLiteralCharacter).value )
      endIf
      return null

    method resolve_with_lhs_reference->Cmd
      return CmdCompareLT( t, CmdAccess(t, lhs, "compare_to", CmdArgs(rhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

    method resolve_with_rhs_reference->Cmd
      return CmdCompareGT( t, CmdAccess(t, rhs, "compare_to", CmdArgs(lhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

endClass

class CmdCompareGT : CmdComparison
  METHODS
    method clone->CmdCompareGT
      return CmdCompareGT( t, clone(lhs), clone(rhs) )

    method name->String
      return ">"

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value > rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value > rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value > (rhs as CmdLiteralCharacter).value )
      endIf
      return null

    method resolve_with_lhs_reference->Cmd
      return CmdCompareGT( t, CmdAccess(t, lhs, "compare_to", CmdArgs(rhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

    method resolve_with_rhs_reference->Cmd
      return CmdCompareLT( t, CmdAccess(t, rhs, "compare_to", CmdArgs(lhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

endClass

class CmdCompareLE : CmdComparison
  METHODS
    method clone->CmdCompareLE
      return CmdCompareLE( t, clone(lhs), clone(rhs) )

    method name->String
      return "<="

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value <= rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value <= rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value <= (rhs as CmdLiteralCharacter).value )
      endIf
      return null

    method resolve_with_lhs_reference->Cmd
      return CmdCompareLE( t, CmdAccess(t, lhs, "compare_to", CmdArgs(rhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

    method resolve_with_rhs_reference->Cmd
      return CmdCompareGE( t, CmdAccess(t, rhs, "compare_to", CmdArgs(lhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

endClass

class CmdCompareGE : CmdComparison
  METHODS
    method clone->CmdCompareGE
      return CmdCompareGE( t, clone(lhs), clone(rhs) )

    method name->String
      return ">="

    method combine_literal_Real_operands( lhs_value:Real, rhs_value:Real )->Cmd
      return CmdLiteralLogical( t, lhs_value >= rhs_value )

    method combine_literal_Integer_operands( lhs_value:Integer, rhs_value:Integer )->Cmd
      return CmdLiteralLogical( t, lhs_value >= rhs_value )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type.is_Character)
        return CmdLiteralLogical( t, (lhs as CmdLiteralCharacter).value >= (rhs as CmdLiteralCharacter).value )
      endIf
      return null

    method resolve_with_lhs_reference->Cmd
      return CmdCompareGE( t, CmdAccess(t, lhs, "compare_to", CmdArgs(rhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

    method resolve_with_rhs_reference->Cmd
      return CmdCompareLE( t, CmdAccess(t, rhs, "compare_to", CmdArgs(lhs)).resolve.require_integer, CmdLiteralInteger(t,0) ).resolve

endClass

class CmdCreateArray( t, array_type:Type, element_type:Type, size_expression:Cmd ) : Cmd
  METHODS
    method clone->CmdCreateArray
      return CmdCreateArray( t, array_type, element_type, size_expression )

    method is_complex_reference->Logical
      return true

    method type->Type
      return array_type

    method print( buffer:StringBuilder )
      buffer.print( array_type.name )
      buffer.print( '(' )
      size_expression.print( buffer )
      buffer.print( ')' )

    method resolve->Cmd
      array_type.resolve
      element_type.resolve
      size_expression = size_expression.resolve.require_integer
      return this
endClass

class CmdArrayCount( t, operand ) : CmdUnary
  METHODS
    method clone->CmdArrayCount
      return CmdArrayCount( t, operand )

    method type->Type
      return Types.type_Integer

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( ".count" )

    method resolve->Cmd
      operand = operand.resolve
      return this
endClass

class CmdReadArrayElement( t, operand, index_expression:Cmd, element_type:Type ) : CmdUnary
  METHODS
    method clone->CmdReadArrayElement
      return CmdReadArrayElement( t, operand, index_expression, element_type )

    method type->Type
      return element_type

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( '[' )
      index_expression.print( buffer )
      buffer.print( ']' )

    method resolve->Cmd
      operand = operand.resolve
      index_expression = index_expression.resolve.require_integer
      element_type.resolve
      return this
endClass

class CmdWriteArrayElement( t, array_type:Type, element_type:Type, operand, index_expression:Cmd, new_value:Cmd) : CmdUnary
  METHODS
    method clone->CmdWriteArrayElement
      return CmdWriteArrayElement( t, array_type, element_type, operand, index_expression, new_value )

    method type->Type
      return array_type

    method print( buffer:StringBuilder )
      operand.print( buffer )
      buffer.print( '[' )
      index_expression.print( buffer )
      buffer.print( "] = " )
      new_value.print( buffer )

    method resolve->Cmd
      operand = operand.resolve
      index_expression = index_expression.resolve.require_integer
      new_value = new_value.resolve
      array_type.resolve
      element_type.resolve
      return this
endClass

