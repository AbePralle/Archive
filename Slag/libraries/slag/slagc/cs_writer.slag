#=====================================================================
# cs_writer.slag
#
# History:
#   2010.10.05 / Abe Pralle - Created
#=====================================================================

singleton class CSWriter
  PROPERTIES
    out         : TextWriter
    indent      : Int32
    col=1       : Int32
    lines       : Int32
    num_files   : Int32

    output_filename, base_name : String
    #referenced_end_method : Logical
    
    this_method : MethodInfo

  METHODS
    method write( output_filename )
      output_filename .= before_first(".cs")
      if (not SlagCompiler.quiet) Global.println( "  Writing $.cs" (output_filename) )
      out = File(output_filename+".cs").create_writer
      base_name = output_filename.after_last('/').after_last('\\')

      # Assign default cross-compilation names
      assign_cross_compile_names

      print_header
      println

      print_helper_functions
      println

      println( "using System;" )
      println( "using System.Threading;" )
      println( "using SlagFramework;" )
      println
      println( "public class GameXC" )
      println( "{" )
      indent += 2;
      print_runtime_helpers
      indent -= 2;
      println( "}" )
      println
      println

      print_types

      out.close

    method do_indent
      while (col <= indent) out.print(' '); col++

    method print( Char ch )
      do_indent
      out.print( ch )
      col++

    method print( String st )
      do_indent
      forEach (ch in st) print(ch)

    method print( Int32 n )
      do_indent
      out.print( n )
      col += (""+n).count

    method print( Real64 n )
      do_indent
      out.print( n )
      col += (""+n).count

    method print( Logical b )
      do_indent
      out.print( b )
      if (b) col += 4
      else   col += 5

    method println( String st )
      print( st )
      println

    method println( Int32 n )
      print( n )
      println
    
    method println( Char ch )
      print( ch )
      println

    method println
      out.println
      col = 1
      lines++

    method print_header
      print( "//" )
      forEach (1..77) print('=')
      println
      println( "//  $.cs" (output_filename) )
      println( "//  Generated by slagc $" (Date()) )
      print( "//" )
      forEach (1..77) print('=')
      println

    method print_helper_functions

    method assign_cross_compile_names
      forEach (type in TypeManager.type_list)
        type.x_name
        if (type.name == "GenericArray") type.&x_name = "Array"
      endForEach

      forEach (m in TypeManager.method_list)
        m.&x_name = m.name.x_compatible

        if (m.x_name == "object")
          m.&x_name = "_object"
        endIf
        #{
        if (m.x_name.contains("__"))
          m.&x_name = m.x_name.after_first("__")
          if (m.x_name.contains("__"))
            m.&x_name = m.x_name.before_first("__")
          endIf
        endIf
        }#
      endForEach

      TypeManager["Real64"].x_name = "double";
      TypeManager["Real32"].x_name = "float";
      TypeManager["Int64"].x_name = "long";
      TypeManager["Int32"].x_name = "int";
      TypeManager["Char"].x_name = "char";
      TypeManager["Byte"].x_name = "byte";
      TypeManager["Logical"].x_name = "bool";
      TypeManager["NativeData"].x_name = "NativeData";

      forEach (type in TypeManager.type_list)
        fix_array_type(type)
      endForEach

    method fix_array_type( TypeInfo type )
      if (type.is_array)
        #type.x_name = "NativeData" 
        fix_array_type(type.element_type)
        type.x_name = type.element_type.x_name + "[]";
      endIf

    method print_runtime_helpers
      forEach (type in TypeManager.type_list)
        if (type.is_singleton and not type.is_managed)
          println( "static public $ singleton_$;" (type.x_name, type.x_name) )
        endIf
      endForEach

      local var main_class = TypeManager.main_class

      println( "static public $ main_object;" (main_class.x_name) )
      println

      println( "static public void configure()" )
      println( "{" )
      indent += 2

      forEach (type in TypeManager.type_list)
        if (type.is_singleton and not type.is_managed and type isNot main_class)
          println( "singleton_$ = new $()(Slag.CallInit.FALSE);" (type.x_name,type.x_name) )
        endIf
      endForEach
      println
      println( "Slag.configure();" );
      println
      forEach (type in TypeManager.type_list)
        if (type.is_singleton and not type.is_managed and type isNot main_class)
          println( "singleton_$.init_object();" (type.x_name) )
        endIf
      endForEach
      println
      forEach (type in TypeManager.type_list)
        if (type.is_singleton and not type.is_managed and type isNot main_class)
          if (type.methods_by_signature.contains("init_singleton()"))
            println( "singleton_$.init_singleton();" (type.x_name) )
          endIf
        endIf
      endForEach

      indent -= 2
      println( "}" )
      println

      println( "static public void init()" )
      println( "{" )
      indent += 2

      if (main_class.is_singleton)
        if (main_class.is_managed)
          println( "singleton_$.property_singleton_instance = new $()(Slag.CallInit.FALSE);"... 
              (main_class.manager_class.x_name,main_class.x_name) )
          println( "main_object = singleton_$.property_singleton_instance;"...
              (main_class.manager_class.x_name) )
        else
          println( "singleton_$ = new $()(Slag.CallInit.FALSE);" (main_class.x_name,main_class.x_name) )
          println( "main_object = singleton_$;" (main_class.x_name) )
        endIf
      else
        # Main class is not a singleton, but let's still save the init() for later.
        println( "main_object = new $()(Slag.CallInit.FALSE);" (TypeManager.main_class.x_name) )
      endIf
      println( "main_object.init_object();" );

      indent -= 2
      println( "}" )
      println

    method print_types
      local var type_string = TypeManager["String"]
      local var type_weak_reference = TypeManager["WeakReference"]

      forEach (type in TypeManager.type_list)
        if (type is TypeInfo.type_null) nextIteration
        if (type.is_array) nextIteration
        if (type.name == "GenericArray") nextIteration
        if (type.name == "Exception") nextIteration
        if (type.name == "NativeData") nextIteration

        local var wrote_base = false
        if (type.is_class)
          forEach (m in type.methods)
            if (m.is_abstract) print("abstract "); escapeForEach
          endForEach
          print( "public class $" (type.x_name) )
          if (type isNot TypeManager.type_object and not type.is_compound)
            print( " : " + type.base_types[0].x_name )
            wrote_base = true
          endIf
        elseIf (type.is_compound)
          print( "public struct $" (type.x_name) )
        elseIf (type.is_aspect)
          print( "public interface $" (type.x_name) )
        else
          nextIteration
        endIf

        if (type.base_types.count?)
          local var first = true
          forEach (a in type.base_types)
            if (a.is_aspect)
              if (wrote_base)
                print(", ")
              else 
                print(" : ")
                wrote_base = true
              endIf
              print(a.x_name)
            endIf
          endForEach
        endIf

        println

        println( "{" )
        indent += 2

        if (type is type_string)
          # Print native implementation
          println( "public String data;" )
          println( "public int    property_hash_code;" )
          println
          println( "public ClassString( String data ) : base(Slag.CallInit.FALSE)" )
          println( "{" )
          println( "  this.data = data;" )
          println( "  int code = 0;" )
          println( "  for (int i=0; i<data.Length; ++i)" )
          println( "  {" )
          println( "    code = (code<<7) | ((code>>(16-7)) & ((1<<7)-1));" )
          println( "    code += (int) data[i];" )
          println( "  }" )
          println( "  property_hash_code = code;" )
          println( "}" )
          println

        elseIf (type is type_weak_reference)
          # Print native implementation
          println( "public WeakReference weak_reference;" )
          println
          println( "public ClassWeakReference( ClassObject obj ) : base(Slag.CallInit.FALSE)" )
          println( "{" )
          println( "  weak_reference = new WeakReference(obj);" )
          println( "}" )
          println
        endIf

        if (not type.is_aspect)
          local var new_property = false
          forEach (p in type.properties)
            if (type.base_class is null or not type.base_class.properties_by_name.contains(p.name))
              println( "public $ $;" (p.type.x_name,p.x_name) )
              new_property = true
            endIf
          endForEach
          if (new_property) println
        endIf

        if (type.is_compound)
          # Compound constructor
          print( "public $()(" (type.x_name) )
          local var first=true
          forEach (p in type.properties)
            if (first) first = false
            else print(',')
            print( " $ $" (p.type.x_name,p.x_name) )
          endForEach
          println(" )")
          println('{')
          forEach (p in type.properties)
            println( "  this.$ = $;" (p.x_name,p.x_name) )
          endForEach
          println('}')
          println

          # equals() method
          println( "public bool equals( $ other )" (type.x_name) )
          println( '{' )
          forEach (p in type.properties)
            if (p.type.is_compound) 
              println( "  if (!$.equals(other.$)) return false;" (p.x_name,p.x_name) )
            else
              println( "  if ($ != other.$) return false;" (p.x_name,p.x_name) )
            endIf
          endForEach
          println( "  return true;" )
          println( '}' )
          println

        else

          if (type.is_aspect)
            # Aspect method list.
            forEach (m in type.methods)
              if (m.type_context is type) 
                contingent
                  forEach (base_aspect in type.base_types)
                    necessary (not base_aspect.methods_by_signature.contains(m.signature))
                  endForEach
                satisfied
                  print_prototype(m,true)
                endContingent
              endIf
            endForEach
          else
            # Class Constructors
            local var found_overrides = false
            local var found_inherited = false
            local var found_default = false
            forEach (m in type.methods)
              if (m.name=="init")
                if (m.type_context is type)
                  if (m.parameters.count == 0) found_default = true
                  found_overrides = true
                  print_constructor( type, m )
                else
                  found_inherited = true
                endIf
              endIf
            endForEach

            if (not found_overrides)
              if (found_inherited)
                # Print inherited constructors
                forEach (m in type.methods)
                  if (m.name=="init")
                    if (m.parameters.count == 0) found_default = true
                    print_constructor( type, m )
                  endIf
                endForEach
              endIf
            endIf

            # Every class needs a special constructor that
            # can be used to skip calls to init_object() and init()
            # so that those calls can be performed separately and 
            # with their own call chain.
            if (type is TypeManager.type_object or type is TypeManager.type_exception)
              println( "public $()( Slag.CallInit call_init )" (type.x_name) )
              println( "{" )
              println( "  if (call_init == Slag.CallInit.TRUE) init_object();" )
              println( "}" )
            else
              println( "public $()( Slag.CallInit call_init ) : base(Slag.CallInit.FALSE)" (type.x_name) )
              println( "{" )
              println( "  if (call_init == Slag.CallInit.TRUE) init_object();" )
              println( "}" )
            endIf
            println

            # type_name() method
            #{
            if (type is TypeManager.type_object) print("public virtual ")
            else                                 print("public override ")
            println( //ClassString type_name() { return Slag.str("$"); }// ...
                     (type.name) )
            println
            }#

            # regular methods
            forEach (m in type.methods)
              if (m.type_context is type) print_method(m)
            endForEach
          endIf
        endIf

        println
        indent -= 2
        println( "}" )
        println
        println
      endForEach
      println

    method print_constructor( TypeInfo type, MethodInfo m )
      print( "public $()(" (type.x_name) )
      local var first=true
      forEach (p in m.parameters)
        if (first) first = false
        else print(',')
        print( "$ $" (p.type.x_name,p.x_name) )
      endForEach
      print(")")
      if (type isNot TypeManager.type_object and type isNot TypeManager.type_exception)
        print( " : base(Slag.CallInit.FALSE)" )
      endIf
      println
      println('{')

      println( "  $_object();" (m.x_name) )

      print( "  $()(" (m.x_name) )
      first=true
      forEach (p in m.parameters)
        if (first) first = false
        else print(',')
        print( "$" (p.x_name) )
      endForEach
      println(");")
      println('}')
      println

    method print_prototype( MethodInfo m, Logical semicolon=false )
      this_method = m
      #referenced_end_method = false

      if (not semicolon) print( "public " )

      if (m.return_type?) print( "$ " (m.base_return_type.x_name) )
      else                print( "void " )
      print( m.x_name + "(" )

      local var first = true
      forEach (p in m.parameters)
        if (first) first = false
        else       print(',')
        print( "$ $" (p.type.x_name,p.x_name) )
      endForEach

      if (semicolon)
        println( ");" )
      else
        print( ") { " )
        which (m.return_type)
          case null: println( "}" )
          case TypeManager.type_real64:  println( "return 0.0; }" )
          case TypeManager.type_real32:  println( "return 0.0f; }" )
          case TypeManager.type_int64:   println( "return 0L; }" )
          case TypeManager.type_int32:   println( "return 0; }" )
          case TypeManager.type_char:    println( "return (char) 0; }" )
          case TypeManager.type_byte:    println( "return (byte) 0; }" )
          case TypeManager.type_logical: println( "return 0; }" )
          others:
            println( "return null; }" )
        endWhich
      endIf

    method print_method( MethodInfo m )
      if (m.type_context.is_aspect) return
      if (m.type_context.name == "GenericArray") return
      #if (m.signature == "type_name()") return

      this_method = m
      #referenced_end_method = false

      if (m.is_abstract)
        print( "abstract public " )
      elseIf (m.type_context.is_class and m.type_context.base_class? ...
          and m.type_context.base_class.methods_by_signature.contains(m.signature))
        local var base_m = m.type_context.base_class.methods_by_signature[m.signature]
        if (base_m.called or base_m.index != -1) print( "public override " )
        else print( "public virtual " )
      else
        print( "public virtual " )
      endIf

      if (m.return_type?) print( "$ " (m.base_return_type.x_name) )
      else                print( "void " )
      print( m.x_name + "(" )

      local var first = true
      forEach (p in m.parameters)
        if (first) first = false
        else       print(',')
        print( "$ $" (p.type.x_name,p.x_name) )
      endForEach

      print( ")" )

      if (m.is_abstract) println(";"); println; return
      else println

      println( "{" )

      indent += 2

      if (m.is_native)
        if (m.return_type?) print("return ")

        local String[] args()
        forEach (p in m.parameters) args.add(p.x_name)
        print( native_call( m.full_signature, m.x_name, "this", args) )
        println(";");
        indent -= 2
        println( "}" )
        println
        return
      endIf

      # local vars
      local var any_locals = false
      forEach (v in m.local_vars.from(m.parameters.count))
        if (not v.is_catch_var)
          any_locals = true
          println( "$ $;" (v.type.x_name,v.x_name) )
        endIf
      endForEach
      if (any_locals) println

      m.body.to_cs

      indent -= 2

      println( "}" )
      println

    method write_continue_id( CmdStructure cmd )
      if (cmd.referenced)
        println( "next_$:;" (cmd.id) )
      endIf

    method write_end_id( CmdStructure cmd )
      if (cmd.referenced)
        println( "end_$:;" (cmd.id) )
      endIf

    method native_call( String full_sig, String method_name, String context, CmdList args ).String
      local String[] string_args()
      forEach (arg in args) string_args.add(arg.to_cs)
      return native_call( full_sig, method_name, context, string_args )

    method native_call( String full_sig, String method_name, String context, String[] args ).String
      which (full_sig[0])
        case 'G':
          which (full_sig)
            case "Global::time_ms().Int64":
              return "(DateTime.Now.Ticks/10000)"

            case "Global::sleep(Int32)":
              return "Thread.Sleep($);" (args[0])
          endWhich

        case 'M':
          which (full_sig)
            case "Math::abs(Int64).Int64":
              return "Math.Abs($)" (args[0])

            case "Math::abs(Int32).Int32":
              return "Math.Abs($)" (args[0])

            case "Math::abs(Real64).Real64":
              return "Math.Abs($)" (args[0])

            case "Math::floor(Real64).Real64":
              return "Math.Floor($)" (args[0])

            case "Math::sqrt(Real64).Real64":
              return "Math.Sqrt($)" (args[0])

            case "Math::sin(Radians).Real64":
              return "Math.Sin(($).property_value)" (args[0])

            case "Math::cos(Radians).Real64":
              return "Math.Cos(($).property_value)" (args[0])

            case "Math::tan(Radians).Real64":
              return "Math.Tan(($).property_value)" (args[0])

            case "Math::asin(Real64).Radians":
              return "new CompoundRadians(Math.Asin($))" (args[0])

            case "Math::acos(Real64).Radians":
              return "new CompoundRadians(Math.Acos($))" (args[0])

            case "Math::atan(Real64).Radians":
              return "new CompoundRadians(Math.Atan($))" (args[0])

            case "Math::atan2(Real64,Real64).Radians":
              return "new CompoundRadians(Math.Atan2($,$))" (args[0],args[1])
          endWhich

        #{
        case 'O':
          which (full_sig)
            case "Object::type_name().String":
              return context + ".type_name()"
          endWhich
          }#

        case 'S':
          which (full_sig)
            case "String::count().Int32":
              return "$.data.Length" (context)

            case "String::hash_code().Int32":
              return "$.property_hash_code" (context)

            case "String::get(Int32).Char":
              return "$.data[$]" (context,args[0])

            case "String::op+(String).String":
              return "(new ClassString($.data + $.data))" (context,args[0])

            case "String::op+(Char).String":
              return "(new ClassString($.data + $))" (context,args[0])

            case "System::force_garbage_collection()":
              return "System.GC.Collect()"
          endWhich

        others:
          which (full_sig)
          endWhich

      endWhich

      local StringBuilder buffer()
      buffer.print( "Native$.$" (full_sig.before_first("::").after_first("Class"),method_name) )
      buffer.print( "($" (context) )
      forEach (arg in args) buffer.print( ",$" (arg) )
      buffer.print( ")" )
      return buffer.to_String

endClass

augment Cmd
    method to_cs.String
      throw Error( "to_cs() undefined for type " + type_name )

    method statement_to_cs.String
      return to_cs
endAugment

augment CmdStatementList
    method to_cs.String
      forEach (statement in statements) 
        local var st = statement.statement_to_cs
        if (st?) CSWriter.print(st); CSWriter.println(';')
      endForEach
      return null
endAugment

augment CmdList
    method to_cs.String
      local StringBuilder buffer()
      local var first = true
      forEach (cmd in this) 
        if (first) first = false
        else buffer.print(",")
        buffer.print(cmd.to_cs)
      endForEach
      return buffer.to_String
endAugment

augment CmdEscape
    method to_cs.String
      return "goto end_" + id
endAugment

augment CmdNextIteration
    method to_cs.String
      return "goto next_" + id
endAugment

augment CmdReturnNil
    method to_cs.String
      return "return"
endAugment

augment CmdReturnValue
    method to_cs.String
      return "return "+ operand.to_cs
endAugment

augment CmdBlock
    method to_cs.String
      CSWriter.println( "{" )
      CSWriter.indent += 2
      body.to_cs
      CSWriter.indent -= 2
      CSWriter.println( "}" )
      CSWriter.write_end_id( this )
      return null
endAugment

augment CmdTry
    method to_cs.String
      CSWriter.println( "try" )
      CSWriter.println( "{" )
      CSWriter.indent += 2
      body.to_cs
      CSWriter.indent -= 2
      CSWriter.println( "}" )
      forEach (c in catches) c.to_cs
      CSWriter.write_end_id( this )
      return null
endAugment

augment CmdCatch
    method to_cs.String
      CSWriter.println( "catch ($ $)" (var_info.type.x_name,var_info.x_name) )
      CSWriter.println( "{" )
      CSWriter.indent += 2
      body.to_cs
      CSWriter.indent -= 2
      CSWriter.println( "}" )
      return null
endAugment

augment CmdThrow
    method to_cs.String
      return "throw " + operand.to_cs
endAugment

augment CmdIf
    method to_cs.String
      CSWriter.println( "if (" + condition.to_cs + ")" )
      CSWriter.println( "{" )
      CSWriter.indent += 2
      body.to_cs
      CSWriter.indent -= 2
      CSWriter.println( "}" )

      forEach (e in elseifs) e.to_cs

      if (else_cmd?) 
        CSWriter.println( "else" )
        CSWriter.println( "{" )
        CSWriter.indent += 2
        else_cmd.to_cs
        CSWriter.indent -= 2
        CSWriter.println( "}" )
      endIf
      CSWriter.write_end_id( this )

      return null
endAugment

augment CmdElseIf
    method to_cs.String
      CSWriter.println( "else if (" + condition.to_cs + ")" )
      CSWriter.println( "{" )
      CSWriter.indent += 2
      body.to_cs
      CSWriter.indent -= 2
      CSWriter.println( "}" )
      return null
endAugment

augment CmdLoop
    method to_cs.String
      CSWriter.println( "for (;;)" )
      CSWriter.println( "{" )
      CSWriter.indent += 2
      CSWriter.write_continue_id( this )
      body.to_cs
      CSWriter.indent -= 2
      CSWriter.println( "}" )
      CSWriter.write_end_id( this )
      return null
endAugment

augment CmdWhile
    method to_cs.String
      CSWriter.println( "while ($)" (condition.to_cs) )
      CSWriter.println( "{" )
      CSWriter.indent += 2
      body.to_cs
      CSWriter.write_continue_id( this )
      CSWriter.indent -= 2
      CSWriter.println( "}" )
      CSWriter.write_end_id( this )
      return null
endAugment

augment CmdContingent
    method to_cs.String
      CSWriter.println( "{" )
      CSWriter.indent += 2
      body.to_cs
      CSWriter.println( "satisfied_$:;" (id) )
      if (satisfied_body?) 
        CSWriter.println( "{" )
        CSWriter.indent += 2
        satisfied_body.to_cs
        CSWriter.indent -= 2
        CSWriter.println( "}" )
      endIf
      CSWriter.println( "goto end_$;" (id) )
      CSWriter.println( "unsatisfied_$:;" (id) )
      if (unsatisfied_body?) 
        CSWriter.println( "{" )
        CSWriter.indent += 2
        unsatisfied_body.to_cs
        CSWriter.indent -= 2
        CSWriter.println( "}" )
      endIf
      CSWriter.indent -= 2
      CSWriter.println( "}" )
      CSWriter.write_end_id( this )
      return null
endAugment

augment CmdNecessary
    method to_cs.String
      CSWriter.println( "if ( !($) ) goto unsatisfied_$;" (operand.to_cs,id) )
      return null
endAugment

augment CmdSufficient
    method to_cs.String
      CSWriter.println( "if ($) goto satisfied_$;" (operand.to_cs,id) )
      return null
endAugment

augment CmdBreakpoint
    method to_cs.String
      CSWriter.println( "alert('breakpoint $')" (id) )
      return null
endAugment

augment CmdLiteralString
    method to_cs.String
      local StringBuilder buffer(//(new ClassString("//)
      forEach (ch in value)
        if (ch >= ' ' and ch <= '~')
          which (ch)
            case '\\': buffer.print( "\\\\" )
            case '\"': buffer.print( "\\\"" );
            others:    buffer.print( Char(ch) )
          endWhich
        else
          which (ch)
            case '\t': buffer.print("\\t")
            case '\n': buffer.print("\\n")
            case '\r': buffer.print("\\r")
            others:
              if (ch <= 255)
                buffer.print( "\\" + ("00"+ch.to_String(8)).rightmost(3) )
              else
                buffer.print( "\\u$(04)" (ch.to_String(16)) )
              endIf
          endWhich
        endIf
      endForEach
      return buffer.to_String + //"))//
endAugment

augment CmdLiteralInt64
    method to_cs.String
      if ((value & 0x8000000000000000)?) return "0x" + value.to_String(16) + "L"
      return value + "L"
endAugment

augment CmdLiteralInt32
    method to_cs.String
      return "" + value
endAugment

augment CmdLiteralChar
    method to_cs.String
      return "((char)$)" (Int32(value))
endAugment

augment CmdLiteralByte
    method to_cs.String
      return "" + value
endAugment

augment CmdLiteralReal64
    method to_cs.String
      if (value == Int32(value))
        return "$(.1)" (value)
      else
        return "Slag.to_double(0x$L)" ((value as Int64).to_String(16))
      endIf
endAugment

augment CmdLiteralReal32
    method to_cs.String
      return "Slag.to_float(0x$)" ((value as Int32).to_String(16))
endAugment

augment CmdLiteralLogical
    method to_cs.String
      if (value) return "true"
      else       return "false"
endAugment

augment CmdLiteralNull
    method to_cs.String
      return "null"
endAugment

augment CmdThisReference
    method to_cs.String
      return "this"
endAugment

augment CmdSingletonReference
    method to_cs.String
      return "GameXC.singleton_$" (of_type.x_name)
endAugment

augment CmdSingletonWrite
    method to_cs.String
      return "GameXC.singleton_$ = $" (of_type.x_name,new_value.to_cs)
endAugment

augment CmdPropertyRead
    method to_cs.String
      if (context instanceOf CmdThisReference) return "$" (var_info.x_name)
      return "$.$" (context.to_cs,var_info.x_name)
endAugment

augment CmdCompoundPropertyRead
    method to_cs.String
      return "$.$" (context.to_cs,var_info.x_name)
endAugment

augment CmdLocalVarRead
    method to_cs.String
      return var_info.x_name
endAugment

augment CmdPropertyWrite
    method to_cs.String
      if (context instanceOf CmdThisReference)
        return "$ = $" (var_info.x_name, new_value.to_cs)
      endIf
      return "$.$ = $" (context.to_cs, var_info.x_name, new_value.to_cs)
endAugment

augment CmdLocalVarWrite
    method to_cs.String
      return "$ = $" (var_info.x_name, new_value.to_cs)
endAugment

augment CmdStaticCall
    method statement_to_cs.String
      return to_cs(false)

    method to_cs.String
      return to_cs(true)

    method to_cs( Logical cast_return_value ).String
      if (method_info.type_context is TypeManager.type_generic_array)
        which (method_info.name)
          case "count":
            return "$.Length" (context.to_cs)
          case "copy_from":
            return "Array.Copy($,$,$,$,$)" ...
              (args[0].to_cs,args[1].to_cs,context.to_cs,args[2].to_cs,args[3].to_cs)
          case "clear":
            return "Slag.clear_array($,$,$)" ...
              (context.to_cs,args[0].to_cs,args[1].to_cs)
          others:
            return "TODO:"+method_info.x_name
        endWhich
      endIf

      local String cast = ""
      if (cast_return_value and method_info.return_type isNot method_info.base_return_type)
        cast = "($)" (method_info.return_type.x_name)
      endIf

      if (context instanceOf CmdThisReference)
        if (method_info.is_native)
          return cast + CSWriter.native_call( method_info.full_signature, 
                                       method_info.x_name, "this", args )
        else
          local var this_method = CSWriter.this_method
          local var this_type = this_method.type_context
          if (this_type isNot method_info.type_context ...
              and this_type.methods_by_signature.contains(method_info.signature) ...
              and this_type.methods_by_signature[method_info.signature] isNot method_info)
            return "$()base.$()($)" (cast,method_info.x_name,args.to_cs)
          else
            return "$()$()($)" (cast,method_info.x_name,args.to_cs)
          endIf
        endIf
      endIf
      
      if (method_info.is_native)
        return cast+CSWriter.native_call( method_info.full_signature, method_info.x_name, 
                                     context.to_cs, args )
      else
        return "$()$.$()($)" (cast,context.to_cs,method_info.x_name,args.to_cs)
      endIf

endAugment

augment CmdDynamicCall
    method statement_to_cs.String
      return to_cs(false)

    method to_cs.String
      return to_cs(true)

    method to_cs( Logical cast_return_value ).String
      if (method_info.type_context is TypeManager.type_generic_array)
        return "ARRAY:"
      endIf

      local String cast = ""
      if (cast_return_value and method_info.return_type isNot method_info.base_return_type)
        cast = "($)" (method_info.return_type.x_name)
      endIf

      if (context instanceOf CmdThisReference)
        return "$()$()($)" (cast,method_info.x_name,args.to_cs)
      endIf
      return "$()$.$()($)" (cast,context.to_cs,method_info.x_name,args.to_cs)
endAugment

augment CmdNewObject
    method to_cs.String
      return "new $()($)" (of_type.x_name,args.to_cs)
endAugment

augment CmdNewCompound
  METHODS
    method to_cs.String
      if (args.count?)
        return "new $()($)" (of_type.x_name,args.to_cs)
      else
        return "new $()" (of_type.x_name)
      endIf
endAugment

augment CmdNarrowingCast
  METHODS
    method statement_to_cs.String
      return operand.statement_to_cs

    method to_cs.String
      if (to_type is operand.type) return operand.to_cs
      return "(($)$)" (to_type.x_name,operand.to_cs)
endAugment

augment CmdWideningCast
  METHODS
    method statement_to_cs.String
      return operand.statement_to_cs

    method to_cs.String
      if (to_type is operand.type) return operand.to_cs
      return "(($)$)" (to_type.x_name,operand.to_cs)
endAugment

augment CmdAs
  METHODS
    method statement_to_cs.String
      return operand.statement_to_cs

    method to_cs.String
      local var op_string = operand.to_cs

      if (as_type is operand.type) return op_string

      if (as_type.is_primitive)
        whichIs (as_type)
          case TypeManager.type_real64
            return "Slag.to_double($)" (op_string)

          case TypeManager.type_real32
            return "Slag.to_float($)" (op_string)

          case TypeManager.type_int64
            return "System.BitConverter.ToInt64(System.BitConverter.GetBytes($),0)" (op_string)

          case TypeManager.type_int32
            return "System.BitConverter.ToInt32(System.BitConverter.GetBytes($),0)" (op_string)

          others
            throw Error()
        endWhichIs
      endIf

      return "($ as $)" (op_string,as_type.x_name)
endAugment

augment CmdCoerceAs
  METHODS
    method statement_to_cs.String
      return operand.statement_to_cs

    method to_cs.String
      if (as_type is operand.type) return operand.to_cs
      return "(($)$)" (as_type.x_name,operand.to_cs)
endAugment

augment CmdCmpInstanceOf
  METHODS
    method to_cs.String
      return "($ is $)" (operand.to_cs,of_type.x_name)
endAugment

augment CmdNegate
  METHODS
    method to_cs.String
      return "-$" (operand.to_cs)
endAugment

augment CmdNot
  METHODS
    method to_cs.String
      if (operand.type.is_logical)
        return "!($)" (operand.to_cs)
      else
        return "~" + (operand.to_cs)
      endIf
endAugment


augment CmdCastToInt64
  METHODS
    method statement_to_cs.String
      return operand.statement_to_cs

    method to_cs.String
      return "unchecked((long)$)" (operand.to_cs)
endAugment

augment CmdCastToInt32
  METHODS
    method statement_to_cs.String
      return operand.statement_to_cs

    method to_cs.String
      return "unchecked((int)$)" (operand.to_cs)
endAugment

augment CmdCastToChar
  METHODS
    method statement_to_cs.String
      return operand.statement_to_cs

    method to_cs.String
      return "unchecked((char)$)" (operand.to_cs)
endAugment

augment CmdCastToByte
  METHODS
    method statement_to_cs.String
      return operand.statement_to_cs

    method to_cs.String
      return "unchecked((byte)$)" (operand.to_cs)
endAugment

augment CmdCastToReal64
  METHODS
    method statement_to_cs.String
      return operand.statement_to_cs

    method to_cs.String
      return "((double)$)" (operand.to_cs)
endAugment

augment CmdCastToReal32
  METHODS
    method statement_to_cs.String
      return operand.statement_to_cs

    method to_cs.String
      return "((float)$)" (operand.to_cs)
endAugment

augment CmdCastToLogical
  METHODS
    method statement_to_cs.String
      return operand.statement_to_cs

    method to_cs.String
      return "($ !=0 )" (operand.to_cs)
endAugment

augment CmdCmpEQ
  method to_cs.String
    if (lhs.type.is_compound)
      return "$.equals($)" (lhs.to_cs,rhs.to_cs)
    else
      return "($ == $)" (lhs.to_cs,rhs.to_cs)
    endIf
endAugment

augment CmdCmpNE
  method to_cs.String
    if (lhs.type.is_compound)
      return "(!$.equals($))" (lhs.to_cs,rhs.to_cs)
    else
      return "($ != $)" (lhs.to_cs,rhs.to_cs)
    endIf
endAugment

augment CmdCmpLE
  method to_cs.String
    return "($ <= $)" (lhs.to_cs,rhs.to_cs)
endAugment

augment CmdCmpLT
  method to_cs.String
    return "($ < $)" (lhs.to_cs,rhs.to_cs)
endAugment

augment CmdCmpGT
  method to_cs.String
    return "($ > $)" (lhs.to_cs,rhs.to_cs)
endAugment

augment CmdCmpGE
  method to_cs.String
    return "($ >= $)" (lhs.to_cs,rhs.to_cs)
endAugment

augment CmdCmpIs
  method to_cs.String
    return "($ == $)" (lhs.to_cs,rhs.to_cs)
endAugment

augment CmdCmpIsNot
  method to_cs.String
    return "($ != $)" (lhs.to_cs,rhs.to_cs)
endAugment

augment CmdCmpIsNull
    method to_cs.String
      return "($ == null)" (operand.to_cs)
endAugment

augment CmdCmpIsNotNull
    method to_cs.String
      return "($ != null)" (operand.to_cs)
endAugment

augment CmdMathOp
    method to_cs.String
      which ($symbol)
        case "%":
          return "Slag.mod($,$)" (lhs.to_cs,rhs.to_cs)
        case "^":
          return "($)Math.Pow($,$)" (lhs.type.x_name,lhs.to_cs,rhs.to_cs)
        others:
          return "(" + lhs.to_cs + $symbol + rhs.to_cs + ")"
      endWhich
endAugment

augment CmdBitwiseOp
    method to_cs.String
      which ($symbol)
        case "~": 
          return "($^$)" (lhs.to_cs,rhs.to_cs)
        others:
          return "(" + lhs.to_cs + $symbol + rhs.to_cs + ")"
      endWhich
endAugment

augment CmdLazyAnd
    method to_cs.String
      return "($ && $)" (lhs.to_cs,rhs.to_cs)
endAugment

augment CmdLazyOr 
    method to_cs.String
      return "($ || $)" (lhs.to_cs,rhs.to_cs)
endAugment

augment CmdLeftShifted
    method to_cs.String
      return "($<<$)" (lhs.to_cs,rhs.to_cs)
endAugment

augment CmdRightShifted
    method to_cs.String
      return "Slag.shr($,$)" (lhs.to_cs,rhs.to_cs)
endAugment

augment CmdRightXShifted
    method to_cs.String
      return "($>>$)" (lhs.to_cs,rhs.to_cs)
endAugment

augment CmdArrayCreate
    method to_cs.String
      local var name = of_type.x_name
      return "new $[$]$" (name.before_first("[]"),size_expr.to_cs,name.after_first("[]"))
endAugment

augment CmdArrayGet
    method to_cs.String
      return "$[$]" (context.to_cs,index_expr.to_cs)
endAugment

augment CmdArraySet
    method to_cs.String
      return "$[$]=$" (context.to_cs,index_expr.to_cs,value_expr.to_cs)
endAugment

augment CmdArrayDuplicate
    method to_cs.String
      return "(($)Slag.array_duplicate($))" (context.type.x_name,context.to_cs)
endAugment

augment CmdThisPropertyAddAndAssign
  method to_cs.String
    return "$ += $" (var_info.x_name,operand.to_cs)
endAugment

augment CmdThisPropertySubAndAssign
  method to_cs.String
    return "$ -= $" (var_info.x_name,operand.to_cs)
endAugment

augment CmdThisPropertyMulAndAssign 
  method to_cs.String
    return "$ *= $" (var_info.x_name,operand.to_cs)
endAugment

augment CmdThisPropertyDivAndAssign
  method to_cs.String
    return "$ = $/$" (var_info.x_name,var_info.x_name,operand.to_cs)
endAugment

augment CmdThisPropertyModAndAssign
  method to_cs.String
    return "$ = Slag.mod($,$)" (var_info.x_name,var_info.x_name,operand.to_cs)
endAugment

augment CmdLocalVarAddAndAssign
  method to_cs.String
    return "$ += $" (var_info.x_name,operand.to_cs)
endAugment

augment CmdLocalVarSubAndAssign
  method to_cs.String
    return "$ -= $" (var_info.x_name,operand.to_cs)
endAugment

augment CmdLocalVarMulAndAssign 
  method to_cs.String
    return "$ *= $" (var_info.x_name,operand.to_cs)
endAugment

augment CmdLocalVarDivAndAssign
  method to_cs.String
    return "$ = $/$" (var_info.x_name,var_info.x_name,operand.to_cs)
endAugment

augment CmdLocalVarModAndAssign
  method to_cs.String
    return "$ = Slag.mod($,$)" (var_info.x_name,var_info.x_name,operand.to_cs)
endAugment

augment CmdThisPropertyIncrement
  method to_cs.String
    return "++$" (var_info.x_name)
endAugment

augment CmdThisPropertyDecrement
  method to_cs.String
    return "--$" (var_info.x_name)
endAugment

augment CmdLocalVarIncrement
  method to_cs.String
    return "++$" (var_info.x_name)
endAugment

augment CmdLocalVarDecrement
  method to_cs.String
    return "--$" (var_info.x_name)
endAugment

