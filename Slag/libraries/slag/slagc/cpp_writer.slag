#=====================================================================
# cpp_writer.slag
#
# Slag-to-C++ cross-compiler functions.
#
# $(SLAG_VERSION) $(DATE)
#
# --------------------------------------------------------------------
#
# Copyright 2010 Plasmaworks LLC
#
# Licensed under the Apache License, Version 2.0 (the "License"); 
# you may not use this file except in compliance with the License. 
# You may obtain a copy of the License at 
#
#   http://www.apache.org/licenses/LICENSE-2.0 
#
# Unless required by applicable law or agreed to in writing, 
# software distributed under the License is distributed on an 
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
# either express or implied. See the License for the specific 
# language governing permissions and limitations under the License.
#
# History:
#   2010.01.05 / Abe Pralle - Revamped for v3.2
#   2010.01.05 / Abe Pralle - Updated for v3 compiler.
#   2008.01.18 / Abe Pralle - Created
#=====================================================================

singleton class CPPWriter
  PROPERTIES
    out         : TextWriter
    indent      : Int32
    col=1       : Int32
    lines       : Int32
    num_files   : Int32

    output_filename, base_name : String
    
    this_method : MethodInfo

    use_longjmp : Logical

    num_method_lists : Int32

  METHODS
    method write( output_filename )
      output_filename .= before_first(".cpp")
      output_filename += "_xc"
      base_name = output_filename.after_last('/').after_last('\\')

      # Assign default cross-compilation names.
      assign_cross_compile_names

      # Add parameter types to identifiers table.
      forEach (m in TypeManager.method_list)
        TypeManager.identifiers[m.signature.from_first('(')]
      endForEach

      if (not SlagCompiler.quiet) Global.println( "  Writing $.h" (output_filename) )
      out = File(output_filename+".h").create_writer
      println( "#ifndef $_H" (base_name.to_uppercase) )
      println( "#define $_H" (base_name.to_uppercase) )
      print_header("h")
      println
      println( //#include "slag.h"// )
      println

      # Define compounds first.
      print_compound_defs

      print_type_defs
      print_method_prototypes(true)

      println( "#endif // $_H" (base_name.to_uppercase) )
      out.close

      if (not SlagCompiler.quiet) Global.println( "  Writing $.cpp" (output_filename) )
      out = File(output_filename+".cpp").create_writer
      print_header("cpp")
      println

      println(//#include "slag.h"//)
      println(//#include "$.h"// (base_name))
      println

      print_identifiers
      print_type_info_defs
      print_property_info
      print_method_prototypes(false)
      print_literal_strings
      print_function_typedefs
      print_method_defs
      print_base_type_index_table
      print_method_pointers
      print_method_info
      print_dispatch_table
      print_configuration_function
      print_miscellaneous

      out.close

    method do_indent
      while (col <= indent) out.print(' '); col++

    method print( Char ch )
      do_indent
      out.print( ch )
      col++

    method print( String st )
      do_indent
      forEach (ch in st) print(ch)

    method print( Int32 n )
      do_indent
      out.print( n )
      col += (""+n).count

    method print( Real64 n )
      do_indent
      out.print( n )
      col += (""+n).count

    method print( Logical b )
      do_indent
      out.print( b )
      if (b) col += 4
      else   col += 5

    method println( String st )
      print( st )
      println

    method println( Int32 n )
      print( n )
      println
    
    method println( Char ch )
      print( ch )
      println

    method println
      out.println
      col = 1
      lines++

    method print_header( String extension )
      print( "//" )
      forEach (1..77) print('=')
      println
      println( "//  $.$" (base_name,extension) )
      println( "//  Generated by slagc $" (Date()) )
      print( "//" )
      forEach (1..77) print('=')
      println

    method assign_cross_compile_names
      forEach (type in TypeManager.type_list)
        type.x_name
        #if (type.name == "GenericArray") type.&x_name = "Array"
      endForEach

      forEach (m in TypeManager.method_list)
        m.x_name
      endForEach

      TypeManager["Real64"].x_name = "SlagReal64";
      TypeManager["Real32"].x_name = "SlagReal32";
      TypeManager["Int64"].x_name = "SlagInt64";
      TypeManager["Int32"].x_name = "SlagInt32";
      TypeManager["Char"].x_name = "SlagChar";
      TypeManager["Byte"].x_name = "SlagByte";
      TypeManager["Logical"].x_name = "SlagLogical";

    method print_compound_defs
      forEach (type in TypeManager.type_list)
        if (not type.is_compound) nextIteration

        println( "struct $" (type.x_name) )
        println( "{" )
        indent += 2

        forEach (p in type.properties)
          if (p.type.is_primitive)
            if (p.type.is_real) println( "SlagReal64 $;" (p.x_name) )
            else                println( "SlagInt64  $;" (p.x_name) )
          else
            println( "$ $;" (p.type.x_name,p.x_name) )
          endIf
        endForEach
        println

        # Compound constructors
        print( "$()()" (type.x_name) )
        if (type.properties.count?)
          println
          print( "    : " )
          local var first = true
          forEach(p in type.properties)
            if (first) first = false
            else print(", ")
            print( p.x_name )
            print( '(' )
            if (p.type.is_reference) print("NULL")
            elseIf (p.type.is_primitive) print("0")
            else print( p.type.x_name+"()" )
            print( ')' )
          endForEach
        endIf
        println( " { }" )
        println

        print( "$()( " (type.x_name) )
        local var first=true
        forEach (p in type.properties)
          if (first) first = false
          else print(", ")
          if (p.type.is_primitive)
            if (p.type.is_real) print( "SlagReal64 $" (p.x_name) )
            else                print( "SlagInt64 $" (p.x_name) )
          else
            print( "$ $" (p.type.x_name,p.x_name) )
          endIf
        endForEach
        print(" )")
        if (type.properties.count?)
          print( " : " )
          first = true
          forEach(p in type.properties)
            if (first) first = false
            else print(", ")
            print( p.x_name + "($)" (p.x_name) )
          endForEach
        endIf
        println( " { }" )
        println

        # Assignment overload (gcc bug workaround; "obj->v = v" can sometimes crash gcc)
        println( "void operator=( $ other )" (type.x_name) )
        println( "{" )
        println( "  memcpy( this, &other, sizeof($) );" (type.x_name) )
        println( "}" )
        println


        # equals() method
        println( "SlagLogical equals( $ other )" (type.x_name) )
        println( '{' )
        println( "  return memcmp(this,&other,sizeof($)) == 0;" (type.x_name) )
        println( '}' )
        println

        # equals() method
        #{ OLD VERSION - doesn't work with NaN
        println( "SlagLogical equals( $ other )" (type.x_name) )
        println( '{' )
        forEach (p in type.properties)
          if (p.type.is_compound) 
            println( "  if ( !($.equals(other.$)) ) return false;" (p.x_name,p.x_name) )
          else
            println( "  if ($ != other.$) return false;" (p.x_name,p.x_name) )
          endIf
        endForEach
        println( "  return true;" )
        println( '}' )
        println
        }#

        indent -= 2
        println( "};" )
        println
        println
      endForEach

    method print_type_defs
      forEach (type in TypeManager.type_list)
        if (type is TypeInfo.type_null) nextIteration
        if (not type.is_reference) nextIteration

        print( "struct $" (type.x_name) )
        if (type.is_class)
          if (type is TypeManager.type_object or type.is_aspect)
            print( " : SlagObject" )
          else
            print( " : " + type.base_class.x_name )
          endIf
        else #elseIf (type.is_aspect and type.base_types.count == 0)
          print( " : SlagObject" )
        endIf

        println

        println( "{" )
        indent += 2

        if (not type.is_aspect)
          local var new_property = false
          forEach (p in type.properties)
            if (type.base_class is null or not type.base_class.properties_by_name.contains(p.name))
              if (p.type.is_reference)
                println( "SlagObject* $;" (p.x_name) )
              else
                println( "$ $;" (p.type.x_name,p.x_name) )
              endIf
              new_property = true
            endIf
          endForEach
        endIf

        indent -= 2
        println( "};" )
        println
        println
      endForEach
      println

    method print_identifiers
      println( "const char* sxc_identifiers[] =" )
      println( "{" )
      indent += 2
      local var first = true
      forEach (id in TypeManager.identifiers)
        if (first) first = false
        else println(",")
        print('"')
        forEach (ch in id)
          which (ch)
            case '"':  print("\\\"")
            case '\\': print("\\\\")
            case '\n': print("\\n")
            others
              if (ch >= 32 and ch <= 126) print(ch)
              else print( "\\" + ch.to_String(8).rightmost(3) )
          endWhich
        endForEach
        print('"')
      endForEach
      println
      indent -= 2
      println( "};" )
      println
      println

    method print_property_info
      println( "int sxc_property_info[] =" )
      println( "{" )
      indent += 2
      local var first = true
      forEach (type in TypeManager.type_list)
        if (type.is_aspect) nextIteration

        if (type.properties.count?)
          if (first) first = false
          else println(",")
          local var first_p = true
          forEach (p in type.properties)
            if (first_p) first_p = false
            else print(",")
            print( "$,$" (p.type.index,TypeManager.identifiers[p.name]) )
          endForEach
        endIf
      endForEach
      println
      indent -= 2
      println( "};" )
      println
      println

    method print_type_info_defs
      local var num_singletons = 0
      forEach (type in TypeManager.type_list)
        if (type.is_singleton) ++num_singletons
      endForEach

      println( "SlagTypeInfo*   sxc_types[$] = {NULL};" (TypeManager.type_list.count) )
      println( "int             sxc_types_count = $;" (TypeManager.type_list.count) )
      println( "SlagObject*     sxc_singletons[$] = {NULL};" (num_singletons) )
      println( "int             sxc_singletons_count = $;" (num_singletons) )
      println( "SlagMethodInfo  sxc_methods[$];" (TypeManager.method_list.count) )
      println

      forEach (type in TypeManager.type_list)
        if (type is TypeInfo.type_null) nextIteration

        local var reference_property_count = 0
        forEach (p in type.properties)
          if (p.type.is_reference) ++reference_property_count
        endForEach

        print( "SlagTypeInfo type_" + type.x_name )
        print( "($,$,$,$,$,sizeof($),$);" ...
          (TypeManager.identifiers[type.name],type.qualifiers.flags,
           type.index,type.singleton_index,type.flat_base_types.count,
           type.x_name, reference_property_count ) )
        println
      endForEach
      println

    method print_base_type_index_table
      println( "int sxc_base_type_index_table[] =" )
      println( "{" )
      indent += 2

      local var first = true
      local var count = 0
      forEach (type in TypeManager.type_list)
        if (type is TypeInfo.type_null) nextIteration

        forEach (base_type in type.flat_base_types) 
          if (first) first = false
          else print(',')
          if (count == 16) println; count = 0
          print( base_type.index )
          ++count
        endForEach
      endForEach
      println

      indent -= 2
      println( "};" )
      println

    method print_method_pointers
      println( "void* sxc_method_pointers[] =" )
      println( "{" )
      indent += 2

      local var first = true
      forEach (m in TypeManager.method_list)
        if (first) first = false
        else       println(',')

        if (m.is_abstract or m.type_context.is_aspect or m.type_context is TypeManager.type_null)
          print( "NULL" )
          nextIteration
        endIf

        if (m.is_native)
          # Disambiguate overloaded method name with function pointer cast.
          print( "(void*)(" )
          if (m.return_type?)
            if (m.return_type.is_reference) print("SlagObject*")
            else print(m.return_type.x_name)
          else
            if (m.name == "init") print( "SlagObject*" )
            else                  print("void")
          endIf
          print("(*)(SlagObject*")
          forEach (p in m.parameters)
            print(',')
            if (p.type.is_reference) print("SlagObject*")
            else                     print(p.type.x_name)
          endForEach
          print( ")) $" (m.x_name) )
        else
          # There's only one copy of this method name.
          print( "(void*) $" (m.x_name) )
        endIf
      endForEach
      println

      indent -= 2
      println( "};" )
      println

    method print_method_info
      local HashTable<<String,Int32>> defined_callers()
      local String[] callers_list()
      local Int32[] method_callers()

      forEach (m in TypeManager.method_list)
        if (m.is_abstract or m.type_context.is_aspect or m.type_context is TypeManager.type_null)
          method_callers.add(0)
          nextIteration
        endIf

        local StringBuilder buffer()
        buffer.print( "call__" )
        local var first = true
        forEach (p in m.parameters)
          if (first) first = false
          else       buffer.print( '_' )
          if (p.type.is_reference) buffer.print( "Object" )
          else                     buffer.print( p.type.name.x_compatible )
        endForEach
        buffer.print( "__" )
        if (m.return_type?)
          if (m.return_type.is_reference) buffer.print( "Object" )
          else                            buffer.print( m.return_type.name.x_compatible )
        endIf

        local var call_sig = buffer.to_String
        if (not defined_callers.contains(call_sig))
          defined_callers[call_sig] = callers_list.count
          callers_list.add(call_sig)
          println( "static void $()( void* method_ptr )" (call_sig) );
          println( "{" )
          indent += 2
          local var index = m.parameters.count
          forEach (p in m.parameters.reverse_order)
            if (p.type.is_reference) 
              println( "SlagObject* p$ = SLAG_POP_REF();" (index) )
            elseIf (p.type.is_primitive) 
              whichIs (p.type)
                case TypeManager.type_real64: println("SlagReal64  p$ = SLAG_POP_REAL64();"(index))
                case TypeManager.type_real32: println("SlagReal32  p$ = SLAG_POP_REAL32();"(index))
                case TypeManager.type_int64:  println("SlagInt64   p$ = SLAG_POP_INT64();"(index))
                case TypeManager.type_int32:  println("SlagInt32   p$ = SLAG_POP_INT32();"(index))
                case TypeManager.type_char:   println("SlagChar    p$ = SLAG_POP_CHAR();"(index))
                case TypeManager.type_byte:   println("SlagByte    p$ = SLAG_POP_BYTE();"(index))
                case TypeManager.type_logical:println("SlagLogical p$ = SLAG_POP_LOGICAL();"(index))
              endWhichIs
            else
              println( "$ p$ = SLAG_POP($);" (p.type.x_name,index,p.type.x_name) )
            endIf
            --index
          endForEach
          println( "SlagObject* context = SLAG_POP_REF();" )

          if (m.return_type?)
            print( "SLAG_PUSH" )
            if (m.return_type.is_reference)
              print( "_REF( " );
            elseIf (m.return_type.is_primitive)
              whichIs (m.return_type)
                case TypeManager.type_real64:  print("_REAL64( ")
                case TypeManager.type_real32:  print("_REAL32( ")
                case TypeManager.type_int64:   print("_INT64( ")
                case TypeManager.type_int32:   print("_INT32( ")
                case TypeManager.type_char:    print("_CHAR( ")
                case TypeManager.type_byte:    print("_BYTE( ")
                case TypeManager.type_logical: print("_LOGICAL( ")
              endWhichIs
            else
              print( "( $, " (m.return_type.x_name) )
            endIf
          endIf

          print( "((" )
          if (m.return_type?)
            if (m.return_type.is_reference) print("SlagObject*")
            else print(m.return_type.x_name)
          else
            print("void")
          endIf
          print("(*)(SlagObject*")
          forEach (p in m.parameters)
            print(',')
            if (p.type.is_reference) print("SlagObject*")
            else                     print(p.type.x_name)
          endForEach
          print( "))method_ptr)(context" )
          index = 1
          forEach (p in m.parameters)
            print( ",p$" (index) )
            ++index
          endForEach
          if (m.return_type?) println( ") );" )
          else println(");")

          indent -= 2
          println( "}" )
          println
        endIf
        method_callers.add( defined_callers[call_sig] )
      endForEach

      println( "void* sxc_caller_table[] =" )
      println( "{" )
      indent += 2;
      local var first = true
      forEach (sig in callers_list)
        if (first) first = false
        else println(",")
        print( "(void*) " + sig );
      endForEach
      println
      indent -= 2;
      println( "};" )
      println

      println( "int sxc_method_info_table[] =" )
      println( "{" )
      indent += 2;
      first = true
      forEach (m in TypeManager.method_list)
        if (first) first = false
        else println(",")

        print( "$, $, $" (TypeManager.identifiers[m.name], 
          TypeManager.identifiers[m.signature.from_first('(')],
          method_callers[m.index]) )

      endForEach
      println
      indent -= 2;
      println( "};" )
      println

      local Int32[] list_data(1000)
      forEach (type in TypeManager.type_list)
        if (type is TypeInfo.type_null) nextIteration
        if (not type.is_class) nextIteration
        ++num_method_lists
        list_data.add( type.index )
        list_data.add( type.methods.count )
        forEach (m in type.methods) list_data.add(m.index)
      endForEach

      println( "int sxc_method_list_table[] =" )
      println( "{" )
      indent += 2;
      local var c = 0
      forEach (i in list_data)
        if (c > 0)
          if ((c & 15) == 0) println(','); c = 0
          else print(',')
        endIf
        print(i)
        ++c
      endForEach
      println

      indent -= 2;
      println( "};" )
      println

    method print_dispatch_table
      println( "void* sxc_dispatch_table[] =" )
      println( "{" )
      indent += 2

      local var first = true
      forEach (type in TypeManager.type_list)
        if (type is TypeInfo.type_null) nextIteration
        if (not type.is_reference) nextIteration

        if (type.dispatch_table?)
          forEach (m in type.dispatch_table)
            if (first) first = false
            elseIf (m? and not m.is_abstract) println(',')
            else                              print(", ")

            if (m? and not m.is_abstract) 
              if (m.is_native)
                # Disambiguate overloaded method name with function pointer cast.
                print( "(void*)(" )
                if (m.return_type?)
                  if (m.return_type.is_reference) print("SlagObject*")
                  else print(m.return_type.x_name)
                else
                  print("void")
                endIf
                print("(*)(SlagObject*")
                forEach (p in m.parameters)
                  print(',')
                  if (p.type.is_reference) print("SlagObject*")
                  else                     print(p.type.x_name)
                endForEach
                print( ")) $" (m.x_name) )
              else
                # There's only one copy of this method name.
                print( "(void*) $" (m.x_name) )
              endIf
            else
              print( "NULL" )
            endIf
          endForEach
        endIf
      endForEach
      println

      indent -= 2
      println( "};" )
      println

    method print_configuration_function
      println( "void sxc_configure()" )
      println( "{" )
      indent += 2

      println( "sxc_main_class = &type_$;" (TypeManager.main_class.x_name) )
      println

      println( "int* type_table = sxc_base_type_index_table;" )
      local var type_table_index = 0
      local var property_info_index = 0
      local var dispatch_index = 0
      forEach (type in TypeManager.type_list)
        if (type is TypeInfo.type_null) nextIteration

        if (not type.is_aspect and type.properties.count?)
          println( "type_$.set_property_info( sxc_property_info, $, $ );" ...
              (type.x_name,property_info_index,type.properties.count) )
          property_info_index += type.properties.count * 2
        endIf

        if (not type.is_reference) nextIteration

        # Base type indices
        if (type.flat_base_types.count?)
          println( "type_$.set_base_types(type_table,$);" (type.x_name,type_table_index) )
          type_table_index += type.flat_base_types.count
        endIf

        # Element type
        if (type.is_array)
          if (type.is_reference_array)
            println( "type_$.element_size = sizeof(SlagObject*);" (type.x_name) )
          else
            println( "type_$.element_size = sizeof($);" (type.x_name,type.element_type.x_name) )
          endIf
        endIf

        if (type.is_class)
          # Reference property offsets for GC
          #{
          forEach (p in type.properties)
            if (p.type.is_reference)
              println( "type_$.add_reference_property_offset( offsetof($,$) );" ...
                (type.x_name,type.x_name,p.x_name) );
            endIf
          endForEach
          }#

          # init_object method
          local var m = type.find_method("init_object()")
          if (m? and (m.qualifiers.flags & Qualifiers.qual_empty_body.flags) == 0 and m.collected)
            println( "type_$.method_init_object = (SlagFn) $;" (type.x_name,m.x_name) )
          endIf

          if (type.qualifiers.requires_cleanup)
            m = type.find_method("clean_up()")
            println( "type_$.method_clean_up = (SlagFn) $;" (type.x_name,m.x_name) )
          endIf

          # Set dispatch tables
          if (type.dispatch_table?)
            println( "type_$.dispatch_table = sxc_dispatch_table+$;" ...
              (type.x_name,dispatch_index) )
            dispatch_index += type.dispatch_table.count
          endIf
        endIf

      endForEach
      println

      # Set up MethodInfo
      println( "sxc.set_up_method_info( sxc_method_info_table, $ );" ...
          (TypeManager.method_list.count) )
      println( "sxc.create_method_lists( sxc_method_list_table, $ );" (num_method_lists) )

      # Create singleton objects
      forEach (type in TypeManager.type_list)
        if (not type.is_singleton) nextIteration
        println( "sxc_write_ref( &sxc_singletons[$], type_$.create_without_init() );" ...
          (type.singleton_index,type.x_name) )
      endForEach
      println

      # Have Global configure its standard I/O first thing.
      println( "Global__set_up_stdio( type_ClassGlobal.singleton() );" )
      println

      # Create the main object
      local var main_class = TypeManager.main_class
      println( "SlagObject* main_obj;" )
      if (main_class.is_singleton)
        println( "main_obj = sxc_singletons[$];" (main_class.singleton_index) )
      else
        println( "main_obj = type_$.create_without_init();" (main_class.x_name) )
        if (main_class.is_managed)
          println( "$Manager* mgr = ($Manager*) type_$Manager.singleton();" ...
            (main_class.x_name,main_class.x_name,main_class.x_name) )
          println( "mgr->property_singleton_instance = main_obj;" )
          println( "++main_obj->reference_count;" )
        endIf
      endIf
      println( "slag_main_object = main_obj;" );
      println

      # Call init_object() on each singleton that's not the main class type
      forEach (type in TypeManager.type_list)
        if (not type.is_singleton) nextIteration
        if (type is TypeManager.main_class) nextIteration
        println( "$()( sxc_singletons[$] );" (type.must_find_method("init_object()").x_name,
          type.singleton_index) )
      endForEach
      println

      # Possibly call init_singleton() on each singleton
      forEach (type in TypeManager.type_list)
        if (type is TypeManager.main_class or not type.is_singleton) nextIteration
        local var m = type.find_method("init_singleton()")
        if (m?)
          println( "$()( sxc_singletons[$] );" (m.x_name,type.singleton_index) )
        endIf
      endForEach

      indent -= 2
      println( "}" )
      println

    method print_miscellaneous
      println( "SlagObject* sxc_get_global_cmd_line_args_list()" )
      println( "{" )
      println( "  return ((ClassGlobal*)sxc_singletons[$])->property_command_line_args;"...
        (TypeManager["Global"].singleton_index) )
      println( "}" )
      println

      #{
      local var main_class = TypeManager.main_class
      println( "void slag_init_main_object()" )
      println( "{" )
      println( "  slag_main_object->type->method_init_object( *slag_main_object );" );
      println( "  $()( *slag_main_object );" ...
          (main_class.must_find_method("init()").x_name ) )
      println( "}" )
      println
      }#

    method print_literal_strings
      forEach (i of TypeManager.strings)
        print( "static SlagLiteralString str" + i )
        print( //( "// )
        forEach (ch in TypeManager.strings[i].to_utf8)
          if (ch >= 32 and ch <= 126)
            which (ch)
              case '"':  print(//\\"//)
              case '\\': print("\\\\")
              others:    print(ch)
            endWhich
          else
            print( "\\" + ch.to_String(8).rightmost(3) )
          endIf
        endForEach
        println( //", $ );// (TypeManager.strings[i].count) )
      endForEach
      println

    method print_function_typedefs
      local HashTable<<String,String>> fnptr_lookup()
      local MethodGroup[] unique_groups()
      forEach (group in TypeManager.method_group_list)
        local var m = group.methods.first
        local StringBuilder buffer()
        buffer.print("Fn__")
        local var first=true
        forEach (p in m.parameters)
          if (first) first = false
          else buffer.print("_")
          buffer.print(p.type.name.x_compatible)
        endForEach
        if (m.return_type?)
          buffer.print("__")
          if (m.return_type.is_reference)
            buffer.print("Object")
          else
            buffer.print(m.return_type.name.x_compatible)
          endIf
        endIf

        local var name = buffer.to_String
        group.x_name = name
        if (not fnptr_lookup.contains(name))
          fnptr_lookup[name] = name
          unique_groups.add( group )
          print( "typedef " )
          if (m.return_type?)
            if (m.return_type.is_reference)
              print( "SlagObject*" )
            else
              print( m.return_type.x_name )
            endIf
          else
            print( "void" )
          endIf
          print(" (*$)(SlagObject*" (name) )
          forEach (p in m.parameters)
            print(",")
            if (p.type.is_reference)
              print("SlagObject*")
            else
              print(p.type.x_name)
            endIf
          endForEach
          println(");")
        endIf

      endForEach
      println

      # Dynamic dispatch functions
      forEach (group in unique_groups)
        local var m = group.methods.first
        print( "static " )
        if (m.return_type?)
          if (m.return_type.is_reference)
            print( "SlagObject*" )
          else
            print( m.return_type.x_name )
          endIf
        else
          print( "void" )
        endIf
        print( " Call" + group.x_name )
        print( "( int dynamic_index, SlagObject* context" )
        local var index = 1
        forEach (p in m.parameters)
          print( ", " )
          if (p.type.is_reference) print( "SlagObject* param$" (index) )
          else                     print( "$ param$" (p.type.x_name,index) )
          ++index
        endForEach
        println( " )" )
        println( "{" )
        indent += 2

        println( "$ fn = ($) context->type->dispatch_table[dynamic_index];" (group.x_name,group.x_name) )
        if (m.return_type?) print( "return " );
        print( "fn( context" )
        forEach (i in 1..m.parameters.count)
          print( ", param" + i )
        endForEach
        println( " );" )

        indent -= 2
        println( "}" )
        println
      endForEach

    method print_method_prototypes( Logical print_requisite )
      forEach (m in TypeManager.method_list)
        if (m.is_abstract or m.type_context.is_aspect) nextIteration
        if (m.type_context is TypeManager.type_null) nextIteration
        #if (m.type_context.name == "GenericArray") nextIteration
        if (print_requisite xor m.is_requisite) nextIteration

        if (m.is_native)
          println( "void $()();" (m.x_name) )  # Native handler
        endIf

        if (not m.is_requisite) print( "static " )

        local var is_initializer = (m.name == "init")

        if (m.return_type?)
          if (m.return_type.is_reference)
            print( "SlagObject* " )
          else
            print( "$ " (m.return_type.x_name) )
          endIf
        elseIf (is_initializer)
          print( "SlagObject* " )
        else
          print( "void " )
        endIf
        print( "$()( " (m.x_name) )

        print( "SlagObject* context")

        forEach (p in m.parameters)
          if (p.type.is_reference)
            print( ", SlagObject*" )
          else
            print( ", $" (p.type.x_name) )
          endIf
          print( " $" (p.x_name) )
        endForEach

        println( " );" )
      endForEach
      println

    method print_method_defs
      forEach (m in TypeManager.method_list)
        if (m.is_abstract or m.type_context.is_aspect) nextIteration
        if (m.type_context is TypeManager.type_null) nextIteration
        #if (m.type_context.name == "GenericArray") nextIteration

        if (not m.is_requisite) print( "static " )

        this_method = m

        local var is_initializer = (m.name == "init")

        if (m.return_type?)
          if (m.return_type.is_reference)
            print( "SlagObject* " )
          else
            print( "$ " (m.return_type.x_name) )
          endIf
        elseIf (is_initializer)
          print( "SlagObject* " )
        else
          print( "void " )
        endIf
        print( "$()( " (m.x_name) )

        print( "SlagObject* context" )

        forEach (p in m.parameters)
          if (p.type.is_reference)
            print( ", SlagObject*" )
          else
            print( ", $" (p.type.x_name) )
          endIf
          print( " $" (p.x_name) )
        endForEach

        println( " )" )
        println( "{" )
        indent += 2

        if (m.is_native)
          local String[] args()
          forEach (p in m.parameters) args.add(p.x_name)
          local var native_call_str = native_call( m, "context", args )
          if (native_call_str?)
            # Call gets mapped to something else - just forward the call.
            if (m.return_type?) print("return ")
            print( native_call_str )
            println(";");
            if (is_initializer) println( "return context;" )
          else
            # Call the stack-based native implementation.
            println( "SLAG_PUSH_REF( context );" )
            forEach (p in m.parameters)
              if (p.type.is_reference)
                println( "SLAG_PUSH_REF( $ );" (p.x_name) )
              elseIf (p.type.is_primitive)
                print( "SLAG_PUSH_" )
                whichIs (p.type)
                  case TypeManager.type_real64:  print("REAL64")
                  case TypeManager.type_real32:  print("REAL32")
                  case TypeManager.type_int64:   print("INT64")
                  case TypeManager.type_int32:   print("INT32")
                  case TypeManager.type_char:    print("CHAR")
                  case TypeManager.type_byte:    print("BYTE")
                  case TypeManager.type_logical: print("LOGICAL")
                endWhichIs
                println( "( $ );" (p.x_name) )
              else
                # Compound
                println( "SLAG_PUSH( $, $ );" (p.type.x_name,p.x_name) )
              endIf
            endForEach
            print( m.x_name )
            println( "();" )
            if (is_initializer)
              println( "return context;" )
            elseIf (m.return_type?)
              if (m.return_type.is_reference())
                println( "return SLAG_POP_REF();" )
              elseIf (m.return_type.is_primitive())
                print( "return SLAG_POP_" )
                whichIs (m.return_type)
                  case TypeManager.type_real64:  println("REAL64();")
                  case TypeManager.type_real32:  println("REAL32();")
                  case TypeManager.type_int64:   println("INT64();")
                  case TypeManager.type_int32:   println("INT32();")
                  case TypeManager.type_char:    println("CHAR();")
                  case TypeManager.type_byte:    println("BYTE();")
                  case TypeManager.type_logical: println("LOGICAL();")
                endWhichIs
              else
                # Compound
                println( "return SLAG_POP( $ );" (m.return_type.x_name) )
              endIf
            endIf
          endIf
          indent -= 2
          println( "}" )
          println
          nextIteration
        endIf

        # local vars
        local var any_locals = false
        forEach (v in m.local_vars.from(m.parameters.count))
          if (not v.is_catch_var)
            any_locals = true
            if (v.type.is_reference)
              println( "SlagObject* $;" (v.x_name) )
            else
              println( "$ $;" (v.type.x_name,v.x_name) )
            endIf
          endIf
        endForEach
        if (any_locals) println

        m.body.to_cpp
        if (is_initializer) println( "return context;" )

        indent -= 2

        println( "}" )
        println
      endForEach
      println

    method write_continue_id( CmdStructure cmd )
      if (cmd.referenced)
        println( "next_$:;" (cmd.id) )
      endIf

    method write_end_id( CmdStructure cmd )
      if (cmd.referenced)
        println( "end_$:;" (cmd.id) )
      endIf

    method native_call( MethodInfo m, String context, CmdList args ).String
      local String[] string_args()
      forEach (arg in args) string_args.add(arg.to_cpp)
      return native_call( m, context, string_args )

    method native_call( MethodInfo m, String context, String[] args ).String
      which (m.full_signature[0])
        case 'G':
          which (m.full_signature)
            case "Global::time_ms().Int64":
              return "slag_get_time_ms()"
          endWhich

        case 'M':
          which (m.full_signature)
            case "Math::abs(Int64).Int64":
              return "abs($)" (args[0])

            case "Math::abs(Int32).Int32":
              return "abs($)" (args[0])

            case "Math::abs(Real64).Real64":
              return "sxc_abs($)" (args[0])

            case "Math::floor(Real64).Real64":
              return "floor($)" (args[0])

            case "Math::sqrt(Real64).Real64":
              return "sqrt($)" (args[0])

            case "Math::sin(Radians).Real64":
              return "sin(($).property_value)" (args[0])

            case "Math::cos(Radians).Real64":
              return "cos(($).property_value)" (args[0])

            case "Math::tan(Radians).Real64":
              return "tan(($).property_value)" (args[0])

            case "Math::asin(Real64).Radians":
              return "CompoundRadians(asin($))" (args[0])

            case "Math::acos(Real64).Radians":
              return "CompoundRadians(acos($))" (args[0])

            case "Math::atan(Real64).Radians":
              return "CompoundRadians(atan($))" (args[0])

            case "Math::atan2(Real64,Real64).Radians":
              return "CompoundRadians(atan2($,$))" (args[0],args[1])
          endWhich

        case 'S':
          which (m.full_signature)
            case "String::count().Int32":
              return "(((SlagString*)$)->count)" (context)
            case "String::hash_code().Int32":
              return "(((SlagString*)$)->hash_code)" (context)
          endWhich

        others:

      endWhich

      return null

endClass

augment Cmd
    method to_cpp.String
      throw Error( "to_cpp() undefined for type " + type_name )

    method statement_to_cpp.String
      return to_cpp
endAugment

augment CmdStatementList
    method to_cpp.String
      forEach (statement in statements) 
        local var st = statement.statement_to_cpp
        if (st?) CPPWriter.print(st); CPPWriter.println(';')
      endForEach
      return null
endAugment

augment CmdList
    method to_cpp.String
      local StringBuilder buffer()
      local var first = true
      forEach (cmd in this) 
        if (first) first = false
        else buffer.print(",")
        buffer.print(cmd.to_cpp)
      endForEach
      return buffer.to_String
endAugment

augment CmdEscape
    method to_cpp.String
      return "goto end_" + id
endAugment

augment CmdNextIteration
    method to_cpp.String
      return "goto next_" + id
endAugment

augment CmdReturnNil
    method to_cpp.String
      return "return"
endAugment

augment CmdReturnValue
    method to_cpp.String
      return "return "+ operand.to_cpp
endAugment

augment CmdBlock
    method to_cpp.String
      CPPWriter.println( "{" )
      CPPWriter.indent += 2
      body.to_cpp
      CPPWriter.indent -= 2
      CPPWriter.println( "}" )
      CPPWriter.write_end_id( this )
      return null
endAugment

augment CmdTry
    method to_cpp.String
      if (CPPWriter.use_longjmp)
        CPPWriter.println( "SlagCatchHandler try_env_$;" (unique_Int32) )
      endIf
      CPPWriter.println( "SLAG_TRY" )
      CPPWriter.println( "{" )
      CPPWriter.indent += 2
      body.to_cpp
      CPPWriter.indent -= 2
      CPPWriter.println( "}" )
      local var err_name = "_err" + unique_Int32
      if (catches.count?)
        CPPWriter.println( "SLAG_CATCH($)" (err_name) )
        CPPWriter.println( "{" )
        CPPWriter.indent += 2
        if (CPPWriter.use_longjmp)
          CPPWriter.println( "slag_cur_catch->unhook();" );
          CPPWriter.println( "SlagTypeInfo* $_type = slag_thrown_error->type;" (err_name) )
        else
          CPPWriter.println( "SlagTypeInfo* $_type = $->type;" (err_name,err_name) )
        endIf
        local var first=true
        forEach (c in catches)
          if (first) first = false
          else CPPWriter.print("else ")
          CPPWriter.println( "if ($_type->instance_of(&type_$))" (err_name,c.var_info.type.x_name) )
          CPPWriter.println( "{" )
          CPPWriter.indent += 2
          if (CPPWriter.use_longjmp)
            CPPWriter.println( "SlagObject* $ = slag_thrown_error;" (c.var_info.x_name) )
          else
            CPPWriter.println( "SlagObject* $ = $;" (c.var_info.x_name,err_name) )
          endIf
          c.to_cpp
          CPPWriter.indent -= 2
          CPPWriter.println( "}" )
        endForEach
        CPPWriter.println( "else" )
        CPPWriter.println( "{" )
        if (CPPWriter.use_longjmp)
          CPPWriter.println( "  SLAG_THROW(slag_thrown_error);" )
        else
          CPPWriter.println( "  SLAG_THROW($);" (err_name) )
        endIf
        CPPWriter.println( "}" )
        CPPWriter.indent -= 2
        CPPWriter.println( "}" )
      endIf
      CPPWriter.write_end_id( this )
      return null
endAugment

augment CmdCatch
    method to_cpp.String
      body.to_cpp
      return null
endAugment

augment CmdThrow
    method to_cpp.String
      #return "SLAG_THROW( (SlagObject*)$ )" (operand.to_cpp)
      return "SLAG_THROW( $ )" (operand.to_cpp)
endAugment

augment CmdIf
    method to_cpp.String
      CPPWriter.println( "if (" + condition.to_cpp + ")" )
      CPPWriter.println( "{" )
      CPPWriter.indent += 2
      body.to_cpp
      CPPWriter.indent -= 2
      CPPWriter.println( "}" )

      forEach (e in elseifs) e.to_cpp

      if (else_cmd?) 
        CPPWriter.println( "else" )
        CPPWriter.println( "{" )
        CPPWriter.indent += 2
        else_cmd.to_cpp
        CPPWriter.indent -= 2
        CPPWriter.println( "}" )
      endIf
      CPPWriter.write_end_id( this )

      return null
endAugment

augment CmdElseIf
    method to_cpp.String
      CPPWriter.println( "else if (" + condition.to_cpp + ")" )
      CPPWriter.println( "{" )
      CPPWriter.indent += 2
      body.to_cpp
      CPPWriter.indent -= 2
      CPPWriter.println( "}" )
      return null
endAugment

augment CmdLoop
    method to_cpp.String
      CPPWriter.println( "for (;;)" )
      CPPWriter.println( "{" )
      CPPWriter.indent += 2
      CPPWriter.write_continue_id( this )
      body.to_cpp
      CPPWriter.indent -= 2
      CPPWriter.println( "}" )
      CPPWriter.write_end_id( this )
      return null
endAugment

augment CmdWhile
    method to_cpp.String
      CPPWriter.println( "while ($)" (condition.to_cpp) )
      CPPWriter.println( "{" )
      CPPWriter.indent += 2
      body.to_cpp
      CPPWriter.write_continue_id( this )
      CPPWriter.indent -= 2
      CPPWriter.println( "}" )
      CPPWriter.write_end_id( this )
      return null
endAugment

augment CmdContingent
    method to_cpp.String
      CPPWriter.println( "{" )
      CPPWriter.indent += 2
      body.to_cpp
      CPPWriter.println( "satisfied_$:;" (id) )
      if (satisfied_body?) 
        CPPWriter.println( "{" )
        CPPWriter.indent += 2
        satisfied_body.to_cpp
        CPPWriter.indent -= 2
        CPPWriter.println( "}" )
      endIf
      CPPWriter.println( "goto end_$;" (id) )
      CPPWriter.println( "unsatisfied_$:;" (id) )
      if (unsatisfied_body?) 
        CPPWriter.println( "{" )
        CPPWriter.indent += 2
        unsatisfied_body.to_cpp
        CPPWriter.indent -= 2
        CPPWriter.println( "}" )
      endIf
      CPPWriter.indent -= 2
      CPPWriter.println( "}" )
      CPPWriter.write_end_id( this )
      return null
endAugment

augment CmdNecessary
    method to_cpp.String
      CPPWriter.println( "if (!$) goto unsatisfied_$;" (operand.to_cpp,id) )
      return null
endAugment

augment CmdSufficient
    method to_cpp.String
      CPPWriter.println( "if ($) goto satisfied_$;" (operand.to_cpp,id) )
      return null
endAugment

augment CmdBreakpoint
    method to_cpp.String
      CPPWriter.println( //printf( "breakpoint $\\n" );// (id) )
      return null
endAugment

augment CmdLiteralString
    method to_cpp.String
      return "str$.value" (TypeManager.strings[value])
endAugment

augment CmdLiteralInt64
    method to_cpp.String
      if ((value & 0x8000000000000000)?) return "0x" + value.to_String(16) + "LL"
      return value + "LL"
endAugment

augment CmdLiteralInt32
    method to_cpp.String
      return "" + value
endAugment

augment CmdLiteralChar
    method to_cpp.String
      return "((SlagChar)$)" (Int32(value))
endAugment

augment CmdLiteralByte
    method to_cpp.String
      return "((SlagByte)$)" (Int32(value))
endAugment

augment CmdLiteralReal64
    method to_cpp.String
      return "sxc_int64_as_real64(0x$LL)" ((value as Int64).to_String(16))
endAugment

augment CmdLiteralReal32
    method to_cpp.String
      if (value == Int32(value))
        return "$(.1)" (value)
      else
        return "sxc_int32_as_real32(0x$)" ((value as Int32).to_String(16))
      endIf
endAugment

augment CmdLiteralLogical
    method to_cpp.String
      which (value)
        case true:  return "true"
        others:     return "false"
      endWhich
endAugment

augment CmdLiteralNull
    method to_cpp.String
      return "NULL"
endAugment

augment CmdThisReference
    method to_cpp.String
      #return "(SlagObject*)context"
      return "context"
endAugment

augment CmdSingletonReference
    method to_cpp.String
      return "sxc_singletons[$]" (of_type.singleton_index)
endAugment

augment CmdSingletonWrite
    method to_cpp.String
      return "sxc_write_ref( &sxc_singletons[$], $ )" (of_type.singleton_index,new_value.to_cpp)
endAugment

augment CmdPropertyRead
    method to_cpp.String
      return "(($*)$)->$" (context.type.x_name,context.to_cpp,var_info.x_name)
endAugment

augment CmdCompoundPropertyRead
    method to_cpp.String
      return "(($)($.$))" (var_info.type.x_name,context.to_cpp,var_info.x_name)
endAugment

augment CmdLocalVarRead
    method to_cpp.String
      if (var_info.type.is_reference)
        #return "(SlagObject*)" + var_info.x_name
        return var_info.x_name
      else
        return var_info.x_name
      endIf
endAugment

augment CmdPropertyWrite
    method to_cpp.String
      if (var_info.type.is_reference)
        #return "sxc_write_ref( &((($*)(SlagObject*)$)->$), $ )" ...
          #(context.type.x_name,context.to_cpp, var_info.x_name, new_value.to_cpp)
        return "sxc_write_ref( &((($*)$)->$), $ )" ...
          (context.type.x_name,context.to_cpp, var_info.x_name, new_value.to_cpp)
      else
        return "(($*)$)->$ = $" ...
          (context.type.x_name,context.to_cpp, var_info.x_name, new_value.to_cpp)
      endIf
endAugment

augment CmdLocalVarWrite
    method to_cpp.String
      return "$ = $" (var_info.x_name, new_value.to_cpp)
endAugment

augment CmdStaticCall
    method statement_to_cpp.String
      return to_cpp(false)

    method to_cpp.String
      return to_cpp(true)

    method to_cpp( Logical cast_return_value ).String
      if (method_info.type_context is TypeManager.type_generic_array)
        which (method_info.name)
          case "count":
            return "((SlagArray*)$)->array_count" (context.to_cpp)
          #case "copy_from":
            #return "GenericArray__copy_from__GenericArray_Int32_Int32_Int32($,$,$,$,$)" ...
            #(context.to_cpp,args[0].to_cpp,args[1].to_cpp,args[2].to_cpp,args[3].to_cpp)
          #case "clear":
            #return "GenericArray__clear__Int32_Int32($,$,$)" ...
              #(context.to_cpp,args[0].to_cpp,args[1].to_cpp)
          #others:
            #return "TODO:"+method_info.x_name
        endWhich
      endIf

      local String native_call_str = null
      if (method_info.is_native)
        native_call_str = CPPWriter.native_call( method_info, context.to_cpp, args )
      endIf

      if (native_call_str?) return native_call_str

      if (args.count?)
        return "$()($,$)" (method_info.x_name,context.to_cpp,args.to_cpp)
      else
        return "$()($)" (method_info.x_name,context.to_cpp)
      endIf

endAugment

augment CmdDynamicCall
    method statement_to_cpp.String
      return to_cpp(false)

    method to_cpp.String
      return to_cpp(true)

    method to_cpp( Logical cast_return_value ).String
      if (method_info.type_context is TypeManager.type_generic_array)
        return "FIXME_ARRAY:"
      endIf

      if (args.count?)
        return "Call$()($,$,$)" ...
          (method_info.group.x_name,method_info.group.index,context.to_cpp,args.to_cpp)
      else
        return "Call$()($,$)" ...
          (method_info.group.x_name,method_info.group.index,context.to_cpp)
      endIf
endAugment

augment CmdNewObject
    method to_cpp.String
      if (args.count?)
        return "$()(type_$.create(),$)" (method_info.x_name,of_type.x_name,args.to_cpp)
      else
        return "$()(type_$.create())" (method_info.x_name,of_type.x_name)
      endIf
endAugment

augment CmdNewCompound
  METHODS
    method to_cpp.String
      if (args.count?)
        return "$()($)" (of_type.x_name,args.to_cpp)
      else
        return "$()" (of_type.x_name)
      endIf
endAugment

augment CmdNarrowingCast
  METHODS
    method statement_to_cpp.String
      return operand.statement_to_cpp

    method to_cpp.String
      return operand.to_cpp
endAugment

augment CmdWideningCast
  METHODS
    method statement_to_cpp.String
      return operand.statement_to_cpp

    method to_cpp.String
      return operand.to_cpp
endAugment

augment CmdAs
  METHODS
    method statement_to_cpp.String
      return operand.statement_to_cpp

    method to_cpp.String
      local var op = operand.to_cpp
      if (as_type is operand.type) return op

      if (as_type.is_primitive)
        whichIs (as_type)
          case TypeManager.type_int64:  return "sxc_real64_as_int64($)" (op)
          case TypeManager.type_int32:  return "sxc_real32_as_int32($)" (op)
          case TypeManager.type_real64: return "sxc_int64_as_real64($)" (op)
          case TypeManager.type_real32: return "sxc_int32_as_real32($)" (op)
        endWhichIs
      endIf

      return "sxc_as($,&type_$)" (operand.to_cpp,as_type.x_name)
endAugment

augment CmdCoerceAs
  METHODS
    method statement_to_cpp.String
      return operand.statement_to_cpp

    method to_cpp.String
      if (as_type.is_reference) return "(($*)$)" (as_type.x_name,operand.to_cpp)
      return operand.to_cpp
endAugment

augment CmdCmpInstanceOf
  METHODS
    method to_cpp.String
      return "sxc_instance_of($,&type_$)" (operand.to_cpp,of_type.x_name)
endAugment

augment CmdNegate
  METHODS
    method to_cpp.String
      return "-$" (operand.to_cpp)
endAugment

augment CmdNot
  METHODS
    method to_cpp.String
      if (operand.type.is_logical)
        return "!$" (operand.to_cpp)
      else
        return "~" + (operand.to_cpp)
      endIf
endAugment

augment CmdLogicalNot
  METHODS
    method to_cpp.String
      return "~" + (operand.to_cpp)
endAugment

augment CmdCastToInt64
  METHODS
    method statement_to_cpp.String
      return operand.statement_to_cpp

    method to_cpp.String
      return "((SlagInt64)$)" (operand.to_cpp)
endAugment

augment CmdCastToInt32
  METHODS
    method statement_to_cpp.String
      return operand.statement_to_cpp

    method to_cpp.String
      return "((SlagInt32)$)" (operand.to_cpp)
endAugment

augment CmdCastToChar
  METHODS
    method statement_to_cpp.String
      return operand.statement_to_cpp

    method to_cpp.String
      return "((SlagChar)$)" (operand.to_cpp)
endAugment

augment CmdCastToByte
  METHODS
    method statement_to_cpp.String
      return operand.statement_to_cpp

    method to_cpp.String
      return "((SlagByte)$)" (operand.to_cpp)
endAugment

augment CmdCastToReal64
  METHODS
    method statement_to_cpp.String
      return operand.statement_to_cpp

    method to_cpp.String
      return "((SlagReal64)$)" (operand.to_cpp)
endAugment

augment CmdCastToReal32
  METHODS
    method statement_to_cpp.String
      return operand.statement_to_cpp

    method to_cpp.String
      return "((SlagReal32)$)" (operand.to_cpp)
endAugment

augment CmdCastToLogical
  METHODS
    method statement_to_cpp.String
      return operand.statement_to_cpp

    method to_cpp.String
      return "($ != 0)" (operand.to_cpp)
endAugment

augment CmdCmpEQ
  method to_cpp.String
    if (lhs.type.is_compound)
      return "$.equals($)" (lhs.to_cpp,rhs.to_cpp)
    else
      return "($ == $)" (lhs.to_cpp,rhs.to_cpp)
    endIf
endAugment

augment CmdCmpNE
  method to_cpp.String
    if (lhs.type.is_compound)
      return "(!$.equals($))" (lhs.to_cpp,rhs.to_cpp)
    else
      return "($ != $)" (lhs.to_cpp,rhs.to_cpp)
    endIf
endAugment

augment CmdCmpLE
  method to_cpp.String
    return "($ <= $)" (lhs.to_cpp,rhs.to_cpp)
endAugment

augment CmdCmpLT
  method to_cpp.String
    return "($ < $)" (lhs.to_cpp,rhs.to_cpp)
endAugment

augment CmdCmpGT
  method to_cpp.String
    return "($ > $)" (lhs.to_cpp,rhs.to_cpp)
endAugment

augment CmdCmpGE
  method to_cpp.String
    return "($ >= $)" (lhs.to_cpp,rhs.to_cpp)
endAugment

augment CmdCmpIs
  method to_cpp.String
    return "($ == $)" (lhs.to_cpp,rhs.to_cpp)
endAugment

augment CmdCmpIsNot
  method to_cpp.String
    return "($ != $)" (lhs.to_cpp,rhs.to_cpp)
endAugment

augment CmdCmpIsNull
    method to_cpp.String
      return "($ == NULL)" (operand.to_cpp)
endAugment

augment CmdCmpIsNotNull
    method to_cpp.String
      return "($ != NULL)" (operand.to_cpp)
endAugment

augment CmdMathOp
    method to_cpp.String
      which ($symbol)
        case "%":
          return "sxc_mod($,$)" (lhs.to_cpp,rhs.to_cpp)
        case "^":
          local String result = ""
          whichIs (lhs.type)
            case TypeManager.type_real64: result = "(SlagReal64)"
            case TypeManager.type_real32: result = "(SlagReal32)"
            case TypeManager.type_int64:  result = "(SlagInt64)"
            case TypeManager.type_int32:  result = "(SlagInt32)"
          endWhichIs
          return result + "pow((double)$,(double)$)" (lhs.to_cpp,rhs.to_cpp)
        others:
          return "(" + lhs.to_cpp + $symbol + rhs.to_cpp + ")"
      endWhich
endAugment

augment CmdBitwiseOp
    method to_cpp.String
      which ($symbol)
        case "~": 
          return "($^$)" (lhs.to_cpp,rhs.to_cpp)
        others:
          return "(" + lhs.to_cpp + $symbol + rhs.to_cpp + ")"
      endWhich
endAugment

augment CmdLazyAnd
    method to_cpp.String
      return "($ && $)" (lhs.to_cpp,rhs.to_cpp)
endAugment

augment CmdLazyOr 
    method to_cpp.String
      return "($ || $)" (lhs.to_cpp,rhs.to_cpp)
endAugment

augment CmdLeftShifted
    method to_cpp.String
      return "($<<$)" (lhs.to_cpp,rhs.to_cpp)
endAugment

augment CmdRightShifted
    method to_cpp.String
      return "sxc_shr($,$)" (lhs.to_cpp,rhs.to_cpp)
endAugment

augment CmdRightXShifted
    method to_cpp.String
      return "($>>$)" (lhs.to_cpp,rhs.to_cpp)
endAugment

augment CmdArrayCreate
    method to_cpp.String
      return "type_$.create($)" (of_type.x_name,size_expr.to_cpp)
endAugment

augment CmdArrayGet
    method to_cpp.String
      local var element_type = context.type.element_type
      if (element_type.is_reference)
        return "(($**)(((SlagArray*)$)->data))[$]" (element_type.x_name,context.to_cpp,index_expr.to_cpp)
      else
        return "(($*)(((SlagArray*)$)->data))[$]" (element_type.x_name,context.to_cpp,index_expr.to_cpp)
      endIf
endAugment

augment CmdArraySet
    method to_cpp.String
      #return "$[$]=$" (context.to_cpp,index_expr.to_cpp,value_expr.to_cpp)

      local var element_type = context.type.element_type
      if (element_type.is_reference)
        return "sxc_write_ref( ((SlagObject**)(((SlagArray*)$)->data))+$, $ )" ...
          (context.to_cpp,index_expr.to_cpp,value_expr.to_cpp)
      else
        return "(($*)(((SlagArray*)$)->data))[$] = $" ...
          (element_type.x_name,context.to_cpp,index_expr.to_cpp,value_expr.to_cpp)
      endIf
endAugment

augment CmdArrayDuplicate
    method to_cpp.String
      return "slag_duplicate_array($)" (context.to_cpp)
endAugment

augment CmdThisPropertyAddAndAssign
  method to_cpp.String
    #return "(($*)(SlagObject*)context)->$ += $" (var_info.type_context.x_name,var_info.x_name,operand.to_cpp)
    return "(($*)context)->$ += $" (var_info.type_context.x_name,var_info.x_name,operand.to_cpp)
endAugment

augment CmdThisPropertySubAndAssign
  method to_cpp.String
    #return "(($*)(SlagObject*)context)->$ -= $" (var_info.type_context.x_name,var_info.x_name,operand.to_cpp)
    return "(($*)context)->$ -= $" (var_info.type_context.x_name,var_info.x_name,operand.to_cpp)
endAugment

augment CmdThisPropertyMulAndAssign 
  method to_cpp.String
    #return "(($*)(SlagObject*)context)->$ *= $" (var_info.type_context.x_name,var_info.x_name,operand.to_cpp)
    return "(($*)context)->$ *= $" (var_info.type_context.x_name,var_info.x_name,operand.to_cpp)
endAugment

augment CmdThisPropertyDivAndAssign
  method to_cpp.String
    #return "(($*)(SlagObject*)context)->$ /= $" (var_info.type_context.x_name,var_info.x_name,operand.to_cpp)
    return "(($*)context)->$ /= $" (var_info.type_context.x_name,var_info.x_name,operand.to_cpp)
endAugment

augment CmdThisPropertyModAndAssign
  method to_cpp.String
    #return "(($*)(SlagObject*)context)->$ = sxc_mod(context->$,$)" (var_info.type_context.x_name,var_info.x_name,var_info.x_name,operand.to_cpp)
    return "(($*)context)->$ = sxc_mod(context->$,$)" (var_info.type_context.x_name,var_info.x_name,var_info.x_name,operand.to_cpp)
endAugment

augment CmdLocalVarAddAndAssign
  method to_cpp.String
    return "$ += $" (var_info.x_name,operand.to_cpp)
endAugment

augment CmdLocalVarSubAndAssign
  method to_cpp.String
    return "$ -= $" (var_info.x_name,operand.to_cpp)
endAugment

augment CmdLocalVarMulAndAssign 
  method to_cpp.String
    return "$ *= $" (var_info.x_name,operand.to_cpp)
endAugment

augment CmdLocalVarDivAndAssign
  method to_cpp.String
    return "$ = $/$" (var_info.x_name,var_info.x_name,operand.to_cpp)
endAugment

augment CmdLocalVarModAndAssign
  method to_cpp.String
    return "$ = sxc_mod($,$)" (var_info.x_name,var_info.x_name,operand.to_cpp)
endAugment

augment CmdThisPropertyIncrement
  method to_cpp.String
    #return "++((($*)(SlagObject*)context)->$)" (var_info.type_context.x_name,var_info.x_name)
    return "++((($*)context)->$)" (var_info.type_context.x_name,var_info.x_name)
endAugment

augment CmdThisPropertyDecrement
  method to_cpp.String
    #return "--((($*)(SlagObject*)context)->$)" (var_info.type_context.x_name,var_info.x_name)
    return "--((($*)context)->$)" (var_info.type_context.x_name,var_info.x_name)
endAugment

augment CmdLocalVarIncrement
  method to_cpp.String
    return "++$" (var_info.x_name)
endAugment

augment CmdLocalVarDecrement
  method to_cpp.String
    return "--$" (var_info.x_name)
endAugment

