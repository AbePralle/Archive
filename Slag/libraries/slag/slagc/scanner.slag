#=====================================================================
# scanner.slag
#
# 2009.12.14 / Abe Pralle - Created
#=====================================================================

class SlagScannerTest
  METHODS
    method init
      local SlagScanner scanner( "hello.slag" )

      forEach (token in scanner)
        println( token )
        if (token.type == Token.eof) escapeForEach
      endForEach
endClass

singleton class Errors
  PROPERTIES
    errors() : SlagError[]

  METHODS
    method add( SlagError err ).Logical
      errors.add( err )
      return errors.count >= 10

    method any.Logical
      return errors.count?

    method full.Logical
      return errors.count < 10

    method print
      if (errors.count == 0) return
      println

      #forEach (err in errors) err.common_path_length = common_path_length

      local var work_list = duplicate(errors)
      while (work_list.count?)
        local var filename = work_list.first.filename
        if (filename is null) filename = "[Internal]"
        
        local Int32 survivors = 0
        local var first = true
        forEach (err in work_list)
          local var err_filename = err.filename
          if (err_filename is null) err_filename = "[Internal]"

          if (err_filename == filename)
            if (first)
              first = false
              forEach (1..13) print( "======" )
              local String fname = filename
              #if (fname.count > common_path_length) fname = fname.excluding_leftmost(common_path_length)
              if (fname[0] == '[') println( "\n$" (fname) )
              else                 println( //\nIn file "$"// (fname) )
              forEach (1..13) print( "======" )
              println
            else
              forEach (1..13) print( " - - -" )
              println( "\n" )
            endIf

            print( err )

          else
            work_list[survivors] = err
            survivors++
          endIf
        endForEach
        work_list.discard_from(survivors)
      endWhile

      forEach (1..13) print( "------" )
      println( "\nErrors: $" (errors.count) )

endClass

class SlagError : Error
  PROPERTIES
    filename : String
    pos  : ParsePos
    common_path_length : Int32

  METHODS
    method init( Token t, message )
      filename = t.filename
      pos  = t.pos

    method init( filename, message )

    method to_String.String
      local StringBuilder buffer()

      if (pos.line == 0)
        buffer.print( "ERROR:  " )
        local var first = true
        forEach (line in message.word_wrap(64))
          if (first) first = false
          else buffer.print( "        " )
          buffer.println( line )
        endForEach
        buffer.println
        return buffer.to_String
      endIf

      local var line_str = "LINE $:  " (pos.line)

      buffer.print( "ERROR:  " )
      forEach (9..line_str.count) buffer.print(' ')

      local var first = true
      forEach (line in message.word_wrap(64))
        if (first) 
          first = false
        else 
          forEach (1..line_str.count) buffer.print(' ')
        endIf
        buffer.println( line )
      endForEach
      buffer.println

      buffer.print( line_str )
      first = true
      forEach (line in LineReader(get_context(filename,pos) ))
        if (first) 
          first = false
        else 
          forEach (1..line_str.count) buffer.print(' ')
        endIf
        buffer.println(line)
      endForEach

      return buffer.to_String

    method get_context( String fname, ParsePos p ).String
      try
        local StringBuilder buffer()

        #local ParseReader file( SlagFile.open(fname) )
        local ParseReader file( File(fname) )
        while (file.has_another and file.cur_pos.line < p.line) file.read

        if (file.has_another)

          local String context = file.read_line
          local var col = p.column - 1

          while (col > 0 and context[0]==' ') context = context.substring(1); --col

          if (col > (66-16))
            local var diff = col - (66-19)
            context = "...$" (context.substring( diff ))
            col = (66-19)+3
          endIf

          if (context.count > 66-2) context = "$..." (context.leftmost(66-5))

          buffer.println( context )
          forEach (1..col) buffer.print(' ')
          buffer.print( '^' )
        endIf

        return buffer.to_String

      catch (FileError err)
        return "[Error accessing file to read context!]"
      endTry

endClass

class PriorSlagError : SlagError
  PROPERTIES
    prior_filename : String
    prior_pos : ParsePos

  METHODS
    method init( Token t, message, Token prior_t )
      prior.init( t, message )
      if (prior_t?)
        prior_filename = prior_t.filename
        prior_pos = prior_t.pos
      else
        prior_filename = "[Internal]"
      endIf

    method to_String.String
      local var line_str = "LINE $:  " (pos.line)
      local var prior_line_str = "LINE $:  " (prior_pos.line)
      local var count = max(line_str.count,prior_line_str.count)

      if (prior_filename == "[Internal]") return prior.to_String

      local StringBuilder buffer( prior.to_String )
      if (prior_filename != filename)
        buffer.println( //In "$"// (prior_filename) )
      endIf
      buffer.print( prior_line_str )
      forEach ((prior_line_str.count+1)..count) buffer.print(' ')

      local var first = true
      forEach (line in LineReader(get_context(prior_filename,prior_pos) ))
        if (first) 
          first = false
        else 
          forEach (1..count) buffer.print(' ')
        endIf
        buffer.println(line)
      endForEach
      return buffer.to_String
endClass


class Token
  ENUMERATE
    eof
    eol
    defined_value

    comment
    identifier
    placeholder_id
    literal_string
    literal_int
    literal_hex_int
    literal_char
    literal_real
    literal_logical

    literal_null

    symbol_open_template
    symbol_close_template
    symbol_dimension

    symbol_defined

    symbol_deferred
    symbol_singleton
    symbol_runtime

    symbol_class
    symbol_aspect
    symbol_enum
    symbol_augment
    symbol_compound

    symbol_with


    # begin non-statement start symbols
    symbol_endclass
    symbol_endaspect
    symbol_endenum
    symbol_endaugment
    symbol_endwith
    symbol_methods
    symbol_properties
    symbol_class_methods
    symbol_class_properties
    symbol_categories
    symbol_enumerate
    symbol_singletons
    symbol_open_bracket
    # end non-statement start symbols

    symbol_close_bracket

    symbol_underlying
    symbol_overlaying
    symbol_public
    symbol_private
    symbol_readonly
    symbol_requisite
    symbol_propagated
    symbol_abstract
    symbol_generic
    symbol_native
    symbol_method
    symbol_local

    symbol_scope

    symbol_if
    symbol_elseif
    symbol_else
    symbol_endif
    symbol_which
    symbol_whichis
    symbol_case
    symbol_casenext
    symbol_others
    symbol_endwhich
    symbol_endwhichis
    symbol_contingent
    symbol_satisfied
    symbol_unsatisfied
    symbol_endcontingent
    symbol_necessary
    symbol_sufficient
    symbol_block
    symbol_endblock
    symbol_try
    symbol_catch
    symbol_endtry
    symbol_throw
    symbol_loop
    symbol_endloop
    symbol_while
    symbol_endwhile
    symbol_foreach
    symbol_in
    symbol_of
    symbol_endforeach

    symbol_escapeif
    symbol_escapewhich
    symbol_escapewhichis
    symbol_escapecontingent
    symbol_escapeblock
    symbol_escapetry
    symbol_escapeloop
    symbol_escapewhile
    symbol_escapeforeach
    symbol_nextiteration
    symbol_removecurrent

    symbol_increment
    symbol_decrement

    symbol_assign
    symbol_bitwise_xor_with_assign
    symbol_bitwise_or_with_assign
    symbol_bitwise_and_with_assign
    symbol_add_with_assign
    symbol_subtract_with_assign
    symbol_multiply_with_assign
    symbol_divide_with_assign
    symbol_mod_with_assign
    symbol_power_with_assign
    symbol_member_with_assign

    symbol_insert_underlying
    symbol_duplicate
    symbol_breakpoint
    symbol_noaction
    symbol_return

    symbol_upto
    symbol_uptolessthan
    symbol_downto
    symbol_downtogreaterthan
    symbol_step

    symbol_logical_xor
    symbol_logical_or
    symbol_logical_and

    symbol_instanceof
    symbol_notinstanceof
    symbol_as
    symbol_coerce_as
    symbol_is
    symbol_isnot

    symbol_compare
    symbol_eq
    symbol_ne
    symbol_le
    symbol_ge
    symbol_lt
    symbol_gt

    symbol_bitwise_xor
    symbol_bitwise_or
    symbol_ampersand

    symbol_plus
    symbol_minus
    symbol_times
    symbol_divide
    symbol_mod
    symbol_power

    symbol_bitwise_not
    symbol_logical_not
    symbol_logicalize

    symbol_comma
    symbol_colon
    symbol_semicolon

    symbol_member_access
    symbol_open_paren
    symbol_close_paren
    symbol_open_brace
    symbol_close_brace
    symbol_close_comment

    symbol_framework
    symbol_endframework
    symbol_useframework

    #symbol_meta_foreach_property
    #symbol_meta_endforeach
    #symbol_meta_property_name
    #symbol_meta_property_type

  CLASS_PROPERTIES
    first_type_def = symbol_class    : Int32
    last_type_def =  symbol_compound : Int32
    first_non_statement_start_symbol = symbol_endclass   : Int32
    last_non_statement_start_symbol  = symbol_singletons : Int32

    filenames()     : HashTable<<String,Int32>>
    filename_list() : String[]

  PROPERTIES
    type       : Int32
    file_index : Int32
    pos        : ParsePos
    content    : String

  METHODS
    method init( type, String filename, pos, content=null )
      local var entry = filenames.find(filename)
      if (entry?)
        file_index = entry.value
      else
        file_index = filename_list.count
        filenames[filename] = file_index
        filename_list.add(filename)
      endIf

    method create_duplicate.Token
      return Token( type, filename, pos, content )

    method error( String mesg ).SlagError
      return SlagError(this,mesg)

    method prior_error( String mesg, Token prior_t ).SlagError
      return PriorSlagError(this,mesg,prior_t)

    method filename.String
      return filename_list[file_index]

    method to_String.String
      which (type)
        case eof:     return "[End of File]"
        case eol:     return "[End of Line]"
        case comment: return "#" + content
        case literal_string: return //"$"// (content)
        case identifier, placeholder_id, literal_int, literal_hex_int, literal_real, literal_logical:
          return content
        case literal_char: 
          local var value = content[0]
          if (value >= 32 and value <= 126) return "'$'" (content)
          else return "Char($)" (value)
        others:
          return SlagScanner.reverse_keyword_lookup[type]
      endWhich
endClass

class SlagScanner : Reader<<Token>>
  CLASS_PROPERTIES
    keywords : HashTable<<String,Int32>>
    defines  : HashTable<<String,String>>

    reverse_keyword_lookup : HashTable<<Int32,String>>

  CLASS_METHODS

    method add_define( String id, String value )
      set_up_keywords

      defines[id] = value
      keywords[id] = Token.defined_value
      if (id == "DEBUG") add_define( "ASSERT", "debug_assert" )

    method set_up_keywords
      if (keywords?) return

      keywords = HashTable<<String,Int32>>(256)
      defines  = HashTable<<String,String>>(128)
      reverse_keyword_lookup = HashTable<<Int32,String>>()

      keywords["defined"]    = Token.symbol_defined

      keywords["deferred"]   = Token.symbol_deferred
      keywords["singleton"]  = Token.symbol_singleton
      keywords["runtime"]    = Token.symbol_runtime

      keywords["class"]      = Token.symbol_class
      keywords["aspect"]     = Token.symbol_aspect
      keywords["enum"]       = Token.symbol_enum
      keywords["augment"]    = Token.symbol_augment
      keywords["compound"]   = Token.symbol_compound
      keywords["endClass"]   = Token.symbol_endclass
      keywords["endAspect"]  = Token.symbol_endaspect
      keywords["endEnum"]    = Token.symbol_endenum
      keywords["endAugment"] = Token.symbol_endaugment

      keywords["METHODS"]          = Token.symbol_methods
      keywords["PROPERTIES"]       = Token.symbol_properties
      keywords["VARS"]             = Token.symbol_properties
      keywords["CLASS_METHODS"]    = Token.symbol_class_methods
      keywords["CLASS_PROPERTIES"] = Token.symbol_class_properties
      keywords["CLASS_VARS"]       = Token.symbol_class_properties
      keywords["CATEGORIES"]       = Token.symbol_categories
      keywords["ENUMERATE"]        = Token.symbol_enumerate
      keywords["SINGLETONS"]       = Token.symbol_singletons

      keywords["underlying"]    = Token.symbol_underlying
      keywords["overlaying"]    = Token.symbol_overlaying
      keywords["public"]        = Token.symbol_public
      keywords["private"]       = Token.symbol_private
      keywords["readOnly"]      = Token.symbol_readonly
      keywords["requisite"]     = Token.symbol_requisite
      keywords["propagated"]    = Token.symbol_propagated
      keywords["abstract"]      = Token.symbol_abstract
      keywords["generic"]       = Token.symbol_generic
      keywords["native"]        = Token.symbol_native
      keywords["method"]        = Token.symbol_method
      keywords["local"]         = Token.symbol_local

      keywords["true"]          = Token.literal_logical
      keywords["false"]         = Token.literal_logical
      keywords["Boolean"]       = Token.literal_logical
      keywords["gt"]            = Token.literal_int
      keywords["eq"]            = Token.literal_int
      keywords["lt"]            = Token.literal_int

      keywords["infinity"]      = Token.literal_real
      keywords["NaN"]           = Token.literal_real
      keywords["pi"]            = Token.literal_real
      keywords["null"]          = Token.literal_null

      keywords["::"]            = Token.symbol_scope

      keywords["if"]            = Token.symbol_if
      keywords["elseIf"]        = Token.symbol_elseif
      keywords["else"]          = Token.symbol_else
      keywords["endIf"]         = Token.symbol_endif
      keywords["which"]         = Token.symbol_which
      keywords["whichIs"]       = Token.symbol_whichis
      keywords["case"]          = Token.symbol_case
      keywords["caseNext"]      = Token.symbol_casenext
      keywords["others"]        = Token.symbol_others
      keywords["endWhich"]      = Token.symbol_endwhich
      keywords["endWhichIs"]    = Token.symbol_endwhichis
      keywords["contingent"]    = Token.symbol_contingent
      keywords["satisfied"]     = Token.symbol_satisfied
      keywords["unsatisfied"]   = Token.symbol_unsatisfied
      keywords["endContingent"] = Token.symbol_endcontingent
      keywords["necessary"]     = Token.symbol_necessary
      keywords["sufficient"]    = Token.symbol_sufficient
      keywords["block"]         = Token.symbol_block
      keywords["endBlock"]      = Token.symbol_endblock
      keywords["try"]           = Token.symbol_try
      keywords["catch"]         = Token.symbol_catch
      keywords["endTry"]        = Token.symbol_endtry
      keywords["throw"]         = Token.symbol_throw
      keywords["loop"]          = Token.symbol_loop
      keywords["endLoop"]       = Token.symbol_endloop
      keywords["while"]         = Token.symbol_while
      keywords["endWhile"]      = Token.symbol_endwhile
      keywords["forEach"]       = Token.symbol_foreach
      keywords["in"]            = Token.symbol_in
      keywords["of"]            = Token.symbol_of
      keywords["endForEach"]    = Token.symbol_endforeach

      keywords["escapeIf"]          = Token.symbol_escapeif
      keywords["escapeWhich"]       = Token.symbol_escapewhich 
      keywords["escapeWhichIs"]     = Token.symbol_escapewhichis
      keywords["escapeContingent"]  = Token.symbol_escapecontingent
      keywords["escapeBlock"]       = Token.symbol_escapeblock
      keywords["escapeTry"]         = Token.symbol_escapetry
      keywords["escapeLoop"]        = Token.symbol_escapeloop
      keywords["escapeWhile"]       = Token.symbol_escapewhile
      keywords["escapeForEach"]     = Token.symbol_escapeforeach

      keywords["nextIteration"]     = Token.symbol_nextiteration

      keywords["removeCurrent"]     = Token.symbol_removecurrent

      keywords["insertUnderlying"]  = Token.symbol_insert_underlying
      keywords["duplicate"]         = Token.symbol_duplicate
      keywords["breakpoint"]        = Token.symbol_breakpoint
      keywords["noAction"]          = Token.symbol_noaction
      keywords["return"]            = Token.symbol_return

      keywords["upTo"]              = Token.symbol_upto
      keywords["upToLessThan"]      = Token.symbol_uptolessthan
      keywords["downTo"]            = Token.symbol_downto
      keywords["downToGreaterThan"] = Token.symbol_downtogreaterthan
      keywords["step"]              = Token.symbol_step

      keywords["xor"]               = Token.symbol_logical_xor
      keywords["or"]                = Token.symbol_logical_or
      keywords["and"]               = Token.symbol_logical_and

      keywords["instanceOf"]        = Token.symbol_instanceof
      keywords["notInstanceOf"]     = Token.symbol_notinstanceof
      keywords["as"]                = Token.symbol_as
      keywords["coerceAs"]          = Token.symbol_coerce_as
      keywords["is"]                = Token.symbol_is
      keywords["isNot"]             = Token.symbol_isnot

      keywords["not"]               = Token.symbol_logical_not
      keywords["with"]              = Token.symbol_with
      keywords["endWith"]           = Token.symbol_endwith

      keywords["framework"]         = Token.symbol_framework
      keywords["endFramework"]      = Token.symbol_endframework
      keywords["useFramework"]      = Token.symbol_useframework

      #keywords["[forEach property]"]= Token.symbol_meta_foreach_property
      #keywords["[endForEach]"]      = Token.symbol_meta_endforeach
      #keywords["[property.name]"]   = Token.symbol_meta_property_name
      #keywords["[property.type]"]   = Token.symbol_meta_property_type

      forEach (key in keywords.keys) reverse_keyword_lookup[keywords[key]] = key

      reverse_keyword_lookup[Token.symbol_open_template]           = "<<"
      reverse_keyword_lookup[Token.symbol_close_template]          = ">>"
      reverse_keyword_lookup[Token.symbol_dimension]               = "[]"
      reverse_keyword_lookup[Token.symbol_open_bracket]            = "["
      reverse_keyword_lookup[Token.symbol_close_bracket]           = "]"
      reverse_keyword_lookup[Token.symbol_scope]                   = "::"
      reverse_keyword_lookup[Token.symbol_increment]               = "++"
      reverse_keyword_lookup[Token.symbol_decrement]               = "--"
      reverse_keyword_lookup[Token.symbol_assign]                  = "="
      reverse_keyword_lookup[Token.symbol_bitwise_xor_with_assign] = "~="
      reverse_keyword_lookup[Token.symbol_bitwise_or_with_assign]  = "|="
      reverse_keyword_lookup[Token.symbol_bitwise_and_with_assign] = "&="
      reverse_keyword_lookup[Token.symbol_add_with_assign]         = "+="
      reverse_keyword_lookup[Token.symbol_subtract_with_assign]    = "-="
      reverse_keyword_lookup[Token.symbol_multiply_with_assign]    = "*="
      reverse_keyword_lookup[Token.symbol_divide_with_assign]      = "/="
      reverse_keyword_lookup[Token.symbol_mod_with_assign]         = "%="
      reverse_keyword_lookup[Token.symbol_power_with_assign]       = "^="
      reverse_keyword_lookup[Token.symbol_member_with_assign]      = ".="
      reverse_keyword_lookup[Token.symbol_compare]                 = "<>"
      reverse_keyword_lookup[Token.symbol_eq]                      = "=="
      reverse_keyword_lookup[Token.symbol_ne]                      = "!="
      reverse_keyword_lookup[Token.symbol_le]                      = "<="
      reverse_keyword_lookup[Token.symbol_ge]                      = ">="
      reverse_keyword_lookup[Token.symbol_lt]                      = "<"
      reverse_keyword_lookup[Token.symbol_gt]                      = ">"
      reverse_keyword_lookup[Token.symbol_bitwise_xor]             = "~"
      reverse_keyword_lookup[Token.symbol_bitwise_or]              = "|"
      reverse_keyword_lookup[Token.symbol_ampersand]               = "&"
      reverse_keyword_lookup[Token.symbol_plus]                    = "+"
      reverse_keyword_lookup[Token.symbol_minus]                   = "-"
      reverse_keyword_lookup[Token.symbol_times]                   = "*"
      reverse_keyword_lookup[Token.symbol_divide]                  = "/"
      reverse_keyword_lookup[Token.symbol_mod]                     = "%"
      reverse_keyword_lookup[Token.symbol_power]                   = "^"
      reverse_keyword_lookup[Token.symbol_bitwise_not]             = "!"
      reverse_keyword_lookup[Token.symbol_logicalize]              = "?"
      reverse_keyword_lookup[Token.symbol_comma]                   = ","
      reverse_keyword_lookup[Token.symbol_colon]                   = ":"
      reverse_keyword_lookup[Token.symbol_semicolon]               = ";"
      reverse_keyword_lookup[Token.symbol_member_access]           = "."
      reverse_keyword_lookup[Token.symbol_open_paren]              = "("
      reverse_keyword_lookup[Token.symbol_close_paren]             = ")"
      reverse_keyword_lookup[Token.symbol_open_brace]              = "{"
      reverse_keyword_lookup[Token.symbol_close_brace]             = "}"
      reverse_keyword_lookup[Token.symbol_close_comment]           = "}#"
      #reverse_keyword_lookup[Token.symbol_backslash]               = "\\"


  PROPERTIES
    filename : String
    src      : ParseReader
    next     : Token
    text_buffer() : StringBuilder
    allow_defines=true    : Logical
    exhausted : Logical

    value_0x80000000( "80000000", 16 ) : BigInt
    value_0xffffffff( "ffffffff", 16 ) : BigInt
    value_signed_64_low  = BigInt(2)^63   : BigInt
    value_signed_64_high = BigInt(2)^64-1 : BigInt

  METHODS
    method init( filename )
      add_define( "ASSERT", "if (false)" )  # compiled out by default
      local Date today()
      add_define( "DATE", //"$.$(02).$(02)"// (today.year,today.month,today.day) )
      add_define( "Int", "Int32" )
      add_define( "Integer", "Int32" )
      add_define( "Real", "Real64" )

      src = ParseReader( File(filename).to_List.(ArrayList<<Char>>) )
      prep_next

    method init( filename, String _src )
      add_define( "ASSERT", "if (false)" )  # compiled out by default
      local Date today()
      add_define( "DATE", //"$.$(02).$(02)"// (today.year,today.month,today.day) )
      add_define( "Int", "Int32" )
      add_define( "Integer", "Int32" )
      add_define( "Real", "Real64" )

      src = ParseReader(_src)
      prep_next

    method has_another.Logical
      return (not exhausted)

    method peek.Token
      while (next.type == Token.comment) 
        local var comment = next.content
        prep_next
        if (next.type == Token.eol) next.content = comment
      endWhile
      return next
      
    method read.Token
      while (next.type == Token.comment)
        local var comment = next.content
        prep_next
        if (next.type == Token.eol) next.content = comment
      endWhile

      if (next.type == Token.eof)
        if (not exhausted) exhausted = true; return Token(eol,next.filename,next.pos)
        return next
      else
        local var result = next
        prep_next
        return result
      endIf

    method consume( Int32 token_type ).Logical
      if (peek.type != token_type) return false
      read
      return true

    method must_consume( Int32 token_type, String expected )
      if (not consume(token_type)) throw next.error( "'$' expected." (expected) )


    method must_scan_id( String error_mesg ).String
      if (next.type == Token.identifier)
        return read.content
      else
        throw next.error( error_mesg )
      endIf
 
    method prep_next
      loop
        consume_ws

        if (not src.has_another)
          if (not exhausted)
            exhausted = true
            next = Token(eol,filename,src.cur_pos)
          else
            next = Token(eof,filename,src.cur_pos)
          endIf
          return
        endIf
        
        local var ch = src.peek

        if (ch >= '0' and ch <='9')
          scan_number
          return
        endIf

        if ( (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or ch == '_' )
          local var pos = src.cur_pos
          next = Token( identifier, filename, pos, scan_id )
          if (not check_for_keywords) nextIteration
          return
        endIf

        if (ch == '"')
          scan_string
          return
        endIf

        if (not scan_symbol) nextIteration
        return
      endLoop

    method consume_ws
      while (src.consume(' ') or src.consume('\t')) noAction

    method scan_number
      next = Token( 0, filename, src.cur_pos )

      local Int32 base = 10
      if (src.peek == '0')
        # Either just literal "0", the start of a decimal number
        # "0.xxx", or the start of a base specifier:
        # 0x, 0d, 0c, 0b (hex, decimal, octal, binary)
        src.read
        if (src.peek == '.')
          if (src.peek(2).is_digit)
            next.type = Token.literal_real
            src.read  # discard '.'
            next.content = (scan_fraction(10) as Int64).to_String(16)
          else
            next.type = Token.literal_int
            next.content = "0"
          endIf
          return
        endIf

        which (src.peek)
          case 'x': base = 16
          case 'd': base = 10
          case 'c': base = 8
          case 'b': base = 2
          others:
            # save the peek value for later; just return the zero
            next.type = Token.literal_int
            next.content = "0"
            return
        endWhich
        src.read

      endIf
      scan_number(base)

      if (base == 16 and next.type == Token.literal_int)
        # The rule in Slag is that base 10 integers >= 2^31 count as an Int64 
        # while base 16 integers up to 2^31-1 (0xffffffff) count as an Int32.
        # Therefore we distinguish hex literals between 0x80000000 and 0xffffffff
        # by giving them a token type of their own.
        if (next.content.count == 10 or next.content.count >= 19)
          # 0x80000000..0xffffffff all have 10 digits in base 10
          # 2^63+ has 19+ digits in base 10
          local BigInt n( next.content )
          if ((n >= value_0x80000000 and n <= value_0xffffffff) ...
              or (n >= value_signed_64_low and n <= value_signed_64_high))
            next.type = Token.literal_hex_int
            next.content = n.to_String(16)
          endIf
        endIf
      endIf

    method scan_number( Int32 base )
      if (src.peek.is_digit(base))
        # whole ['.' decimal]
        next.content = scan_integer( base )
        if (src.peek == '.' and src.peek(2).is_digit(base))
          src.read
          next.type = Token.literal_real
          next.content = ((next.content.to_Real64 + scan_fraction(base)) as Int64).to_String(16)
        else
          next.type = Token.literal_int
        endIf

      elseIf (src.peek == '.' and src.peek(2).is_digit(base))
        # '.' decimal
        # This conditional only happens with a number like: 0x.f3)
        src.read
        next.type = Token.literal_real
        next.content = (scan_fraction(base) as Int64).to_String(16)

      endIf

    method scan_integer( Int32 base ).String
      local BigInt n(0)

      while ( src.peek().is_digit(base) )
        n = n * base + src.read.to_value
      endWhile

      if (n == BigInt.i64_limit and base == 16) n = -n

      return n.to_String

    method scan_fraction( Int32 base ).Real64
      local Real64 n(0)
      local Real64 count = 0

      while (src.peek.is_digit(base))
        n = n * base + src.read.to_value
        count++
      endWhile

      # .1001 = 9 / (2^4)
      n /= base ^ count
      return n

    method scan_id.String
      text_buffer.clear
      local var ch = src.peek
      while ( (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or
          (ch >= '0' and ch <= '9') or ch == '_' )
          text_buffer.print( src.read )
        if (not src.has_another) escapeWhile
        ch = src.peek
      endWhile

      return text_buffer.to_String

    method check_for_keywords.Logical
      local var entry = keywords.find( next.content )
      if (entry?)
        local var type = entry.value
        next.type = type

        which (type)
          case Token.literal_logical:
            if (next.content == "Boolean") throw next.error( "Use 'Logical' instead of 'Boolean'." )

          case Token.literal_int:
            local var content = next.content
            if (content == "gt") next.content = "1"
            elseIf (content == "eq") next.content = "0"
            elseIf (content == "lt") next.type = Token.literal_hex_int; next.content = "ffffffff"

          case Token.literal_real:
            local var content = next.content
            if (content == "infinity") next.content = (infinity as Int64).to_String(16)
            elseIf (content == "NaN") next.content = (NaN as Int64).to_String(16)
            elseIf (content == "pi")  next.content = (pi as Int64).to_String(16)

          case Token.symbol_defined:
            while (src.consume(' ') or src.consume('\t')) noAction
            if (not src.consume('(')) throw next.error( "Open '(' expected." )

            while (src.consume(' ') or src.consume('\t')) noAction
            local var ch = src.peek
            if (not ((ch >= 'A' and ch <= 'Z') or (ch >= 'a' and ch <= 'z') or ch == '_'))
              throw next.error( "Identifier expected'." )
            endIf
            next.type = Token.literal_logical
            local var define_id = scan_id
            if (defines.contains(define_id)) next.content = "true"
            else                             next.content = "false"

            while (src.consume(' ') or src.consume('\t')) noAction
            if (not src.consume(')')) throw next.error( "Close ')' expected." )

          case Token.defined_value:
            # insert defined value
            local var value = defines[next.content]
            if (src.pos < value.count)
              local Array<<Char>> new_data( src.remaining + value.count )
              new_data.copy_from( src.data, src.pos, 0, src.remaining )
              new_data.copy_from( value.to_Array, 0, src.remaining, value.count )
              local var line = src.line
              local var column = src.column
              src.init( new_data )
              src.line = line
              src.column = column
            else
              src.pos -= value.count
              src.remaining += value.count
              src.data.copy_from( value.to_Array, 0, src.pos, value.count )
            endIf

            return false

          others:
            next.content = null
        endWhich
      endIf
      return true

    method scan_string
      local var pos = src.cur_pos

      text_buffer.clear
      src.read
      while (src.has_another)
        if (src.consume('"'))
          next = Token( literal_string, filename, pos, text_buffer.to_String ); return
        endIf
        text_buffer.print( scan_literal_char )
      endWhile

      throw Token( 0, filename, pos ).error( "Missing closing quote (\") on string literal." )

    method scan_alternate_string.String
      text_buffer.clear
      while (src.has_another)
        local Char ch
        if (src.peek == '/')
          ch = src.read
          if (src.consume('/')) return text_buffer.to_String
        else
          ch = scan_literal_char
        endIf
        text_buffer.print( ch )
      endWhile

      throw Token( 0, filename, src.cur_pos ).error( "Missing closing quote (//) on string literal." )

    method scan_literal_char.Char
      local Char ch = src.peek
      which (ch)
        case 10:  
          throw Token( 0, filename, src.cur_pos ).error( "Character expected; found end of line." )

        case '\\':
          local var src_pos = src.cur_pos
          src.read
          which (src.read)
            case 'n':  return Char(10)
            case 'r':  return Char(13)
            case 't':  return Char(9)
            case '0':  return Char(0)
            case '/':  return '/';
            case '\'': return '\'';
            case '\\': return '\\';
            case '"':  return '"';
            case 'u':
              local Char unicode = 0
              forEach (1..4)
                if (not src.peek.is_digit(16))
                  ch = src.peek
                  local String str
                  if (ch < 32 or ch == 127) str = "$" (Int32(ch))
                  else str = "$" (ch)
                  throw Token( 0, filename, src_pos ).error( "Invalid hex digit '$'." (str) )
                endIf
                unicode = unicode.left_shifted(4) + src.read.to_value
              endForEach
              return unicode

            others:
              throw Token( 0, filename, src_pos ).error( ...
                "Invalid escape sequence.  Supported: \\n \\r \\t \\0 \\/ \\' \\\\ \\\" \\$XXXX." ("u") )
          endWhich

        others:
          src.read  # == ch 
          if ((ch & 0x80) != 0)
            # Handle UTF8 encoding
            local Char ch2 = src.read

            if ((ch & 0x20) == 0)
              # %110xxxxx 10xxxxxx
              ch  &= 0x1f;
              ch2 &= 0x3f;
              ch = ch.left_shifted(6) | ch2;
            else
              # %1110xxxx 10xxxxxx 10xxxxxx
              local Char ch3 = src.read
              ch  &= 15;
              ch2 &= 0x3f;
              ch3 &= 0x3f;
              ch = ch.left_shifted(12) | ch2.left_shifted(6) | ch3;
            endIf
          endIf
          return ch
      endWhich

    method scan_symbol.Logical
      next = Token( 0, filename, src.cur_pos )

      local var ch = src.read
      which (ch)
        case '\n':  
          next.type = eol
        case '!':  
          if (src.consume('=')) next.type = symbol_ne
          else next.type = symbol_bitwise_not
        case '#':
          next.type = comment
          if (src.consume("{"))
            next.content = scan_multi_line_comment
          else
            next.content = scan_single_line_comment
          endIf
        case '$':
          next.type = placeholder_id
          next.content = "$" + scan_id
        case '%':
          if     (src.consume('=')) next.type = symbol_mod_with_assign
          else   next.type = symbol_mod
        case '&': 
          if     (src.consume('&')) throw next.error( "Use 'and' instead of '&&'." )
          elseIf (src.consume('=')) next.type = symbol_bitwise_and_with_assign
          else   next.type = symbol_ampersand
        case '\'': 
          next.type = literal_char
          next.content = "" + scan_literal_char
          if (not src.consume('\''))
            throw next.error( "Missing closing '." )
          endIf
        case '(':  next.type = symbol_open_paren
        case ')':  next.type = symbol_close_paren
        case '*':
          if     (src.consume('=')) next.type = symbol_multiply_with_assign
          else   next.type = symbol_times
        case '+':
          if     (src.consume('=')) next.type = symbol_add_with_assign
          elseIf (src.consume('+')) next.type = symbol_increment
          else   next.type = symbol_plus
        case ',':  next.type = symbol_comma
        case '-':
          if     (src.consume('=')) next.type = symbol_subtract_with_assign
          elseIf (src.consume('-')) next.type = symbol_decrement
          else   next.type = symbol_minus
        case '.': 
          if (src.consume('.'))
            if (src.consume('.')) 
              # ellipsis
              consume_ws
              while (src.consume("#"))
                if (src.consume("{")) scan_multi_line_comment
                else scan_single_line_comment
              endWhile
              if (not src.consume('\n')) throw next.error( "End of line expected after '...'." )
              return false
            elseIf (src.consume('<'))
              next.type = symbol_uptolessthan
            elseIf (src.consume('>'))
              next.type = symbol_downtogreaterthan
            else 
              next.type = symbol_upto
            endIf
          elseIf (src.consume('='))
            next.type = symbol_member_with_assign
          elseIf (src.peek.is_digit)
            next.type = Token.literal_real
            next.content = (scan_fraction(10) as Int64).to_String(16)
          else
            next.type = symbol_member_access
          endIf
        case '/':
          if     (src.consume('/')) next.type = literal_string; next.content = scan_alternate_string
          elseIf (src.consume('=')) next.type = symbol_divide_with_assign
          else   next.type = symbol_divide
        case ':': 
          if (src.consume(':')) next.type = symbol_scope
          else next.type = symbol_colon
        case ';': next.type = symbol_semicolon
        case '<': 
          if     (src.consume('<')) next.type = symbol_open_template
          elseIf (src.consume('=')) next.type = symbol_le
          elseIf (src.consume('>')) next.type = symbol_compare
          else   next.type = symbol_lt
        case '=': 
          if (src.consume('=')) next.type = symbol_eq
          else next.type = symbol_assign
        case '>': 
          if     (src.consume('=')) next.type = symbol_ge
          elseIf (src.consume('>')) next.type = symbol_close_template
          else   next.type = symbol_gt
        case '?': next.type = symbol_logicalize
        case '[':
          if     (src.consume(']')) next.type = symbol_dimension
          else   next.type = symbol_open_bracket; return check_for_special
          #case '\\':
          #next.type = symbol_backslash
        case ']':  next.type = symbol_close_bracket
        case '^':
          if     (src.consume('=')) next.type = symbol_power_with_assign
          else   next.type = symbol_power
        case '{': next.type = symbol_open_brace
        case '|': 
          if     (src.consume('=')) next.type = symbol_bitwise_or_with_assign
          elseIf (src.consume('|')) throw next.error( "Use 'or' instead of '||'." )
          else   next.type = symbol_bitwise_or
        case '}': 
          if     (src.consume('#')) next.type = symbol_close_comment  # used for error reporting
          else   next.type = symbol_close_brace
        case '~': 
          if     (src.consume('=')) next.type = symbol_bitwise_xor_with_assign
          else   next.type = symbol_bitwise_xor
        others:
          throw next.error( "Unrecognized symbol: " + ch )
      endWhich
      return true

    method check_for_special.Logical
      if (src.consume("define "))
        while (src.consume(' ')) noAction
        local var ch = src.peek
        if (not ((ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or ch == '_'))
          throw next.error( "Identifier expected after 'define'." )
        endIf

        local var define_id = scan_id

        src.consume(' ')
        text_buffer.clear
        while (not src.consume(']'))
          if (not src.has_another or src.peek == '\n')
            throw next.error( "Missing ']' at end." )
          endIf
          src.consume('\\')
          text_buffer.add( src.read )
        endWhile

        local var define_value = text_buffer.to_String
        if (allow_defines) 
          if (define_id == define_value) throw next.error( "Recursive define." )
          add_define( define_id, define_value )
        endIf
        return false

      elseIf (src.consume("string]"))
        # string block
        consume_ws
        src.consume(10)

        next.type = Token.literal_string
        local StringBuilder buffer()
        while (src.has_another)
          local var ch = src.read
          if (ch == '[')
            if (src.consume("endString]"))
              next.content = buffer.to_String
              return true
            else
              buffer.print('[')
            endIf
          else
            buffer.print(ch)
          endIf
        endWhile
        throw next.error( "No closing [endString] found." )

      #{
      elseIf (src.consume("join"))
        prep_next
        if (next.type != Token.identifier) throw next.error( "Identifier expected." )
        local var lhs = next.content
        prep_next
        if (next.type != Token.identifier) throw next.error( "Identifier expected." )
        next = duplicate(next)
        next.content = lhs + next.content
        consume_ws
        if (not src.consume(']')) throw next.error( "Closing ']' expected." )
        return true

      elseIf (src.consume("forEach"))
        # forEach Meta block
        consume_ws
        prep_next
        contingent
          necessary (next.type == Token.identifier)
          necessary (next.content == "property")
        unsatisfied
          throw next.error( "Keyword 'property' expected." )
        endContingent
        consume_ws
        if (not src.consume(']')) throw next.error( "Closing ']' expected." )
        next = duplicate(next)
        next.type = Token.symbol_meta_foreach_property
        return true

      elseIf (src.consume("endForEach"))
        consume_ws
        if (not src.consume(']')) throw next.error( "Closing ']' expected." )
        next = duplicate(next)
        next.type = Token.symbol_meta_endforeach
        return true

      elseIf (src.consume("property.name"))
        consume_ws
        if (not src.consume(']')) throw next.error( "Closing ']' expected." )
        next = duplicate(next)
        next.type = Token.symbol_meta_property_name
        return true

      elseIf (src.consume("property.type"))
        consume_ws
        if (not src.consume(']')) throw next.error( "Closing ']' expected." )
        next = duplicate(next)
        next.type = Token.symbol_meta_property_type
        return true
      }#

      else
        return true
      endIf

    method scan_single_line_comment.String
      text_buffer.clear
      while (src.has_another)
        local Char ch = src.peek
        if (ch == '\n') escapeWhile
        text_buffer.add(src.read)
      endWhile
      return text_buffer.to_String

    method scan_multi_line_comment.String
      local StringBuilder buffer()
      forEach (ch in src)
        if (ch == '#')
          if (src.peek == '{')
            src.read
            buffer.print( "#{" )
            buffer.print( scan_multi_line_comment )
            buffer.print( "}#" )
            nextIteration
          endIf
        elseIf (ch == '}')
          if (src.peek == '#')
            src.read
            return buffer.to_String
          endIf
        endIf
        buffer.add(ch)
      endForEach
      throw next.error( "'}#' expected; found end of file." )

endClass

